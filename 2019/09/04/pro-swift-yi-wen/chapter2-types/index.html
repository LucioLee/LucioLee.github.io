<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="第二章 类型（Types）, iOS">
    <meta name="description" content="我最喜欢的 Swift 单行代码是使用flatMap()来对一个数组进行降维和过滤：
let myCustomViews = allViews.flatMap { $0 as? MyCustomView }
这行代码看起来很简单，但它包含了">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>第二章 类型（Types） | Li&#39;s Note</title>
    <link rel="icon" type="image/png" href="https://cdn.kongyintianxia.com/feedback_0_evYm8e_20190906.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.kongyintianxia.com/feedback_0_evYm8e_20190906.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Li's Note</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.kongyintianxia.com/feedback_0_evYm8e_20190906.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Li's Note</div>
        <div class="logo-desc">
            
            iOS 程序猿一枚~
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/0.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        第二章 类型（Types）
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Swift/" target="_blank">
                                <span class="chip bg-color">Swift</span>
                            </a>
                        
                            <a href="/tags/Pro-Swift/" target="_blank">
                                <span class="chip bg-color">Pro Swift</span>
                            </a>
                        
                            <a href="/tags/范型/" target="_blank">
                                <span class="chip bg-color">范型</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Pro-Swift/" class="post-category" target="_blank">
                                Pro Swift
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-09-04
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        11.5k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        44 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>我最喜欢的 <em>Swift</em> 单行代码是使用<code>flatMap()</code>来对一个数组进行降维和过滤：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> myCustomViews <span class="token operator">=</span> allViews<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">MyCustomView</span> <span class="token punctuation">}</span></code></pre>
<p>这行代码看起来很简单，但它包含了很多很棒的 <em>Swift</em> 特性，如果你将其与 <em>Objective-C</em> 中最接近的开箱即用的特性进行比较，就会发现这些特性最为明显：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">NSArray</span><span class="token operator">&lt;</span><span class="token builtin">MyCustomView</span> <span class="token operator">*</span><span class="token operator">></span> <span class="token operator">*</span>myCustomViews <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">NSArray</span><span class="token operator">&lt;</span><span class="token builtin">MyCustomView</span> <span class="token operator">*</span><span class="token operator">></span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>allViews filteredArrayUsingPredicate<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">NSPredicate</span> predicateWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token function">BOOL</span><span class="token punctuation">(</span>id _Nonnull evaluatedObject<span class="token punctuation">,</span> <span class="token builtin">NSDictionary</span><span class="token operator">&lt;</span><span class="token builtin">NSString</span> <span class="token operator">*</span><span class="token punctuation">,</span>id<span class="token operator">></span> <span class="token operator">*</span> _Nullable bindings<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">[</span>evaluatedObject isKindOfClass<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token builtin">MyCustomView</span> <span class="token keyword">class</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
<p>– <em>Matt Gallagher, CocoaWithLove.com</em> 的作者</p>
<h2 id="高效初始化器-Useful-initializers"><a href="#高效初始化器-Useful-initializers" class="headerlink" title="高效初始化器(Useful initializers)"></a>高效初始化器(Useful initializers)</h2><p>理解 <em>Swift</em> 中初始化器是如何工作的并不容易，但这也是你们很久以前学过的东西，所以我就不在这里重复了。相反，我想关注一些有趣的初始化器，它们可能有助你更有效地使用常见的 <em>Swift</em> 类型。</p>
<h3 id="重复值-Repeating-values"><a href="#重复值-Repeating-values" class="headerlink" title="重复值(Repeating values)"></a>重复值(Repeating values)</h3><p>我最喜欢的字符串和数组初始化器是 <code>repeat:count:</code>，它允许你快速创建大量值。例如，你可以通过在一些文本下面写等号来创建 <em>Markdown</em> 文本格式的标题，如下所示:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">This</span> <span class="token keyword">is</span> a heading
<span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">==</span></code></pre>
<p><em>Markdown</em> 是一种很有用的格式，因为它可以被计算机解析，同时对人类也具有视觉吸引力，而且下划线为<code>repeat:count:</code> 提供了一个很好的例子。要使用这个初始化器，为其第一个参数指定一个字符串，并为其第二个参数指定重复的次数，如下所示:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> heading <span class="token operator">=</span> <span class="token string">"This is a heading"</span>
<span class="token keyword">let</span> underline <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">"="</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> heading<span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span></code></pre>
<p>你也可以对数组这样做：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> equalsArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">"="</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> heading<span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span></code></pre>
<p>这个数组初始化器足够灵活，你可以使用它非常容易地创建多维数组。例如，这创建了一个准备填充 <em>10x10</em> 数组:</p>
<pre class=" language-swift"><code class="language-swift"> <span class="token keyword">var</span> board <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span></code></pre>
<h3 id="转换为数字和从数字转换-Converting-to-and-from-numbers"><a href="#转换为数字和从数字转换-Converting-to-and-from-numbers" class="headerlink" title="转换为数字和从数字转换(Converting to and from numbers)"></a>转换为数字和从数字转换(Converting to and from numbers)</h3><p>当我看到这样的代码时，我头疼不已:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str1 <span class="token operator">=</span> <span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>someInteger<span class="token delimiter variable">)</span></span>"</span></code></pre>
<p>这是浪费和不必要的，但是字符串插值是一个很好的特性，使用它是值得原谅。事实上，我很确定我已经使用过它好几次了，毫无疑问！</p>
<p>但 <em>Swift</em> 有一个简单、更好的方法，可以使用初始化器根据整型创建字符串类型:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>someInteger<span class="token punctuation">)</span></code></pre>
<p>当使用这种方式进行转换时，事情会变得稍微困难一些，因为你可能会尝试传入一个无效的数字，例如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> int1 <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"elephant"</span><span class="token punctuation">)</span></code></pre>
<p>那么，这个初始化器将返回 <code>Int?</code> ：如果你给它一个有效的数字，你会得到一个整数，否则你会得到<code>nil</code>。</p>
<p>如果你不想要一个可选值，你应该对结果解包:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> int2 <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"1989"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>int2<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>或者，使用空合操作符（<code>??</code>）提供一个合理的默认值，如下所示:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> int3 <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"1989"</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token number">0</span>
<span class="token function">print</span><span class="token punctuation">(</span>int3<span class="token punctuation">)</span></code></pre>
<p><em>Swift</em> 在这两个初始化器上有一些处理不同变量基数的变体。例如，如果你想使用十六进制(以 <em>16</em> 为基数)，你可以让 <em>Swift</em> 给你一个十六进制数字的字符串表示形式:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">)</span></code></pre>
<p>这将把 <em>str3</em> 设置为 <strong>1c</strong>。如果你更喜欢 <strong>1C</strong>，即大写——请尝试以下方法:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str4 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">,</span> uppercase<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span></code></pre>
<p>要将其转换回整数—请记住它是可选值!——用这个:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> int4 <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"1C"</span><span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">)</span></code></pre>
<h3 id="唯一的数组（Unique-arrays）"><a href="#唯一的数组（Unique-arrays）" class="headerlink" title="唯一的数组（Unique arrays）"></a>唯一的数组（Unique arrays）</h3><p>如果你有一个包含重复值的数组，并且希望找到一种快速删除重复值的方法，则你需要的找的是<code>Set</code>。这是一个内建的数据类型，具有与普通数组互相转换的初始化器，这意味着你只需使用初始化器即可快速高效地消除数组中的重复数据：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> scoresSet <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span>
<span class="token keyword">let</span> uniqueScores <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>scoresSet<span class="token punctuation">)</span></code></pre>
<p>这就是它所需要的一切——难怪我这么喜欢集合！</p>
<h3 id="字典的容量（Dictionary-capacities）"><a href="#字典的容量（Dictionary-capacities）" class="headerlink" title="字典的容量（Dictionary capacities）"></a>字典的容量（Dictionary capacities）</h3><p>以一个简单的初始化器结尾：如果要单独向字典添加项，但是知道想添加多少项，请使用<code>minimumCapacity:initializer</code>创建字典，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> dictionary <span class="token operator">=</span> <span class="token builtin">Dictionary</span><span class="token operator">&lt;</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token operator">></span><span class="token punctuation">(</span>minimumCapacity<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span></code></pre>
<p>这有助于通过预先分配足够的空间来快速优化执行。注意：在后台，<em>Swift</em> 的字典增加了 <em>2</em> 的幂次方的容量，所以当你请求一个像 <em>100</em> 这样的非 <em>2</em> 的幂次方的容量时，你实际上会得到一个最小容量为 <em>128</em> 的字典。记住，这是最小容量——如果你想添加更多的对象，这不是问题。</p>
<h2 id="枚举（Enums）"><a href="#枚举（Enums）" class="headerlink" title="枚举（Enums）"></a>枚举（Enums）</h2><p>在模式匹配一章中，我已经讨论了枚举关联值，但这里我想重点讨论枚举本身，因为它们的功能非常强大。</p>
<p>让我们从一个非常简单的枚举开始，跟踪一些基本的颜色:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> unknown
   <span class="token keyword">case</span> blue
   <span class="token keyword">case</span> green
   <span class="token keyword">case</span> pink
   <span class="token keyword">case</span> purple
   <span class="token keyword">case</span> red
<span class="token punctuation">}</span></code></pre>
<p>如果你愿意，可以将所有<code>case</code>项写在一行上，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> unknown<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">,</span> pink<span class="token punctuation">,</span> purple<span class="token punctuation">,</span> red
<span class="token punctuation">}</span></code></pre>
<p>为了便于测试，让我们用一个表示玩具的简单结构体来包装它：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Toy</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">let</span> color<span class="token punctuation">:</span> <span class="token builtin">Color</span>
<span class="token punctuation">}</span></code></pre>
<p><em>Swift</em> 的类型推断可以推断出<code>Toy</code>的<code>color</code>属性是一个<code>Color</code>枚举，这意味着在创建玩具结构体时不需要编写<code>Color.blue</code>。例如，我们可以创建两个这样的玩具：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> barbie <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Barbie"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>pink<span class="token punctuation">)</span>
<span class="token keyword">let</span> raceCar <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Lightning McQueen"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>red<span class="token punctuation">)</span></code></pre>
<h3 id="初始值（Raw-values）"><a href="#初始值（Raw-values）" class="headerlink" title="初始值（Raw values）"></a>初始值（Raw values）</h3><p>让我们从初始值开始：每个枚举项的基础数据类型。默认情况下，枚举没有初始值，因此如果需要初始值，则需要声明它。例如，我们可以给颜色一个这样的整型初始值：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span><span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> unknown<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">,</span> pink<span class="token punctuation">,</span> purple<span class="token punctuation">,</span> red
<span class="token punctuation">}</span></code></pre>
<p>只需添加<code>:Int</code> <em>Swift</em> 将为每种颜色都指定了一个匹配的整数，从<em>0</em> 开始向上计数。也就是说，<code>unknown</code>等于 <em>0</em> ，<code>blue</code>等于 <em>1</em> ，以此类推。有时，默认值对你来说并没有用，所以如果需要，你可以为每个初始值指定单独的整数。或者，你可以指定一个不同的起点，使 <em>Xcode</em> 从那里开始计数。</p>
<p>例如，我们可以像这样为太阳系的四个行星创建一个枚举:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Planet</span><span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> mercury <span class="token operator">=</span> <span class="token number">1</span>
   <span class="token keyword">case</span> venus
   <span class="token keyword">case</span> earth
   <span class="token keyword">case</span> mars
   <span class="token keyword">case</span> unknown
<span class="token punctuation">}</span></code></pre>
<p>通过明确指定水星的值为 <em>1</em>，<em>Xcode</em> 将从那里向上计数：金星是 <em>2</em>，地球是 <em>3</em>，火星是 <em>4</em>。</p>
<p>现在行星的编号是合理的，我们可以像这样得到任何的行星的初始值:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> marsNumber <span class="token operator">=</span> <span class="token builtin">Planet</span><span class="token punctuation">.</span>mars<span class="token punctuation">.</span>rawValue</code></pre>
<p>另一种方法并不那么容易：是的，既然我们已经有了初始值，你可以从一个数字创建一个<code>Planet</code> 枚举，但是这样做会创建一个可选的枚举。这是因为你可以尝试创建一个初始值为 <em>99</em> 的行星，而这个行星并不存在——至少目前还不存在。</p>
<p>幸运的是，我在行星枚举中添加了一个<code>unknown</code>，当请求无效的行星编号时，我们可以从其初始值创建行星枚举，并使用空值合并运算符提供合理的默认值：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> mars <span class="token operator">=</span> <span class="token function">Planet</span><span class="token punctuation">(</span>rawValue<span class="token punctuation">:</span> <span class="token number">556</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token builtin">Planet</span><span class="token punctuation">.</span>unknown</code></pre>
<p>对于行星来说，数字是可以的，但是当涉及到颜色时，你可能会发现使用字符串更容易。除非你有非常特殊的需要，否则只需指定<code>String</code>作为枚举的原始数据类型就足以为它们提供有意义的名称—— <em>Swift</em> 会自动将你的枚举名称映射到一个字符串。例如，这将打印 <strong><em>Pink</em></strong>:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span><span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> unknown<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">,</span> pink<span class="token punctuation">,</span> purple<span class="token punctuation">,</span> red
<span class="token punctuation">}</span>
<span class="token keyword">let</span> pink <span class="token operator">=</span> <span class="token builtin">Color</span><span class="token punctuation">.</span>pink<span class="token punctuation">.</span>rawValue
<span class="token function">print</span><span class="token punctuation">(</span>pink<span class="token punctuation">)</span></code></pre>
<p>不管初始值的数据类型是什么，或者是否有初始值，当枚举被用作字符串插值的一部分时，<em>Swift</em> 都会自动对枚举进行字符串化。但是，以这种方式使用并不会使它们变成字符串，所以如果你想调用任何字符串方法，你需要自己根据它们创建一个字符串。例如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> barbie <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Barbie"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>pink<span class="token punctuation">)</span>
<span class="token keyword">let</span> raceCar <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Lightning McQueen"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>red<span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// regular string interpolation</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>name<span class="token delimiter variable">)</span></span> toy is <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>color<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// get the string form of the Color then call a method on it</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>name<span class="token delimiter variable">)</span></span> toy is \(barbie.color.rawValue.uppercased())"</span><span class="token punctuation">)</span></code></pre>
<h3 id="计算属性和方法-Computed-properties-and-methods"><a href="#计算属性和方法-Computed-properties-and-methods" class="headerlink" title="计算属性和方法(Computed properties and methods)"></a>计算属性和方法(Computed properties and methods)</h3><p>枚举没有结构体和类那么强大，但是它们允许你在其中封装一些有用的功能。例如，除非枚举存储的属性是静态的，否则不能给它们赋值，因为这样做没有意义，但是你可以添加在运行一些代码之后返回值的计算属性。</p>
<p>为了让你了解一些有用的内容，让我们向<code>Color</code>枚举添加一个计算属性，该属性将打印颜色的简要描述。</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> unknown<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">,</span> pink<span class="token punctuation">,</span> purple<span class="token punctuation">,</span> red
   <span class="token keyword">var</span> description<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
      <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> <span class="token punctuation">.</span>unknown<span class="token punctuation">:</span>
         <span class="token keyword">return</span> <span class="token string">"the color of magic"</span>
      <span class="token keyword">case</span> <span class="token punctuation">.</span>blue<span class="token punctuation">:</span>
         <span class="token keyword">return</span> <span class="token string">"the color of the sky"</span>
      <span class="token keyword">case</span> <span class="token punctuation">.</span>green<span class="token punctuation">:</span>
         <span class="token keyword">return</span> <span class="token string">"the color of grass"</span>
      <span class="token keyword">case</span> <span class="token punctuation">.</span>pink<span class="token punctuation">:</span>
         <span class="token keyword">return</span> <span class="token string">"the color of carnations"</span>
      <span class="token keyword">case</span> <span class="token punctuation">.</span>purple<span class="token punctuation">:</span>
         <span class="token keyword">return</span> <span class="token string">"the color of rain"</span>
      <span class="token keyword">case</span> <span class="token punctuation">.</span>red<span class="token punctuation">:</span>
         <span class="token keyword">return</span> <span class="token string">"the color of desire"</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
<span class="token keyword">let</span> barbie <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Barbie"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>pink<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"This <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>name<span class="token delimiter variable">)</span></span> toy is <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>color<span class="token punctuation">.</span>description<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span></code></pre>
<p>当然，计算属性只是封装方法的语法糖，所以你可以直接将方法添加到枚举中也就不足为奇了。现在让我们通过向<code>Color</code> 枚举添加两个新方法来实现这一点，<code>forBoys()</code>和<code>forGirls()</code>，根据颜色来判断一个玩具是为女孩还是男孩准备的——只需在我们刚刚添加的<code>description</code> 属性下面添加以下内容：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">forBoys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">forGirls</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span></code></pre>
<p>如果你想知道，根据颜色来决定哪个玩具是男孩的还是女孩的有点上世纪 <em>70</em> 年代的味道：这些方法都返回<code>true</code>是有原因的!</p>
<p>因此：我们的枚举现在有一个初始值、一个计算属性和一些方法。我希望你能明白为什么我把枚举描述为<strong>看起来很强大</strong>——它们可以做很多事情!</p>
<h2 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h2><p>数组是 <em>Swift</em> 的真正主力之一。当然，它们在大多数应用程序中都很重要，但是它们对泛型的使用使它们在添加一些有用功能的同时保证类型安全。我不打算详细介绍它们的基本用法；相反，我想向你介绍一些你可能不知道的有用方法。</p>
<p>第一：排序。只要数组存储的元素类型遵循<code>Comparable</code>协议，就会得到<code>sorted()</code>和<code>sort()</code>方法——前者返回一个已排序的数组，而后者修改调用它的数组。如果你不打算遵循<code>Comparable</code>协议，可以使用<code>sorted()</code>和<code>sort()</code>的替代版本，让你指定数据项应该如何排序。</p>
<p>为了演示下面的例子，我们将使用这两个数组:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Timothy"</span><span class="token punctuation">,</span> <span class="token string">"Tyler"</span><span class="token punctuation">,</span> <span class="token string">"Thomas"</span><span class="token punctuation">,</span> <span class="token string">"Tobias"</span><span class="token punctuation">,</span> <span class="token string">"Tabitha"</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span></code></pre>
<p>要按字母顺序排列<code>names</code>数组，使用<code>sorted()</code>或<code>sort()</code>方法取决于你的需要。</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token builtin">sorted</span> <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>一旦代码运行，<code>sorted</code>将包含<code>["Tabitha", "Taylor", "Thomas", "Timothy", "Tobias", "Tyler"]</code>。</p>
<p>如果你想编写自己的排序函数 - 如果你不采用<code>Comparable</code>则是必需的，否则是可选的 - 编写一个接受两个字符串的闭包，如果第一个字符串应该在排在第二个字符串之前，则返回<code>true</code>。</p>
<p>例如，我们可以编写一个字符串排序算法，它的行为与常规的字母排序相同，但它总是将名称 <strong><em>Taylor</em></strong> 放在前面。我敢肯定，这正是<code>Taylor Swift</code>(美国女歌手)想要的：</p>
<pre class=" language-swift"><code class="language-swift">names<span class="token punctuation">.</span><span class="token builtin">sort</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Comparing <span class="token interpolation"><span class="token delimiter variable">\(</span>$<span class="token number">0</span><span class="token delimiter variable">)</span></span> and <span class="token interpolation"><span class="token delimiter variable">\(</span>$<span class="token number">1</span><span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
   <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token number">0</span> <span class="token operator">==</span> <span class="token string">"Taylor"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">true</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> $<span class="token number">1</span> <span class="token operator">==</span> <span class="token string">"Taylor"</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> $<span class="token number">0</span> <span class="token operator">&lt;</span> $<span class="token number">1</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span></code></pre>
<p>该代码使用<code>sort()</code>而不是<code>sorted()</code>，这将使数组按适当位置排序，而不是返回一个新的排序数组。我还在其中添加了一个<code>print()</code>调用，这样你就可以确切地看到<code>sort()</code>是如何工作的。这是输出结果:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Comparing</span> <span class="token builtin">Timothy</span> and <span class="token builtin">Taylor</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Tyler</span> and <span class="token builtin">Timothy</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Thomas</span> and <span class="token builtin">Tyler</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Thomas</span> and <span class="token builtin">Timothy</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Thomas</span> and <span class="token builtin">Taylor</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Tobias</span> and <span class="token builtin">Tyler</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Tobias</span> and <span class="token builtin">Timothy</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Tyler</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Tobias</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Timothy</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Thomas</span>
<span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Taylor</span></code></pre>
<p>如你所见，随着算法的发展，名称可以显示为 <em>$0</em> 或 <em>$1</em>，这就是为什么我在自定义排序函数中比较这两种可能性的原因。</p>
<p>排序很容易，但采用<code>Comparable</code>还可以实现两个更有用的方法：<code>min()</code>和<code>max()</code>。就像<code>sort()</code>一样，如果不采用<code>Comparable</code>的方法，这些方法也可以接受一个闭包，但是代码是相同的，因为操作是相同的：A项应该出现在B项之前吗？</p>
<p>使用前面的<code>number</code>数组，我们可以在两行代码中找到数组中的最高值和最低值:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lowest <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> highest <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>对于字符串，<code>min()</code>返回排序后的第一个字符串，<code>max()</code>返回最后一个字符串。如果你尝试重用我为自定义排序提供的相同闭包，包括<code>print()</code>语句，你将看到<code>min()</code>和<code>max()</code>实际上比使用<code>sort()</code>更高效，因为它们不需要移动每一项。</p>
<h3 id="遵循Comparable协议-Conforming-to-Comparable"><a href="#遵循Comparable协议-Conforming-to-Comparable" class="headerlink" title="遵循Comparable协议(Conforming to Comparable)"></a>遵循Comparable协议(Conforming to Comparable)</h3><p>对于字符串和整型等基本数据类型，使用<code>sort()</code>、<code>min()</code>和<code>max()</code>非常简单。但是你怎么把别的东西完全分类呢，比如奶酪的种类或者狗的品种？我已经向你展示了如何编写自定义闭包，但是如果你必须进行多次排序，那么这种方法就会变得非常麻烦—你最终会复制代码，这将带来维护的噩梦。</p>
<p>更聪明的解决方案是实现<code>Comparable</code>协议，这反过来要求你使用操作符重载。稍后我们将对此进行更详细的讨论，但现在我只想向你展示足以进行比较的工作。首先，这里有一个基本的<code>Dog</code>结构，它包含一些信息:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Dog</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> breed<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>
<span class="token punctuation">}</span></code></pre>
<p>为了便于测试，我们将创建三只 <strong>dog</strong> 并将它们放到数组里:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> poppy <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Poodle"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> rusty <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Labrador"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> rover <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Corgi"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> dogs <span class="token operator">=</span> <span class="token punctuation">[</span>poppy<span class="token punctuation">,</span> rusty<span class="token punctuation">,</span> rover<span class="token punctuation">]</span></code></pre>
<p>因为 <code>Dog</code>结构体没有遵循 <code>Comparable</code>协议，所以我们没有在<code>dogs</code>数组上获得简单的<code>sort()</code> 和 <code>ordered()</code>方法，我们只获得了需要自定义闭包才能运行的方法。</p>
<p>要使<code>Dog</code>遵循 <code>Comparable</code>协议，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Dog</span><span class="token punctuation">:</span> <span class="token builtin">Comparable</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> breed<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>
<span class="token punctuation">}</span></code></pre>
<p>你会得到错误，没关系。</p>
<p>下一步是让第一次尝试它的人感到困惑的地方：你需要实现两个新函数，但是它们有一些不同寻常的名称，在处理操作符重载时需要一点时间来适应，这正是我们需要做的。</p>
<p>在<code>Dog</code>结构中添加这两个函数:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>age <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>age
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">==</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>age <span class="token operator">==</span> rhs<span class="token punctuation">.</span>age
<span class="token punctuation">}</span></code></pre>
<p>需要说明的是，你的代码应该如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Dog</span><span class="token punctuation">:</span> <span class="token builtin">Comparable</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> breed<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>
   <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>age <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>age
   <span class="token punctuation">}</span>
   <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">==</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>age <span class="token operator">==</span> rhs<span class="token punctuation">.</span>age
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>如果你以前没有使用过运算符重载，那么这些函数名是不常见的，但是我希望你能够确切地了解它们的作用: 当你编写<code>dog1 &lt; dog2</code>时使用 <code>&lt;</code> 函数，当你写<code>dog1 == dog2</code>时使用<code>==</code>函数。</p>
<p>这两个步骤足以完全实现<code>Comparable</code>协议，因此你现在可以轻松地对<code>dogs</code>数组进行排序：</p>
<pre class=" language-swift"><code class="language-swift">dogs<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h3 id="添加和删除元素-Adding-and-removing-items"><a href="#添加和删除元素-Adding-and-removing-items" class="headerlink" title="添加和删除元素(Adding and removing items)"></a>添加和删除元素(Adding and removing items)</h3><p>几乎可以肯定，你已经使用过数组的<code>append()</code>、<code>insert()</code>和<code>remove(at:)</code>方法，但我想确保你知道添加和删除项的其他方法。</p>
<p>如果想将两个数组相加，可以使用<code>+</code>或<code>+=</code>来就地相加。例如:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> poppy <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Poodle"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> rusty <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Labrador"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> rover <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Corgi"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> dogs <span class="token operator">=</span> <span class="token punctuation">[</span>poppy<span class="token punctuation">,</span> rusty<span class="token punctuation">,</span> rover<span class="token punctuation">]</span>
<span class="token keyword">let</span> beethoven <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"St Bernard"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">)</span>
dogs <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">[</span>beethoven<span class="token punctuation">]</span></code></pre>
<p>当涉及到删除项目时，有两种有趣的方法可以删除最后一项:<code>removeLast()</code> 和 <code>popLast()</code>。它们都删除数组中的最后一项并将其返回给你，但是<code>popLast()</code>返回的是可选值，而<code>removeLast()</code>不是。考虑一下：<code>dogs.removeLast()</code>必须返回<code>Dog</code>结构的一个实例。 如果数组是空的会发生什么？答案是“坏事情”——你的应用会崩溃。</p>
<p>如果你试图删除一项时，你的数组可能是空的，那么使用<code>popLast()</code>，这样你就可以安全地检查返回值:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> dog <span class="token operator">=</span> dogs<span class="token punctuation">.</span><span class="token function">popLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment" spellcheck="true">// do stuff with `dog`</span>
<span class="token punctuation">}</span></code></pre>
<blockquote>
<p>注意：<code>removeLast()</code>有一个称为<code>removeFirst()</code>的对应项，用于删除和返回数组中的初始项。遗憾的是，<code>popLast()</code>没有类似的方法。</p>
</blockquote>
<h3 id="空和容量-Emptiness-and-capacity"><a href="#空和容量-Emptiness-and-capacity" class="headerlink" title="空和容量(Emptiness and capacity)"></a>空和容量(Emptiness and capacity)</h3><p>下面是我想展示的另外两个小技巧:  <code>isEmpty</code> 和 <code>reserveCapacity()</code></p>
<p>第一个是<code>isEmpty</code>，如果数组没有添加任何项，则返回<code>true</code>。 这比使用<code>someArray.count == 0</code>更短，更有效，但由于某种原因使用较少。</p>
<p> <code>reserveCapacity()</code>方法允许您告诉 <em>iOS</em> 打算在数组中存储多少项。这并不是一个严格的限制。如果你预留了 <em>10</em> 个容量，你可以继续存储 <em>20</em> 个，如果你想的话——但它允许 <em>iOS</em> 优化对象存储，确保你有足够的空间来容纳你的建议容量。</p>
<blockquote>
<p>警告：使用 <code>reserveCapacity()</code>不是一个免费的操作。在后台，<em>Swift</em> 将创建一个包含相同值的新数组，并为你需要的容量留出空间。它不只是扩展现有数组。这样做的原因是该方法保证得到的数组将具有连续存储(即所有项目彼此相邻存储而不是分散在 <em>RAM</em> 中）因此，<em>Swift</em> 会做大量的移动操作。即使你已经调用了<code>reserveCapacity()</code>，这也适用—尝试将这段代码放到一个 <em>Playground</em> 中，自己看看:</p>
</blockquote>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span>
<span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1000000</span><span class="token punctuation">)</span>
array<span class="token punctuation">.</span><span class="token function">reserveCapacity</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>
array<span class="token punctuation">.</span><span class="token function">reserveCapacity</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Took <span class="token interpolation"><span class="token delimiter variable">\(</span>end<span class="token delimiter variable">)</span></span> seconds"</span><span class="token punctuation">)</span></code></pre>
<p>当这段代码运行时，你将看到调用<code>reserveCapacity()</code>时两次都会出现严重的暂停。因为<code>reserveCapacity()</code>是一个<code>O(n)</code>复杂度的调用(其中<code>n</code>是数组的<code>count</code>值)，所以应该在向数组添加项之前调用它。</p>
<h3 id="连续数组-Contiguous-arrays"><a href="#连续数组-Contiguous-arrays" class="headerlink" title="连续数组(Contiguous arrays)"></a>连续数组(Contiguous arrays)</h3><p><em>Swift</em> 提供了两种主要的数组，但几乎总是只使用一种。首先，让我们分解一下语法：你应该知道这两行代码在功能上是相同的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> array2 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>第一行是第二行的语法糖。到目前为止，一切都很简单。但是我想向你们介绍一下连续数组容器的重要性，它看起来是这样的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array3 <span class="token operator">=</span> <span class="token builtin">ContiguousArray</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1000000</span><span class="token punctuation">)</span></code></pre>
<p>就是这样。连续数组具有你习惯使用的所有属性和方法—<code>count</code>、<code>sort()</code>、<code>min()</code>、<code>map()</code>等等—但因为所有项都保证是连续存储的，即你可以得到更好的表现。</p>
<p>苹果的官方文档说，当你需要 <em>C</em> 数组的性能时，应该使用连续数组，而当你想要<strong>针对 <em>Cocoa</em> 高效转换优化</strong>时，应该使用常规数组。文档还说，当与非类类型一起使用时，<code>Array</code>和<code>ContiguousArray</code>的性能是相同的，这意味着在使用类时，你肯定会得到性能上的改进。</p>
<p>原因很简单：<em>Swift</em> 数组可以桥接到<code>NSArray</code>，这是 <em>Objective-C</em> 开发人员使用的数组类型。 由于历史原因，<code>NSArray</code>无法存储值类型，例如整数，除非它们被包装在对象中。 因此，<em>Swift</em> 编译器可以很聪明：如果你创建一个包含值类型的常规 <em>Swift</em> 数组，它就知道你不能尝试将它桥接到<code>NSArray</code>，因此它可以执行额外的优化来提高性能。</p>
<p>也就是说，我发现连续数组无论如何都比数组快，即使是使用<code>Int</code>这样的基本类型。举个简单的例子，下面的代码把1到100万的数字加起来:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array2 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> array3 <span class="token operator">=</span> <span class="token builtin">ContiguousArray</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1000000</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> start <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
array2<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> end <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Took <span class="token interpolation"><span class="token delimiter variable">\(</span>end<span class="token delimiter variable">)</span></span> seconds"</span><span class="token punctuation">)</span>
start <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
array3<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span>
end <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Took <span class="token interpolation"><span class="token delimiter variable">\(</span>end<span class="token delimiter variable">)</span></span> seconds"</span><span class="token punctuation">)</span></code></pre>
<p>当我运行这段代码时，数组花费 <em>0.25</em> 秒，连续数组花费 <em>0.13</em> 秒。考虑到我们只是循环了超过 <em>100</em> 万个元素，这并不是非常优秀，但如果你想在你的应用程序或游戏中获得额外的性能提升，你肯定应该尝试使用连续数组。</p>
<h2 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h2><p>了解集合和数组之间的区别 – 并知道哪一个在何时是正确的选择 - 是任何 <em>Swift</em> 开发人员工具箱中的一项重要技能。集合可以被认为是无序数组，不能包含重复元素。如果你多次添加同一个元素，它将只在集合中出现一次。缺少重复项和不跟踪顺序的组合允许集合比数组快得多，因为数据项是根据哈希而不是递增的整数索引存储的。</p>
<p>要将其置于上下文中，检查数组是否包含项，复杂度为<code>O(n)</code>，这意味着“它取决于你在数组中有多少元素”。这是因为<code>Array.contains()</code>需要从 <em>0</em> 开始检查每个元素，所以如果有 <em>50</em> 个元素，则需要执行 <em>50</em> 次检查。检查一个集合是否包含项，复杂度为<code>O(1)</code>，这意味着“无论你有多少元素，它始终以相同的速度运行”。这是因为集合的工作原理类似于字典：通过创建对象的 <em>hash</em> 生成键，而该键直接指向对象存储的位置。</p>
<h3 id="基础-The-basics"><a href="#基础-The-basics" class="headerlink" title="基础(The basics)"></a>基础(The basics)</h3><p>最好的实验方法是使用 <em>Playground</em> ，试着输入这个：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> set1 <span class="token operator">=</span> <span class="token builtin">Set</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
<p>当它运行时，你将在输出窗口中看到 <strong><em>{ 5,2,3,1,4  }</em></strong>。就像我说的，集合是无序的，所以你可能会在 <em>Xcode</em> 窗口中看到一些不同的东西。</p>
<p>这将从数组中创建一个新的集合，但是你也可以从范围中创建它们，就像数组一样：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> set2 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">100</span><span class="token punctuation">)</span></code></pre>
<p>你还可以单独向它们添加项，尽管方法名为<code>insert()</code>而不是<code>append()</code>，以反映其无序性:</p>
<pre class=" language-swift"><code class="language-swift">set1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>
set1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span></code></pre>
<p>若要检查集合中是否存在项，请使用像闪电一样快的<code>contains()</code>方法：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> set1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Number 3 is in there!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>并使用<code>remove()</code>从集合中删除项：</p>
<pre class=" language-swift"><code class="language-swift">set1<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre>
<h3 id="数组和集合-Arrays-and-sets"><a href="#数组和集合-Arrays-and-sets" class="headerlink" title="数组和集合(Arrays and sets)"></a>数组和集合(Arrays and sets)</h3><p>数组和集合一起使用时工作得很好，所以它们几乎可以互换也就不足为奇了。首先，数组和集合都有接受另一种类型的构造函数，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> set1 <span class="token operator">=</span> <span class="token builtin">Set</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> array1 <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>set1<span class="token punctuation">)</span>
<span class="token keyword">var</span> set2 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span>array1<span class="token punctuation">)</span></code></pre>
<p>实际上，将数组转换为集合并返回是删除所有重复项的最快方法，而且只需两行代码。</p>
<p>其次，集合的一些方法返回数组而不是集合，因为这样做更有用。例如，集合上的<code>ordered()</code>、<code>map()</code>和<code>filter()</code>方法返回一个数组。</p>
<p>所以，虽然你可以像这样直接循环集合:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> number <span class="token keyword">in</span> set1 <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>…你也可以先将集合按合理的顺序排序，如下所示:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> number <span class="token keyword">in</span> set1<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>像数组一样，集合使用<code>removeFirst()</code>方法从集合的前面删除项。 但是它的用途是不同的：因为集合是无序的，你真的不知道第一个项目是什么，所以<code>removeFirst()</code>实际上意味着“给我任何对象，以便我可以处理它。” 巧妙地，集合有一个popFirst()方法，而数组没有——我真希望知道为什么!</p>
<h3 id="集合操作-Set-operations"><a href="#集合操作-Set-operations" class="headerlink" title="集合操作(Set operations)"></a>集合操作(Set operations)</h3><p>集合附带了许多方法，允许你以有趣的方式操作它们。例如，你可以创建两个集合的并集，即两个集合的合并，如下所示:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> spaceships1 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Nostromo"</span><span class="token punctuation">,</span> <span class="token string">"Enterprise"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> spaceships2 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Voyager"</span><span class="token punctuation">,</span> <span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Executor"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> union <span class="token operator">=</span> spaceships1<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>spaceships2<span class="token punctuation">)</span></code></pre>
<p>当代码运行时，<code>union</code>将包含 <em>5</em> 个条目，因为重复的 “<em>Serenity</em>” 只出现一次。</p>
<p>另外两个有用的集合操作是<code>intersection()</code>和<code>symmetricDifference()</code>。前者返回一个只包含两个集合中存在的元素的新集合，而后者则相反:它只返回两个集合中不存在的元素。代码是这样的:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> intersection <span class="token operator">=</span> spaceships1<span class="token punctuation">.</span><span class="token function">intersection</span><span class="token punctuation">(</span>spaceships2<span class="token punctuation">)</span>
<span class="token keyword">let</span> difference <span class="token operator">=</span> spaceships1<span class="token punctuation">.</span><span class="token function">symmetricDifference</span><span class="token punctuation">(</span>spaceships2<span class="token punctuation">)</span></code></pre>
<p>当它运行时，<code>intersection</code>将包含<code>Serenity</code>，<code>difference</code>将包含<code>Nostromo</code>、<code>Enterprise</code>、<code>Voyager</code>和<code>Executor</code>。</p>
<blockquote>
<p>注意：<code>union()</code>、<code>intersection()</code>和 <code>symmetricDifference()</code>都有直接修改集合的替代方法，可以通过向方法前添加<code>form</code>来调用它们，<code>formUnion()</code>、<code>formIntersection()</code> 和 <code>formSymmetricDifference()</code>。</p>
</blockquote>
<p>集合有几个查询方法，根据提供的内容返回<code>true</code>或<code>false</code>。</p>
<p>这些方法是:</p>
<ul>
<li><strong>A.isSubset(of: B)</strong>: 如果集合 <em>A</em> 的所有项都在集合 <em>B</em> 中，则返回 <em>true</em> 。</li>
<li><strong>A.isSuperset(of: B)</strong>: 如果集合 <em>B</em> 的所有项都在集合 <em>A</em> 中，则返回 <em>true</em> 。</li>
<li><strong>A.isDisjoint(with: B)</strong>: 如果集合 <em>B</em> 的所有项都不在集合 <em>A</em> 中，则返回 <em>true</em> 。</li>
<li><strong>A.isStrictSubset(of: B)</strong>: 如果集合 <em>A</em> 的所有项都在集合 <em>B</em> 中，则返回 <em>true</em> ， 但是 <em>A</em> 和 <em>B</em> 不相等。</li>
<li><strong>A.isStrictSuperset(of: B)</strong>: 如果集合 <em>B</em> 的所有项都在集合 <em>A</em> 中，则返回 <em>true</em> ，但是 <em>A</em> 和 <em>B</em> 不相等。</li>
</ul>
<p>集合区分子集和严格子集，不同之处在于后者必须排除相同的集合。 也就是说，如果集合 <em>A</em> 中的每个项目也在集合 <em>B</em> 中，则集合 <em>A</em> 是集合 <em>B</em> 的子集。另一方面，如果集合 <em>A</em> 中的每个元素也在集合 <em>B</em> 中，则集合 <em>A</em> 是集合 <em>B</em> 的严格子集，但是集合 <em>B</em>至少包含集合 <em>A</em> 中缺少的一个项。</p>
<p>下面的代码分别演示了它们，我在注释中标记了每个方法的返回值：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> spaceships1 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Nostromo"</span><span class="token punctuation">,</span> <span class="token string">"Enterprise"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> spaceships2 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Voyager"</span><span class="token punctuation">,</span> <span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"StarDestroyer"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> spaceships3 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Galactica"</span><span class="token punctuation">,</span> <span class="token string">"Sulaco"</span><span class="token punctuation">,</span> <span class="token string">"Minbari"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> spaceships1and2 <span class="token operator">=</span> spaceships1<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>spaceships2<span class="token punctuation">)</span>
spaceships1<span class="token punctuation">.</span><span class="token function">isSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1and2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>
spaceships1<span class="token punctuation">.</span><span class="token function">isSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>
spaceships1<span class="token punctuation">.</span><span class="token function">isSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>
spaceships1<span class="token punctuation">.</span><span class="token function">isStrictSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1and2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>
spaceships1<span class="token punctuation">.</span><span class="token function">isStrictSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>
spaceships1and2<span class="token punctuation">.</span><span class="token function">isSuperset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>
spaceships1and2<span class="token punctuation">.</span><span class="token function">isSuperset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships3<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>
spaceships1and2<span class="token punctuation">.</span><span class="token function">isStrictSuperset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>
spaceships1<span class="token punctuation">.</span><span class="token function">isDisjoint</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> spaceships2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span></code></pre>
<h3 id="NSCountedSet"><a href="#NSCountedSet" class="headerlink" title="NSCountedSet"></a>NSCountedSet</h3><p><em>Foundation</em> 库有一个专门的集合叫做<code>NSCountedSet</code>，它是一个具有扭曲(<strong>twist</strong>)的集合: 项仍然只能出现一次，但是如果你尝试多次添加它们，它将跟踪计数，就像它们确实存在一样。这意味着你可以获得非重复集合的所有速度，但是如果允许重复，你还可以计算项目出现的次数。</p>
<p>你可以根据需要从 <em>Swift</em> 数组或集合创建<code>NSCountedSet</code>。在下面的例子中，我创建了一个大型数组（带有重复项），将它全部添加到计数集，然后打印出两个值的计数:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> spaceships <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Nostromo"</span><span class="token punctuation">,</span> <span class="token string">"Enterprise"</span><span class="token punctuation">]</span>
spaceships <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Voyager"</span><span class="token punctuation">,</span> <span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Star Destroyer"</span><span class="token punctuation">]</span>
spaceships <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Galactica"</span><span class="token punctuation">,</span> <span class="token string">"Sulaco"</span><span class="token punctuation">,</span> <span class="token string">"Minbari"</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> countedSet <span class="token operator">=</span> <span class="token function">NSCountedSet</span><span class="token punctuation">(</span>array<span class="token punctuation">:</span> spaceships<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>countedSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token string">"Serenity"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2</span>
<span class="token function">print</span><span class="token punctuation">(</span>countedSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token string">"Sulaco"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span></code></pre>
<p>正如你所看到的，您可以使用<code>count(for:)</code>来检索一个元素在计数集合中出现的次数(理论上)。你可以使用<code>countedSet.allObjects</code>属性提取所有对象的数组，但要注意：<code>NSCountedSet</code>不支持泛型，因此你需要将其类型转换回<code>[String]</code>。</p>
<h2 id="元组-Tuples"><a href="#元组-Tuples" class="headerlink" title="元组(Tuples)"></a>元组(Tuples)</h2><p>元组类似于简化的匿名结构体：它们是携带不同信息字段的值类型，但不需要正式定义。由于缺少正式的定义，所以很容易创建和丢弃它们，所以当你需要一个函数返回多个值时，通常会使用它们。</p>
<p>在关于模式匹配和析构的章节中，我介绍了元组如何以其他方式使用——它们确实是无处不在的小东西。有多普遍？那么，考虑以下代码:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>思考一下： <code>result</code>常量具有什么数据类型？你可能已经猜到了本章的名称，它是一个元组: <code>()</code>。在后台，<em>Swift</em> 将 <em>Void</em> 数据类型(没有显式返回类型的函数的默认值)映射到一个空元组。</p>
<p>现在考虑一下这个：<em>Swift</em> 中的每一种类型——整数、字符串等等——实际上都是自身的一个单元素元组。请看下面的代码：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> int1<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">let</span> int2<span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre>
<p>这段代码完全正确：将一个整数赋值给一个单元素元组和将一个单元素元组赋值给一个整数都做了完全相同的事情。正如 <em>Apple</em> 文档中所说，“如果括号中只有一个元素，那么(元组的)类型就是该元素的类型。”它们实际上是一样的，所以你甚至可以这样写：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singleTuple <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">)</span>
singleTuple <span class="token operator">=</span> <span class="token number">69</span></code></pre>
<p>当 <em>Swift</em> 编译第一行时，它基本上忽略标签，将其变成一个包含整数的单元素元组——而整数又与整数相同。实际上，这意味着你不能给单元素元组添加标签——如果你试图强制一个数据类型，你会得到一个错误：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> thisIsAllowed <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> thisIsNot<span class="token punctuation">:</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">)</span></code></pre>
<p>如果你没有从一个函数返回任何东西，你得到一个元组，如果你从一个函数返回几个值，你得到一个元组，如果你返回一个值，你实际上也得到一个元组。我认为可以肯定地说，不管您是否知道，您已经是一个频繁使用元组的用户了!</p>
<p>现在，我将在下面介绍元组的一些有趣的方面，但是首先你应该知道元组有几个缺点。具体来说，你不能向元组添加方法或让它们实现协议——如果这是你想要做的，那么你要寻找的是结构体。</p>
<h3 id="元组有类型-Tuples-have-types"><a href="#元组有类型-Tuples-have-types" class="headerlink" title="元组有类型(Tuples have types)"></a>元组有类型(Tuples have types)</h3><p>元组很容易被认为是数据的开放垃圾场，但事实并非如此:它们是强类型的，就像 <em>Swift</em> 中的其他所有东西一样。这意味着你不能改变一个元组的类型一旦它被创建-像这样的代码将无法编译：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>
singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span></code></pre>
<p>如果你不给元组的元素命名，你可以使用从 <em>0</em> 开始的数字来访问它们，就像这样：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>singer<span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre>
<p>如果元组中有元组(这并不少见)，则需要使用 <em>0.0</em> ，诸如此类：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">,</span> address<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">"555 Taylor Swift Avenue"</span><span class="token punctuation">,</span> <span class="token string">"No, this isn't real"</span><span class="token punctuation">,</span> <span class="token string">"Nashville"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>singer<span class="token punctuation">.</span><span class="token number">2.2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Nashville</span></code></pre>
<p>这是一种内置的行为，但并不意味着推荐使用它。你可以——通常也应该——给你的元素命名，这样你才能更明智地访问它们：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>singer<span class="token punctuation">.</span><span class="token builtin">last</span><span class="token punctuation">)</span></code></pre>
<p>这些名称是类型的一部分，所以这样的代码不会编译通过:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>
singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Justin"</span><span class="token punctuation">,</span> fish<span class="token punctuation">:</span> <span class="token string">"Trout"</span><span class="token punctuation">)</span></code></pre>
<h3 id="元组和闭包-Tuples-and-closures"><a href="#元组和闭包-Tuples-and-closures" class="headerlink" title="元组和闭包(Tuples and closures)"></a>元组和闭包(Tuples and closures)</h3><p>不能向元组添加方法，但可以添加闭包。我同意这种区别很好，但它很重要：向元组添加闭包就像添加任何其他值一样，实际上是将代码作为数据类型附加到元组。因为它不是一个方法，声明有一点不同，但这里有一个例子让你开始：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">,</span> sing<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>lyrics<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token keyword">in</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>lyrics<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

singer<span class="token punctuation">.</span><span class="token function">sing</span><span class="token punctuation">(</span><span class="token string">"Haters gonna hate"</span><span class="token punctuation">)</span></code></pre>
<p>注意:这些闭包不能访问同级元素，这意味着这样的代码不能工作：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"My name is <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token builtin">first</span><span class="token delimiter variable">)</span></span>: <span class="token interpolation"><span class="token delimiter variable">\(</span>lyrics<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span></code></pre>
<h3 id="返回多个值-Returning-multiple-values"><a href="#返回多个值-Returning-multiple-values" class="headerlink" title="返回多个值(Returning multiple values)"></a>返回多个值(Returning multiple values)</h3><p>元组通常用于从一个函数返回多个值。事实上，如果这是元组带给我们的唯一东西，那么与其他语言(包括 <em>Objective-C</em> ) 相比，它们仍然是 <em>Swift</em> 的一个重要特性。</p>
<p>下面是一个 <em>Swift</em> 函数在一个元组中返回多个值的例子：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> cloudCover<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"Sunny"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> weather <span class="token operator">=</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>weather<span class="token punctuation">.</span>type<span class="token punctuation">)</span></code></pre>
<p>当然，你不必指定元素的名称，但是这无疑是一种很好的实践，这样其他开发人员就知道应该期望什么。</p>
<p>如果你更喜欢析构元组返回函数的结果，那么也很容易做到：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span>type<span class="token punctuation">,</span> cloud<span class="token punctuation">,</span> high<span class="token punctuation">,</span> low<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>相比之下，如果 <em>Swift</em> 没有元组，那么我们将不得不依赖于返回一个数组和按需要进行类型转换，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span>
<span class="token keyword">func</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">"Sunny"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> weather <span class="token operator">=</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> weatherType <span class="token operator">=</span> weather<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">String</span>
<span class="token keyword">let</span> weatherCloud <span class="token operator">=</span> weather<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Int</span>
<span class="token keyword">let</span> weatherHigh <span class="token operator">=</span> weather<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Int</span>
<span class="token keyword">let</span> weatherLow <span class="token operator">=</span> weather<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Int</span></code></pre>
<p>或者更糟的是，使用<code>inout</code>变量，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token builtin">String</span><span class="token punctuation">,</span> cloudCover<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    type <span class="token operator">=</span> <span class="token string">"Sunny"</span>
    cloudCover <span class="token operator">=</span> <span class="token number">50</span>
    high <span class="token operator">=</span> <span class="token number">32</span>
    low <span class="token operator">=</span> <span class="token number">26</span>
 <span class="token punctuation">}</span>
<span class="token keyword">var</span> weatherType <span class="token operator">=</span> <span class="token string">""</span>
<span class="token keyword">var</span> weatherCloud <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">var</span> weatherHigh <span class="token operator">=</span> <span class="token number">0</span>
<span class="token keyword">var</span> weatherLow <span class="token operator">=</span> <span class="token number">0</span>
<span class="token function">fetchWeather</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token operator">&amp;</span>weatherType<span class="token punctuation">,</span> cloudCover<span class="token punctuation">:</span> <span class="token operator">&amp;</span>weatherCloud<span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token operator">&amp;</span>weatherHigh<span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token operator">&amp;</span>weatherLow<span class="token punctuation">)</span></code></pre>
<p>说真的：如果<code>inout</code>是答案，你可能问错了问题。</p>
<h3 id="可选元组-Optional-tuples"><a href="#可选元组-Optional-tuples" class="headerlink" title="可选元组(Optional tuples)"></a>可选元组(Optional tuples)</h3><p>元组可以包含可选元素，也可以有可选元组。这听起来可能相似，但差别很大：可选元素是元组中的单个项，如<code>String?</code> 和 <code>Int?</code> ，而可选元组是整个结构可能存在也可能不存在。</p>
<p>具有可选元素的元组必须存在，但其可选元素可以为<code>nil</code>。可选元组必须填充其所有元素，或者是<code>nil</code>。具有可选元素的可选元组可能存在，也可能不存在，并且其每个可选元素可能存在，也可能不存在。</p>
<p>当处理可选元组时，<em>Swift</em> 不能使用类型推断，因为元组中的每个元素都有自己的类型。所以，你需要明确声明你想要什么，就像这样：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> optionalElements<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> optionalTuple<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> optionalBoth<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span></code></pre>
<p>一般来说，可选元素很常见，可选元组就不那么常见了。</p>
<h3 id="比较元组-Comparing-tuples"><a href="#比较元组-Comparing-tuples" class="headerlink" title="比较元组(Comparing tuples)"></a>比较元组(Comparing tuples)</h3><p><em>Swift</em> 允许你比较最多拥有 <em>6</em> 个参数数量的元组，只要它们具有相同的类型。这意味着您可以使用<code>==</code>比较包含最多 <em>6</em> 个项的元组，如果一个元组中的所有 <em>6</em> 个项都匹配第二个元组中的对应项，则返回<code>true</code>。</p>
<p>例如，下面的代码会打印“No match”：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Justin"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Bieber"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> singer <span class="token operator">==</span> person <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Match!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No match"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>但是要注意：元组比较忽略了元素标签，只关注类型，这可能会产生意想不到的结果。例如，下面的代码将打印“Match!”，即使元组标签不同：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> bird <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> breed<span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> singer <span class="token operator">==</span> bird <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Match!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No match"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="别名-Typealias"><a href="#别名-Typealias" class="headerlink" title="别名(Typealias)"></a>别名(Typealias)</h3><p>你已经看到了元组是多么强大、灵活和有用，但是有时候你可能想要将一些东西形式化。给你一个斯威夫特主题的例子，考虑这两个元组，代表泰勒·斯威夫特的父母:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> father <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Scott"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> mother <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Andrea"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Finlay"</span><span class="token punctuation">)</span></code></pre>
<p>(不，我没有泰勒·斯威夫特的资料，但我可以用维基百科!)</p>
<p>当他们结婚时，安德里亚·芬利变成了安德里亚·斯威夫特，他们成为了夫妻。我们可以写一个简单的函数来表示这个事件：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">marryTaylorsParents</span><span class="token punctuation">(</span>man<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span> woman<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>husband<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span> wife<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span>man<span class="token punctuation">,</span> <span class="token punctuation">(</span>woman<span class="token punctuation">.</span><span class="token builtin">first</span><span class="token punctuation">,</span> man<span class="token punctuation">.</span><span class="token builtin">last</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>注：我用了 “<em>man<em>” 和 “</em>wife*” ，还让妻子改成了她丈夫的姓，因为 *Taylor Swift</em> 的父母就是这么做的。很明显，这只是一种婚姻形式，我希望你能理解这是一个简化的例子，而不是一个政治声明。</p>
<p><code>father</code>元组和<code>mother</code>元组单独看起来足够好，但是<code>marryTaylorsParents()</code>函数看起来相当糟糕。一次又一次地重复<code>(first: String, last: String)</code>会使它很难阅读，也很难更改。</p>
<p><em>Swift</em> 的解决方案很简单: <code>typealias</code>关键字。这并不是特定于元组的，但在这里它无疑是最有用的：它允许你为类型附加一个替代名称。例如，我们可以创建这样一个 <code>typealias</code>：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">typealias</span> <span class="token builtin">Name</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span></code></pre>
<p>使用这个函数，<code>marryTaylorsParents()</code>函数明显变短：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">marryTaylorsParents</span><span class="token punctuation">(</span>man<span class="token punctuation">:</span> <span class="token builtin">Name</span><span class="token punctuation">,</span> woman<span class="token punctuation">:</span> <span class="token builtin">Name</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>husband<span class="token punctuation">:</span> <span class="token builtin">Name</span><span class="token punctuation">,</span> wife<span class="token punctuation">:</span> <span class="token builtin">Name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span>man<span class="token punctuation">,</span> <span class="token punctuation">(</span>woman<span class="token punctuation">.</span><span class="token builtin">first</span><span class="token punctuation">,</span> man<span class="token punctuation">.</span><span class="token builtin">last</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="范型-Generics"><a href="#范型-Generics" class="headerlink" title="范型(Generics)"></a>范型(Generics)</h2><p>尽管泛型在 <em>Swift</em> 中是一个高级主题，但你一直在使用它们：<code>[String]</code>是你使用数组结构存储字符串的一个例子，这是泛型的一个例子。事实上，使用泛型很简单，但是创建泛型需要一点时间来适应。在本章中，我将演示如何(以及为什么!)创建自己的泛型，从函数开始，然后是结构体，最后是包装 <em>Foundation</em>类型。</p>
<p>让我们从一个简单的问题开始，这个问题演示了泛型是什么以及它们为什么重要：我们将创建一个非常简单的泛型函数。</p>
<p>设想一个函数，它被设计用来打印关于字符串的一些调试信息。它可能是这样的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">inspectString</span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Received String with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">inspectString</span><span class="token punctuation">(</span><span class="token string">"Haters gonna hate"</span><span class="token punctuation">)</span></code></pre>
<p>现在让我们创建相同的函数来打印关于整数的信息：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">inspectInt</span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Received Int with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">inspectInt</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span></code></pre>
<p>现在让我们创建打印关于 <em>Double</em> 类型的信息的相同函数。实际上……我们不需要。这显然是非常枯燥的代码，我们需要将其扩展到浮点数、布尔值、数组、字典等等。有一种更智能的解决方案称为泛型编程，它允许我们编写处理稍后指定类型的函数。<em>Swift</em> 中的通用代码使用尖括号<code>&lt;</code>和<code>&gt;</code>，所以它非常明显!</p>
<p>要创建<code>inspectString()</code>函数的泛型形式，可以这样写：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> inspect<span class="token operator">&lt;</span><span class="token builtin">SomeType</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> <span class="token builtin">SomeType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre>
<p>注意<code>SomeType</code>的用法：在函数名后面的尖括号中，用于描述<code>value</code>参数。尖括号里的第一个是最重要的，因为它定义了你的占位符数据类型：<code>inspect&lt;SomeType&gt;()</code>意味着“一个名为<code>inspect()</code>的函数,可以使用任何类型的数据类型,但是无论使用的数据类型是什么,我想把它称为<code>SomeType</code>。因此，参数<code>value: SomeType</code>现在应该更有意义了：<code>SomeType</code>将被用于调用函数的任何数据类型替换。</p>
<p>稍后你将看到，占位符数据类型也用于返回值。但是首先，这里是<code>inspect()</code>函数的最终版本，它输出正确的信息，无论向它抛出什么数据：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> inspect<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">inspect</span><span class="token punctuation">(</span><span class="token string">"Haters gonna hate"</span><span class="token punctuation">)</span>
<span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">56</span><span class="token punctuation">)</span></code></pre>
<p>我使用了<code>type(of:)</code>函数，以便 <em>Swift</em>正确地输出 “<em>String</em>”、“<em>Int</em>” 等。注意，我还使用了<code>T</code>而不是某种类型，这是一种常见的编码约定:第一个占位符数据类型名为<code>T</code>，第二个<code>U</code>和第三个<code>V</code>，以此类推。在实践中，我发现这个约定没有帮助，也不清楚，所以尽管我将在这里使用它，只是因为你必须习惯它。</p>
<p>现在，你可能想知道泛型给这个函数带来了什么好处——难道它就不能为它的参数类型使用泛型吗?在这种情况下可以，因为占位符只使用一次，所以这在功能上是相同的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>但是，如果我们希望函数接受相同类型的两个参数，那么<code>Any</code>和占位符之间的区别就会变得更加明显。例如:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> inspect<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value1<span class="token punctuation">:</span> T<span class="token punctuation">,</span> <span class="token number">_</span> value2<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"1. Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value1<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value1<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"2. Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value2<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value2<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span></code></pre>
<p>现在接受<code>T</code>类型的两个参数，这是占位符数据类型。同样，我们不知道这将是什么，这就是为什么我们给它一个抽象的名称，如 “<em>T</em> ”，而不是一个特定的数据类型，如<code>Int</code>或<code>String</code>。然而，这两个参数的类型都是<code>T</code>，这意味着无论最终是什么类型，它们都必须是相同的类型。所以，这个代码是合法的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span></code></pre>
<p>但这是行不通的，因为它混合了数据类型：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"Dolphin"</span><span class="token punctuation">)</span></code></pre>
<p>如果我们对数据类型使用了<code>Any</code>参数，那么 <em>Swift</em> 就不能确保两个参数都是相同的类型——一个可以是<code>Int</code>，另一个可以是<code>String</code>。所以，这段代码将是正确的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">_</span> value1<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">,</span> <span class="token number">_</span> value2<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"1. Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value1<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value1<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"2. Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value2<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value2<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"Dolphin"</span><span class="token punctuation">)</span></code></pre>
<h3 id="范型限制-Limiting-generics"><a href="#范型限制-Limiting-generics" class="headerlink" title="范型限制(Limiting generics)"></a>范型限制(Limiting generics)</h3><p>你常常希望限制泛型，以便它们只能对类似类型的数据进行操作，而 <em>Swift</em> 使这一点变得既简单又容易。下一个函数将对任意两个整数进行平方，不管它们是<code>Int</code>、<code>UInt</code>、<code>Int64</code>，等等：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> square<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Integer</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T <span class="token punctuation">{</span>
   <span class="token keyword">return</span> value <span class="token operator">*</span> value
<span class="token punctuation">}</span></code></pre>
<p>注意，我为返回值添加了一个占位符数据类型。在本例中，它意味着函数将返回与它接受的数据类型相同的值。</p>
<p>扩展<code>square()</code>以支持其他类型的数字(如双精度和浮点数)比较困难，因为没有覆盖所有内置数字类型的协议。我们来创建一个：</p>
<pre class=" language-swift"><code class="language-swift">protocol <span class="token builtin">Numeric</span> <span class="token punctuation">{</span>
   <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">*</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">Self</span>
<span class="token punctuation">}</span></code></pre>
<p>它不包含任何代码，它只定义了一个名为<code>Numeric</code>的协议，并声明任何符合该协议的东西都必须能够自我相乘。我们想把这个协议应用到 <em>Float</em> 、<em>Double</em> 和 <em>Int</em> ，所以在协议下面加上这三行：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">Float</span><span class="token punctuation">:</span> <span class="token builtin">Numeric</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">extension</span> <span class="token builtin">Double</span><span class="token punctuation">:</span> <span class="token builtin">Numeric</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">extension</span> <span class="token builtin">Int</span><span class="token punctuation">:</span> <span class="token builtin">Numeric</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
<p>有了这个新协议，你可以满足任何你想要的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> square<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Numeric</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T <span class="token punctuation">{</span>
   <span class="token keyword">return</span> value <span class="token operator">*</span> value
<span class="token punctuation">}</span>
<span class="token function">square</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>
<span class="token function">square</span><span class="token punctuation">(</span><span class="token number">42.556</span><span class="token punctuation">)</span></code></pre>
<h3 id="创建泛型数据类型-Creating-a-generic-data-type"><a href="#创建泛型数据类型-Creating-a-generic-data-type" class="headerlink" title="创建泛型数据类型(Creating a generic data type)"></a>创建泛型数据类型(Creating a generic data type)</h3><p>既然你已经掌握了泛型函数，让我们进一步了解完全泛型数据类型:我们将创建一个泛型结构。在创建泛型数据类型时，需要将占位符数据类型声明为结构名称的一部分，然后可以根据需要在每个属性和方法中使用该占位符。</p>
<p>我们将要构建的结构名为 <em>deque<em>，这是一种常见的抽象数据类型，意思是“双端队列”。常规队列是将东西添加到队列末尾，然后从队列前端删除它们的队列。</em>deque</em> 是一个队列，你可以将内容添加到开头或结尾，也可以从开头或结尾删除内容。我选择在这里使用<em>deque*，因为重用 *Swift</em> 的内置数组非常简单——这里的关键是概念，而不是实现!</p>
<p>为了创建 <em>deque</em> 结构，我们将给它一个存储数组属性，它本身是通用的，因为它需要保存 <em>deque</em> 存储的任何数据类型。我们还将添加四个方法: <code>pushBack()</code> 和 <code>pushFront()</code> 将接受类型为<code>T</code>的参数并将其添加到正确的位置，而<code>popBack()</code>和<code>popFront()</code>将返回一个<code>T?</code>(占位符可选数据类型)，如果存在值，它将从后面或前面返回值。</p>
<p>只有一个很小的复杂性，那就是数组没有返回<code>T?</code>的<code>popFirst()</code>方法，因此我们需要添加一些额外的代码，以便在数组为空时运行。这是代码：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> deque<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">pushBack</span><span class="token punctuation">(</span><span class="token number">_</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      array<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">pushFront</span><span class="token punctuation">(</span><span class="token number">_</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      array<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">popBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T<span class="token operator">?</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">popLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">popFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T<span class="token operator">?</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> array<span class="token punctuation">.</span><span class="token builtin">isEmpty</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> <span class="token constant">nil</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
         <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span></code></pre>
<p>有了这个结构，我们可以立即开始使用它：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> testDeque <span class="token operator">=</span> deque<span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
testDeque<span class="token punctuation">.</span><span class="token function">pushBack</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
testDeque<span class="token punctuation">.</span><span class="token function">pushFront</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
testDeque<span class="token punctuation">.</span><span class="token function">pushFront</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
testDeque<span class="token punctuation">.</span><span class="token function">popBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<h3 id="使用Cocoa类型-Working-with-Cocoa-types"><a href="#使用Cocoa类型-Working-with-Cocoa-types" class="headerlink" title="使用Cocoa类型(Working with Cocoa types)"></a>使用Cocoa类型(Working with Cocoa types)</h3><p><em>Cocoa</em> 数据类型—— <code>NSArray</code>、<code>NSDictionary</code> 等等——从 <em>Swift</em> 最早的版本开始就可以使用了，但是它们很难使用，因为 <em>Objective-C</em> 对泛型的支持是最近的，也是有限的。</p>
<p><code>NSCountedSet</code> 是我最喜欢的基础类型之一，它根本不支持泛型。这意味着你失去了 <em>Swift</em> 编译器赋予你的自动类型安全，而这又让你离 <em>JavaScript</em> 程序员更近了一步——你不想这样吧？ 当然不。</p>
<p>幸运的是，我将向你演示如何通过围绕 <code>NSCountedSet</code> 创建泛型包装来创建自己的泛型数据类型。</p>
<p>这就像一个常规集合，每个条目只存储一次，但是它还有一个额外的好处，那“你添加了 <em>20</em> 次数字 <em>5</em> ”，尽管实际上它只在那里出现过一次。</p>
<p>这个的基本代码并不难，尽管你需要导入 <em>Foundation</em> 来访问<code>NSCountedSet</code> :</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span>
<span class="token keyword">struct</span> <span class="token builtin">CustomCountedSet</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token operator">></span> <span class="token punctuation">{</span>

   <span class="token keyword">let</span> internalSet <span class="token operator">=</span> <span class="token function">NSCountedSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">_</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      internalSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">_</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      internalSet<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">func</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> internalSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> obj<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>有了新的数据类型，你可以这样使用它:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> countedSet <span class="token operator">=</span> <span class="token builtin">CustomCountedSet</span><span class="token operator">&lt;</span><span class="token builtin">String</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
countedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>
countedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>
countedSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> countedSet2 <span class="token operator">=</span> <span class="token builtin">CustomCountedSet</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>
countedSet2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
countedSet2<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span></code></pre>
<p>我们的结构体所做的就是包装<code>NSCountedSet</code>使其类型安全，但这总是一个受欢迎的改进。考虑到苹果在 <em>Swift 3</em> 中的发展方向，如果他们在未来将<code>NSCountedSet</code>重新实现为一个通用的基于结构体的<code>CountedSet</code>，我不会感到惊讶——让我们拭目以待!</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《第二章 类型（Types）》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2019/09/04/pro-swift-yi-wen/chapter2-types/" property="cc:attributionName"
               rel="cc:attributionURL">
                影痕
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'f3f4b0e75a31c33690a1',
        clientSecret: 'c7a167d236ca9107a6728fcc08468b5237eabe4f',
        repo: 'BlogComments',
        owner: 'LucioLee',
        admin: ["LucioLee"],
        id: '2019-09-04T19-59-00',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/09/05/pro-swift-yi-wen/chapter3-references-and-values/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="第三章 引用类型和值类型(References and Values)">
                        
                        <span class="card-title">第三章 引用类型和值类型(References and Values)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            深入理解引用类型和值类型之间的区别和优缺点。
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-09-05
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Pro-Swift/" class="post-category" target="_blank">
                                    Pro Swift
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Swift/" target="_blank">
                        <span class="chip bg-color">Swift</span>
                    </a>
                    
                    <a href="/tags/Pro-Swift/" target="_blank">
                        <span class="chip bg-color">Pro Swift</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/09/03/pro-swift-yi-wen/chapter1-syntax/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="第一章 语法（Syntax）">
                        
                        <span class="card-title">第一章 语法（Syntax）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            从模式匹配、空值合并、Guard、懒加载、标记语句和嵌套类型等方面，介绍Swift语言中好用却又容易被开发者忽视的语法特性。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-09-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Pro-Swift/" class="post-category" target="_blank">
                                    Pro Swift
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Swift/" target="_blank">
                        <span class="chip bg-color">Swift</span>
                    </a>
                    
                    <a href="/tags/Pro-Swift/" target="_blank">
                        <span class="chip bg-color">Pro Swift</span>
                    </a>
                    
                    <a href="/tags/模式匹配/" target="_blank">
                        <span class="chip bg-color">模式匹配</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('1')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;

        newdiv.innerHTML += '<br />'
            + '来源: Li&apos;s Note<br />'
            + '作者: 影痕<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归@影痕所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站版权归&copy;<a href="https://luciolee.github.io/" target="_blank">影痕</a>所有.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">55.4k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/LucioLee/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:lixinxin990467229@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=990467229" class="tooltipped" data-tooltip="QQ联系我: 990467229" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->




    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>