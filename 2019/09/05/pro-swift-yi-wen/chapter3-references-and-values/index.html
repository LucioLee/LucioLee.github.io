<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="第三章 引用类型和值类型(References and Values), iOS">
    <meta name="description" content="下次发生崩溃时，请按照以下说明正确解决问题：单击线程中的  objc_exception_throw，然后在调试区域键入po $arg1以获取错误的可读版本。如果你使用异常断点，你甚至可以在那里添加po $arg1命令，这样它将自动输出。 ">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>第三章 引用类型和值类型(References and Values) | Li&#39;s Note</title>
    <link rel="icon" type="image/png" href="https://cdn.kongyintianxia.com/feedback_0_evYm8e_20190906.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://cdn.kongyintianxia.com/feedback_0_evYm8e_20190906.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Li's Note</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://cdn.kongyintianxia.com/feedback_0_evYm8e_20190906.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Li's Note</div>
        <div class="logo-desc">
            
            iOS 程序猿一枚~
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        第三章 引用类型和值类型(References and Values)
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Swift/" target="_blank">
                                <span class="chip bg-color">Swift</span>
                            </a>
                        
                            <a href="/tags/Pro-Swift/" target="_blank">
                                <span class="chip bg-color">Pro Swift</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Pro-Swift/" class="post-category" target="_blank">
                                Pro Swift
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-09-05
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        6.9k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        24 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>下次发生崩溃时，请按照以下说明正确解决问题：单击线程中的  <code>objc_exception_throw</code>，然后在调试区域键入<code>po $arg1</code>以获取错误的可读版本。如果你使用异常断点，你甚至可以在那里添加<code>po $arg1</code>命令，这样它将自动输出。<br> – <em>Natasha Murashev (@natashatherobot)</em>, 作者和演说家</p>
<h2 id="有什么区别？-What’s-the-difference"><a href="#有什么区别？-What’s-the-difference" class="headerlink" title="有什么区别？(What’s the difference?)"></a>有什么区别？(What’s the difference?)</h2><p>理解和利用引用类型和值类型之间的差异对于任何认真的Swift开发人员来说都是一项至关重要的技能。这不是“有用的知识”，也不是“知道就好”，而是至关重要的——我不是随便说说。</p>
<p>在接下来的几章中，我将详细介绍引用和值，以便你可以自己学习，但首先我想解释它们之间的区别。我遇到过太多的开发人员，他们要么不理解，要么不在乎——这两者都是错误的——所以这是一个明智的起点。</p>
<p>我是《星球大战》的超级粉丝，你可能还记得第一部《星球大战》电影(后来被命名为《新希望》)的结尾是对死星的攻击。叛军飞行员之一韦奇·安地列斯——飞往攻击死星，但遭到破坏，不得不飞回基地。另一名叛军飞行员卢克·天行者也在攻击死星，但他使用原力拯救了这一天，至少在下一部电影之前是这样。</p>
<p>为了说明引用类型和值类型之间的区别，我想用简单的 <em>Swift</em> 代码重新创建这个电影场景。虽然还不完整，但你可以跟着做：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// create a target</span>
<span class="token keyword">var</span> target <span class="token operator">=</span> <span class="token function">Target</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// set its location to be the Death Star</span>
target<span class="token punctuation">.</span>location <span class="token operator">=</span> <span class="token string">"Death Star"</span>
<span class="token comment" spellcheck="true">// tell Luke to attack the Death Star</span>
luke<span class="token punctuation">.</span>target <span class="token operator">=</span> target
<span class="token comment" spellcheck="true">// oh no – Wedge is hit! We need to</span>
<span class="token comment" spellcheck="true">// tell him to fly home</span>
target<span class="token punctuation">.</span>location <span class="token operator">=</span> <span class="token string">"Rebel Base"</span>
wedge<span class="token punctuation">.</span>target <span class="token operator">=</span> target
<span class="token comment" spellcheck="true">// report back to base</span>
<span class="token function">print</span><span class="token punctuation">(</span>luke<span class="token punctuation">.</span>target<span class="token punctuation">.</span>location<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>wedge<span class="token punctuation">.</span>target<span class="token punctuation">.</span>location<span class="token punctuation">)</span></code></pre>
<p>现在的问题是：当这些飞行员返回基地时，他们会说什么？答案是，“视情况而定。” 它所依赖的是——你猜对了——引用类型和值类型之间的区别。</p>
<p>你看，如果<code>Target</code>是一个类，在 <em>Swift</em> 中是一个引用类型，它应该是这样的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> location <span class="token operator">=</span> <span class="token string">""</span>
<span class="token punctuation">}</span></code></pre>
<p>如果<code>Target</code>是结构体，也就是 <em>Swift</em> 中的值类型，它会是这样的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Target</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> location <span class="token operator">=</span> <span class="token string">""</span>
<span class="token punctuation">}</span></code></pre>
<p>代码几乎相同，只有一个词不同。但结果是相差巨大的：如果<code>Target</code>是一个结构体，那么卢克会瞄准死亡之星，而韦奇会瞄准叛军基地，但是如果<code>Target</code>是一个类，那么卢克和韦奇都会瞄准叛军基地——这会给叛军和一些深深困惑的电影迷们带来非常不愉快的结局。</p>
<p>这种行为的原因是，当你在多个位置分配引用类型时，所有这些位置都指向相同的数据块。</p>
<p>因此，尽管卢克有一个<code>target</code>属性，韦奇也有一个<code>target</code>属性，但它们都指向<code>Target</code>类的同一个实例——改变一个意味着另一个也会改变。</p>
<p>另一方面，值类型总是只有一个所有者。当你在多个位置分配值类型时，所有这些位置都指向该值的单个副本。</p>
<p>当代码<code>luke.target = target</code>运行时，卢克获得了自己的<code>Target</code>实例的唯一副本。所以，当这变成“叛军基地”时，他不在乎——他继续攻击死星。</p>
<p><em>Swift</em> 是一种积极的值类型导向的语言，这意味着它的大多数数据类型都是值类型，而不是引用类型。布尔值、整数、字符串、元组和枚举都是值类型。甚至数组和字典也是值类型，所以下面的代码将打印 <em>3</em> 而不是 <em>4</em> ：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> a
a<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span></code></pre>
<p>值类型比引用类型简单，这不是坏事。当你给定一个要使用的值时，你可以确保它的值不会意外更改，因为你有自己惟一的副本。你还可以轻松地比较值类型，它们是如何得到值的并不重要——只要两个值看起来相同，它们就是相同的。例如，下面的代码将打印 “<em>Equal</em> ” ，即使 <em>a</em> 和 <em>b</em> 的创建方式非常不同：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> a <span class="token operator">==</span> b <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Equal"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre>
<p>简而言之，引用类型在赋值时共享，因此可以有多个所有者，而值类型在赋值时复制，因此只有一个所有者。</p>
<h2 id="闭包是引用类型-Closures-are-references"><a href="#闭包是引用类型-Closures-are-references" class="headerlink" title="闭包是引用类型(Closures are references)"></a>闭包是引用类型(Closures are references)</h2><p>这可能会有点烧脑，所以如果你很少复制闭包，那么可以完全跳过这一章。</p>
<p>我已经说过，布尔类型、整型、字符串类型、数组、字典、结构体等等都是 <em>Swift</em> 中的值类型。类是引用类型，闭包也是。对于简单的闭包，这并不重要。例如，下面的代码在<code>printGreeting</code>中存储了一个简单的闭包，调用它，将它分配给<code>copyGreeting</code>，然后再调用：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> printGreeting <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token function">printGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> copyGreeting <span class="token operator">=</span> printGreeting
<span class="token function">copyGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>在该代码中，闭包可以是值类型，它不会影响输出。当闭包捕获值时，事情就变得复杂了，因为捕获的值在指向相同闭包的任何变量之间共享。</p>
<p>给你一个实际的例子，下面的代码是一个<code>createIncrementer()</code>函数，它不接受任何参数并返回一个闭包：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">createIncrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span>
      counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>
      <span class="token function">print</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>在<code>createIncrementer()</code>函数中有一个变量<code>counter</code>，它的初始值为<code>0</code>。因为该变量是在返回的闭包中使用的，所以它将被捕获。所以，我们可以用这样的代码来执行这个函数：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> incrementer <span class="token operator">=</span> <span class="token function">createIncrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>第一行调用<code>createIncrementer()</code>函数并将其返回的闭包存储在<code>incrementer</code>变量中。下面的两行调用<code>incrementer()</code>两次，触发了闭包，因此你将看到 <code>1</code>和<code>2</code>被打印出来—计数器如预期的那样向上增加。</p>
<p>现在重点是：因为闭包是引用类型，如果我们创建另一个<code>incrementer</code>引用，它们将共享相同的闭包，因此也将共享相同的计数器变量。例如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> incrementer <span class="token operator">=</span> <span class="token function">createIncrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> incrementerCopy <span class="token operator">=</span> incrementer
<span class="token function">incrementerCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>当代码运行时，你将看到<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>被打印出来，因为<code>incrementer</code>和<code>incrementerCopy</code>都指向完全相同的闭包，因此也指向相同的捕获值。</p>
<p>重复一遍：如果你不经常使用闭包，那么这不太可能是一个问题，如果你不使用闭包来捕获值，那么你就是安全的。否则，请小心操作：在不引入闭包捕获的情况下，使用引用类型可能会非常困难。</p>
<h2 id="为什么使用结构体？-Why-use-structs"><a href="#为什么使用结构体？-Why-use-structs" class="headerlink" title="为什么使用结构体？(Why use structs?)"></a>为什么使用结构体？(Why use structs?)</h2><p>如果你要在类或结构体(即引用类型或值类型)之间进行选择，那么选择结构体是有充分理由的。这种比较适用于所有引用类型或值类型，但最常见的是当涉及到类或结构体时如何选择，这就是我将在这里讲的内容。</p>
<p>我已经提到过值类型是复制而不是共享，这意味着如果你的代码有三个不同的东西指向同一个结构，它们每个都有自己的副本 - 他们没有机会踩到对方的脚趾。 一旦你理解了这种逐个复制的行为，你就会开始意识到它带来了另一套好处。</p>
<p>如果你使用的应用程序比较复杂，那么值类型的最大好处之一就是它们本质上是线程安全的。也就是说，如果你正在处理一个或多个后台线程，则不可能导致值类型的竞争条件。为了避免混淆，在解释原因之前，我先简要解释一下原因。</p>
<p>首先，竞态条件：这是一个常见的 <em>bug</em> 类型的名称，它是由并行运行的两段代码引起的，它们完成的顺序会影响程序的状态。例如，假设我开车去你家给你 <em>1000</em> 美元，你的一个朋友也开车去你家索要 <em>200</em> 美元。我先到，然后把钱给你。朋友几分钟后到了，你给了她 <em>200</em> 美元——一切都很好。或者，你的朋友可能会比我开得快，然后先到那里，在这种情况下，他们要求 <em>200</em> 美元，而你却没有从我这里得到任何钱——突然之间，你就有麻烦了。</p>
<p>在软件中，这可能意味着尝试在收到结果之前对其进行操作，或者尝试处理尚未创建的对象。无论如何，结果都是不好的：你的软件的行为不一致，这取决于首先发生的操作，这使得问题很难发现和解决。</p>
<p>第二，线程安全：这是一个术语，它意味着代码的编写方式是多线程可以使用数据结构，而不会相互影响。如果线程 <em>A</em> 修改了线程 <em>B</em> 正在使用的东西，那么这就不是线程安全的。</p>
<p>值类型本质上是线程安全的，因为它们不是在线程之间共享的——每个线程都将获得自己的数据副本，并且可以在不影响其他线程的情况下尽可能多地操作该副本。每个副本都独立于其他副本，因此基于数据的竞态条件将消失。</p>
<p>消除(或至少显著减少)线程问题是很好的，但是值类型有一个更大的好处：它们大大减少了代码中存在的关系的数量。举个例子，常见的情况是 <em>Core Data</em> 应用程序在 <em>app delegate</em> 中设置数据库，然后在视图控制器之间传递对数据库或单个对象的引用。每次你在视图控制器之间传递一个对象时，你都在双向地连接它们——子视图控制器可以以任何方式修改那个对象，而所有这些变化都会无声地出现在父视图控制器中。</p>
<p>因此，应用程序中的对象关系可能不太像树，而更像意大利面工厂中的爆炸——联系无处不在，任何人所做的更改都可以在应用程序中显示和传播，这一切变得很难解释。也就是说，很难说“这段代码是如何工作的？”当你的物体被缠住的时候。</p>
<p>当你使用值类型时，这就不是问题了: 一旦将结构体从一个视图控制器传递到另一个视图控制器，子控制器就有了自己的独立副本 – 这里没有形成任何隐含的关系，子控制器也不可能搞乱自己和父控制器的值。</p>
<p>选择结构体而不是类的最后一个原因是：它们带有成员初始化。这意味着编译器自动生成一个初始化器，该初始化器为结构的每个属性提供默认值。例如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Person</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>
   <span class="token keyword">var</span> favoriteIceCream<span class="token punctuation">:</span> <span class="token builtin">String</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">,</span> favoriteIceCream<span class="token punctuation">:</span> <span class="token string">"Chocolate"</span><span class="token punctuation">)</span></code></pre>
<p>我知道这微不足道，但它非常实用，使结构更容易使用。</p>
<h2 id="为什么使用类类型？-Why-use-classes"><a href="#为什么使用类类型？-Why-use-classes" class="headerlink" title="为什么使用类类型？(Why use classes?)"></a>为什么使用类类型？(Why use classes?)</h2><p>使用类而不是结构有一些很好的理由，尽管它们中至少有一个会回来咬你一口。引用类型有点像命名或句柄，如果你是一个老派的开发人员，甚至是指针：当你传递它们时，每个人都指向相同的值。这意味着你可以创建一个资源，如数据库连接，并在应用程序中的许多对象之间共享它，而无需创建新的连接。</p>
<p>巧妙地说，类的这种共享特性是支持和反对使用值类型而不是引用类型的主要原因。原因之一是灵活性和性能：在短期内，很容易传递一个共享对象，并让每个人根据需要修改它。 这很糟糕，而且很脆弱，但它确实很容易编写代码。事实上，我建议这种方法是许多开发人员的默认方法，特别是那些来自 <em>Objective-C</em> 背景的开发人员。</p>
<p>这种方法也可能运行得非常快，因为你不需要每次将对象传递到其他地方时都创建对象的副本。相反，你只创建一个对象，并将其传递到需要它的地方——只要你的代码是线程安全的，对象甚至可以跨线程使用，而不用担心太多。</p>
<p>对象提供给你的一个结构体所没有的特性是继承：获取现有类并在其基础上构建的能力。多年来，继承一直是软件开发中的一个基本概念，并且现在已经深深地扎根于我们的行业中，很容易就可以追溯到一两代开发人员。它允许你使用现有的类，无论大小，并以任何你想要的方式构建它。你可能会添加一些小的调整，或大量的更改。有些语言(幸运的是不是 <em>Swift</em> !) 允许你从多个类中继承——这在智力上非常有趣，但很少使用，而且从来没有必要。</p>
<p>最后，使用类的一个主要原因是 <em>Cocoa Touch</em> 本身是使用类编写的：<em>UIKit</em> 、<em>SpriteKit</em> 、<em>MapKit*、 *Core Location</em> 等等都是面向对象的，<em>NSCoding</em> 和 <em>NSCopying</em> 等协议也是如此。如果你正在编写需要使用 <em>Cocoa</em> 或 <em>Cocoa Touch</em> 的 <em>Swift</em> 代码，比如将自定义数据类型保存到 <em>NSUserDefaults</em> ，那么你可能在某个时候需要类类型。</p>
<h2 id="在结构和类之间选择-Choosing-between-structs-and-classes"><a href="#在结构和类之间选择-Choosing-between-structs-and-classes" class="headerlink" title="在结构和类之间选择(Choosing between structs and classes)"></a>在结构和类之间选择(Choosing between structs and classes)</h2><p>在结构或类之间进行选择取决于你想要引用类型还是值类型行为。每种方法的一些优点实际上可能是缺点，这取决于你的上下文，因此你需要阅读下面的建议并自己决定。</p>
<p>首先，线程安全和不受竞争条件限制的好处是使用值类型的主要原因。很容易想象我们是一个非常聪明的程序员，能够在睡梦中处理多线程，但事实是，我们的大脑并不是这样工作的：计算机实际上可以同时执行两项、四项、八项或更多复杂的任务，这对于普通人来说极其困难，更不用说调试了。</p>
<p><em>Joel Spolsky</em> 就这个主题写了一篇优秀的文章，叫做 “<em>The Duct Tape Programmer</em> ”，他在文章中讨论了聪明的程序员采用简单解决方案的原则 – <em>the equivalent duct tape and WD-40</em> 。在这篇文章中，他引用了多线程作为复杂代码的一个例子，并说：“<em>The Duct Tape Programmer</em> 很好地理解的一个原则是，任何一种稍微复杂的编码技术都会毁了你的项目。”</p>
<p>你也不应该低估简化你的应用程序中的关系的价值。正如我已经提到的，每次你将一个对象从一个地方传递到另一个地方，你都在含蓄地创建一个关系，在未来的任何时候都可能适得其反。如果你只做过一两次这样的操作，那么跟踪它可能并不困难，但是你有多少次看到对象被传递了几十次的情况呢？如果你曾经使用过 <em>Core Data</em> ，你就会知道它与简单的关系建模截然相反。</p>
<p>对象允许你在应用的不同部分共享数据，但你真的需要吗？就绝对性能而言，它通常更有效，但是它会在你的体系结构中创建非常复杂的关系。有些值类型——特别是内置到 <em>Swift</em> 本身的值类型——具有一种称为写时复制(<em>copy on write)</em> 的优化，使得传递它们和传递对象一样高效，因为除非你试图更改值，否则 <em>Swift</em> 不会复制值。遗憾的是，这种优化并没有运用到你自定义的结构，所以你要么自己编写代码，要么(稍微)降低性能。</p>
<p>类的另一个主要优势是能够通过继承另一个类来创建新类。这是一个功能强大的特性，具有经过验证的跟踪记录，而且还有一个额外的好处，即数百万开发人员了解该技术并广泛使用它。但是，尽管继承功能强大，它也有自己的问题：如果你在设计一个聪明,有用的和清晰的架构，从 <em>A</em> 到 <em>B</em> 到 <em>C</em> 甚至是 <em>D</em>，如果你后来改变了主意，会发生什么 – 例如，试着移除 <em>B</em> 或者把 <em>E</em> 放到 <em>B</em> 所在的位置? 答案是，它变得非常混乱。</p>
<p>虽然继承在任何人的工具包中仍然是一个有价值的工具——特别是在构建 <em>Cocoa</em> 和 <em>Cocoa Touch</em> 时——但是一种更新、更简单的方法正在迅速流行起来：面向协议开发。在这里，你可以水平地而不是垂直地添加单个功能块，这允许你随时更改你的想法，而不会造成任何问题。<em>Swift</em> 强大的扩展类型和扩展能力使得继承远不如以前有用：我们通过功能组合而不是层次继承来生成强大的数据类型。</p>
<p>同样，你的选择很大程度上取决于你的使用场景。然而，基于以上，我想提供一些总结点，以帮助指导你。</p>
<p>首先，我建议你尽可能选择结构而不是类。如果没有继承就无法生存，或者迫切需要共享数据所有权，那么就使用类，但是结构应该始终是你的默认起点。我喜欢在自己的代码中使用结构，但在本书中，我偶尔使用类，因为我试图覆盖所有的基础。</p>
<p>其次，如果必须使用类，请将其声明为<code>final</code>。这将立即带给你性能提升，而且它也应该是你的默认设置：除非你特别认为，“是的，这个类可以安全地被其他类子类化”，否则允许它发生是一个错误。不要低估健壮子类的复杂性！</p>
<p>第三，尽可能地将结构体或类的属性声明为常量。不变性——数据无法被更改——多亏了<code>let</code> 这个关键字，它被完美地融入了 <em>Swift</em> ，这是一个值得坚持的好习惯。</p>
<p>第四，如果你发现自己无论如何都是从一个类开始的，这只是其他编程语言遗留下来的问题吗? <em>Objective-C</em> 开发人员几乎所有的事情都使用类，因此类可能是一个难以改变的习惯。如果你像写 <em>Objective-C</em> 一样写 <em>Swift</em> 的时候，那你将错过一半乐趣和一半的效率。对于这种新语言，我建议你在回到使用类之前对值类型进行彻底的了解。</p>
<h3 id="结合类和结构-Mixing-classes-and-structs"><a href="#结合类和结构-Mixing-classes-and-structs" class="headerlink" title="结合类和结构(Mixing classes and structs)"></a>结合类和结构(Mixing classes and structs)</h3><p>一旦理解了值类型和引用类型，在类和结构体之间进行选择就容易得多——至少在开始时是这样。但是随着应用程序的增长，你可能会发现你的情况变得不那么黑白分明了：你的应用程序可能 <em>95%</em> 的时间都在处理值类型，但是如果你使用引用类型，那么可能只需要一两次，一切就会变得简单得多。</p>
<p>所有这些都不会丢失：记住我所说的关于两者相对优势和劣势的所有内容，如果你确信这是正确的解决方案，那么有一种方法可以在多个地方共享值类型。这种技术被称为 <em>boxing</em> ——不是那种有力的、汗流浃背的拳击，而是“把东西放在盒子里”。这种方法将值类型封装在引用类型中，以便更容易地共享它，这种方法在 <em>c#</em> 和 <em>Java</em> 等语言中很常见。</p>
<blockquote>
<p>注意：我不会继续重复警告：共享而不是复制值会增加程序的复杂性；请将其视为已读！</p>
</blockquote>
<p>我想给你举一个实际的例子，让你自己看看它是如何工作的。首先，这里是我们的 <code>Person</code>结构：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Person</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>
   <span class="token keyword">var</span> favoriteIceCream<span class="token punctuation">:</span> <span class="token builtin">String</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">,</span> favoriteIceCream<span class="token punctuation">:</span> <span class="token string">"Chocolate"</span><span class="token punctuation">)</span></code></pre>
<p>如果我们想在多个对象之间共享<code>taylor</code>这个结构体，我们需要像这样创建一个<code>PersonBox</code>类：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PersonBox</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> person<span class="token punctuation">:</span> <span class="token builtin">Person</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span>person<span class="token punctuation">:</span> <span class="token builtin">Person</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">self</span><span class="token punctuation">.</span>person <span class="token operator">=</span> person
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> box <span class="token operator">=</span> <span class="token function">PersonBox</span><span class="token punctuation">(</span>person<span class="token punctuation">:</span> taylor<span class="token punctuation">)</span></code></pre>
<p>它是封装<code>Person</code>结构体的类容器，作为引用类型，将被共享而不是复制。</p>
<p>最后，让我们创建一个<code>TestContainer</code>类，它模拟应用程序的某些部分，例如不同的视图控制器：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TestContainer</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> box<span class="token punctuation">:</span> <span class="token builtin">PersonBox</span><span class="token operator">!</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> container1 <span class="token operator">=</span> <span class="token function">TestContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> container2 <span class="token operator">=</span> <span class="token function">TestContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
container1<span class="token punctuation">.</span>box <span class="token operator">=</span> box
container2<span class="token punctuation">.</span>box <span class="token operator">=</span> box</code></pre>
<p>这段代码创建两个容器，每个容器指向同一个<code>PersonBox</code>对象，这意味着它们指向同一个<code>Person</code>结构体。为了证明这一点，我们可以编写如下代码：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span>container1<span class="token punctuation">.</span>box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>container2<span class="token punctuation">.</span>box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Not Taylor"</span>
<span class="token function">print</span><span class="token punctuation">(</span>container1<span class="token punctuation">.</span>box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>container2<span class="token punctuation">.</span>box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span></code></pre>
<p>这将打印 “<em>Taylor Swift</em> ”两次，然后打印 “<em>Not Taylor</em> ”两次，以证明更改一个容器中的值会更改另一个容器中的值。</p>
<p>如果你打算广泛使用 <code>boxing</code> 和 <code>unboxing</code>（警告，我希望你可以自己写这个！），你可能需要考虑创建这样的通用<code>Box</code>类：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> value<span class="token punctuation">:</span> T
   <span class="token keyword">init</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value
<span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TestContainer</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> box<span class="token punctuation">:</span> <span class="token builtin">Box</span><span class="token operator">&lt;</span><span class="token builtin">Person</span><span class="token operator">></span><span class="token operator">!</span>
<span class="token punctuation">}</span></code></pre>
<p>这样就可以共享其他类型的结构，而不必创建许多不同的<code>Box</code>类。</p>
<p>不可否认的是，这种方法稍微削弱了值类型的能力和安全性，但至少它明确了哪些情况提供了值类型的安全性，哪些情况没有——你在声明“这部分是显式共享的”，而不是隐式共享所有内容。</p>
<p>还有一件事你应该知道，如果你有使用 <em>Objective-C</em> 的背景：如果你面临重要的引用计数性能问题，<code>boxing</code> 和 <code>unboxing</code>可能会很有帮助。<em>Swift</em> 与现代的 <em>Objective-C</em> 一样，使用了一个称为自动引用计数(<em>ARC</em>)的系统，它可以跟踪一个对象被引用的次数。当该计数达到 <em>0</em> 时，对象将自动销毁。</p>
<p><em>Swift</em> 的结构体不进行引用计数，因为它们始终是唯一引用的。但是，如果结构体包含一个对象作为它的属性之一，则该对象将被引用计数。</p>
<p>对于小的东西，这不是问题，但是如果你的结构有很多对象作为属性。假设有 <em>10</em> 个引用类型的属性，然后你的结构体每次被复制时 <em>ARC</em> 都需要做 <em>10</em> 次增加引用计数的操作。在这种情况下，将结构体装箱到包装对象中可以极大地简化工作，因为 <em>ARC</em> 只需要操作包装对象的引用计数，而不需要操作所有单独的属性。</p>
<h3 id="不可变性-Immutability"><a href="#不可变性-Immutability" class="headerlink" title="不可变性(Immutability)"></a>不可变性(Immutability)</h3><p>值和引用类型在处理不可变性的方式上有所不同，但我在这里将其分开，因为这是一个非常细微的差异，很容易混淆。</p>
<p>让我们回顾一下：我喜欢 <em>Swift</em> 的一点是，它积极地关注不变性。也就是说，很容易说“不要让这个值改变”。这不仅意味着在编写代码时鼓励你使用<code>let</code>而不是<code>var</code>，而且 <em>Swift</em> 编译器将扫描你的代码，并在发现可以将变量转换为常量的位置时发出警告。这和 <em>Objective-C</em> 非常不同，在<em>Objective-C*中，可变性只作为类名的一部分强制执行 *NSString</em> 有一个<em>NSMutableString</em> 对应项，<em>NSArray</em> 有一个 <em>NSMutableArray</em> 对应项，等等。</p>
<p>不变性和值类型似乎是密切相关的。毕竟，如果一个值只是一个值，它怎么能改变呢? 整型是 <em>Swift</em> 中的值类型，你不能确切地说 “嘿，我在改变数字 <em>5</em>，所以现在 <em>5</em> 实际上等于 <em>6</em> ”。但是当你开始比较类和结构时，不变性就更加复杂了，我想解释一下原因。</p>
<p>考虑以下代码：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">PersonStruct</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> taylor <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>
taylor<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span></code></pre>
<p>当代码运行时，<code>taylor</code> 实例的最终名称值是 “<em>Justin Bieber</em> ”，这对于任何参加演唱会的人来说都将是一个巨大的惊喜!</p>
<p>如果我们只修改一行代码，结果会非常不同：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>
taylor<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span></code></pre>
<p>只有一行不同，代码甚至无法编译，因为不允许更改<code>name</code>属性。即使<code>name</code> 和 <code>age</code>属性被标记为变量，<code>taylor</code>结构被标记为常量，因此 <em>Swift</em> 不允许它的任何部分更改。</p>
<p>这就是事情变得有点复杂的地方，但请认真对待：这真的很重要。考虑以下代码:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PersonClass</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
      <span class="token keyword">self</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age
   <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>

<span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">PersonClass</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>
taylor<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span></code></pre>
<p>这个例子使用的是 <code>PersonClass</code>类而不是结构体，但是它将 <code>taylor</code> 实例保留为常量。现在代码进行编译，这与它是一个结构体时非常不同。</p>
<p>当 <code>taylor</code> 是一个常量结构体时，你不能改变它的值或属性。当它是一个常量对象时，你不能改变它的值，但你可以改变它的属性，只要它们没有被单独标记为常量。这意味着使用结构允许你比使用类更强地执行不变性，这有助于进一步简化代码。</p>
<p>下面的代码显示了所有可能的选项——我已经注释掉了不能工作的代码:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// variable struct: changing property and changing value OK</span>
<span class="token keyword">var</span> taylor1 <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>
taylor1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span>

taylor1 <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Justin Bieber"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// constant struct: changing property or value not allowed</span>
<span class="token keyword">let</span> taylor2 <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">//taylor2.name = "Justin Bieber"</span>
<span class="token comment" spellcheck="true">//taylor2 = PersonStruct(name: "Justin Bieber", age: 22)</span>


<span class="token comment" spellcheck="true">// variable object: changing property and reference OK</span>
<span class="token keyword">var</span> taylor3 <span class="token operator">=</span> <span class="token function">PersonClass</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>
taylor3<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span>
taylor3 <span class="token operator">=</span> <span class="token function">PersonClass</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Justin Bieber"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// constant object: changing property OK, changing reference not allowed</span>
<span class="token keyword">let</span> taylor4 <span class="token operator">=</span> <span class="token function">PersonClass</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>
taylor4<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span>
<span class="token comment" spellcheck="true">//taylor4 = PersonClass(name: "Justin Bieber", age: 22)</span></code></pre>
<p>正如你所看到的，在使用常量的地方会发生差异：常量对象不能更改为指向新对象，但是你可以更改它的任何属性，而常量结构是完全固定的。</p>
<p>在处理集合(如数组)时，易变性是最常见的问题。这些是 <em>Swift</em> 中的值类型(万岁!)，但它们也可以是可变的——如果你将它们声明为 <em>var</em> ，你可以自由地添加和删除元素。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《第三章 引用类型和值类型(References and Values)》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2019/09/05/pro-swift-yi-wen/chapter3-references-and-values/" property="cc:attributionName"
               rel="cc:attributionURL">
                影痕
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'f3f4b0e75a31c33690a1',
        clientSecret: 'c7a167d236ca9107a6728fcc08468b5237eabe4f',
        repo: 'BlogComments',
        owner: 'LucioLee',
        admin: ["LucioLee"],
        id: '2019-09-05T10-59-00',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/09/06/pro-swift-yi-wen/chapter4-functions/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="第四章 函数(Functions)">
                        
                        <span class="card-title">第四章 函数(Functions)</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            可变参数函数、操作符重载、修改现有操作符、自定义操作符
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-09-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Pro-Swift/" class="post-category" target="_blank">
                                    Pro Swift
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Swift/" target="_blank">
                        <span class="chip bg-color">Swift</span>
                    </a>
                    
                    <a href="/tags/Pro-Swift/" target="_blank">
                        <span class="chip bg-color">Pro Swift</span>
                    </a>
                    
                    <a href="/tags/操作符重载/" target="_blank">
                        <span class="chip bg-color">操作符重载</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fa fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2019/09/04/pro-swift-yi-wen/chapter2-types/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="第二章 类型（Types）">
                        
                        <span class="card-title">第二章 类型（Types）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            高效初始化器、枚举、数组、集合、元组、范型
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-09-04
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Pro-Swift/" class="post-category" target="_blank">
                                    Pro Swift
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Swift/" target="_blank">
                        <span class="chip bg-color">Swift</span>
                    </a>
                    
                    <a href="/tags/Pro-Swift/" target="_blank">
                        <span class="chip bg-color">Pro Swift</span>
                    </a>
                    
                    <a href="/tags/范型/" target="_blank">
                        <span class="chip bg-color">范型</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('1')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;

        newdiv.innerHTML += '<br />'
            + '来源: Li&apos;s Note<br />'
            + '作者: 影痕<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归@影痕所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站版权归&copy;<a href="https://luciolee.github.io/" target="_blank">影痕</a>所有.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">55.4k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/LucioLee/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:lixinxin990467229@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=990467229" class="tooltipped" data-tooltip="QQ联系我: 990467229" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->




    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>