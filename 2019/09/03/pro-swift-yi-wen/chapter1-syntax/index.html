<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="第一章 语法（Syntax）, iOS">
    <meta name="description" content="当知道不需要重写声明时，对属性和方法使用final。 这允许编译器用直接调用替换动态派发调用。甚至可以通过将属性附加到类本身，将整个类标记为final。– Wendy Lu (@wendyluwho),Pinterest 的 iOS 工程师">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>第一章 语法（Syntax） | Li&#39;s Note</title>
    <link rel="icon" type="image/png" href="https://upload.jianshu.io/users/upload_avatars/1024068/b11e045f5e3e.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    <style type="text/css">
        
        code[class*="language-"], pre[class*="language-"] {
            white-space: pre !important;
        }
        
    </style>

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://upload.jianshu.io/users/upload_avatars/1024068/b11e045f5e3e.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Li's Note</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>首页</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>标签</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>分类</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>归档</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>关于</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/friends" class="waves-effect waves-light">
            
            <i class="fa fa-address-book"></i>
            
            <span>友情链接</span>
        </a>
    </li>
    
    <li>
        <a href="#searchModal" class="modal-trigger waves-effect waves-light">
            <i id="searchIcon" class="fa fa-search" title="搜索"></i>
        </a>
    </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://upload.jianshu.io/users/upload_avatars/1024068/b11e045f5e3e.jpg?imageMogr2/auto-orient/strip|imageView2/1/w/240/h/240" class="logo-img circle responsive-img">
        
        <div class="logo-name">Li's Note</div>
        <div class="logo-desc">
            
            iOS 程序猿一枚~
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                首页
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                标签
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                分类
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                归档
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                关于
            </a>
        </li>
        
        <li>
            <a href="/friends" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-address-book"></i>
                
                友情链接
            </a>
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>





<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/2.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        第一章 语法（Syntax）
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 20px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Swift/" target="_blank">
                                <span class="chip bg-color">Swift</span>
                            </a>
                        
                            <a href="/tags/Pro-Swift/" target="_blank">
                                <span class="chip bg-color">Pro Swift</span>
                            </a>
                        
                            <a href="/tags/模式匹配/" target="_blank">
                                <span class="chip bg-color">模式匹配</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fa fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Pro-Swift/" class="post-category" target="_blank">
                                Pro Swift
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                <div class="post-date info-break-policy">
                    <i class="fa fa-calendar-minus-o fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-09-03
                </div>

                
                    
                    <div class="info-break-policy">
                        <i class="fa fa-file-word-o fa-fw"></i>文章字数:&nbsp;&nbsp;
                        14.3k
                    </div>
                    

                    
                    <div class="info-break-policy">
                        <i class="fa fa-clock-o fa-fw"></i>阅读时长:&nbsp;&nbsp;
                        56 分
                    </div>
                    
                
				
				
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="fa fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>当知道不需要重写声明时，对属性和方法使用<code>final</code>。 这允许编译器用直接调用替换动态派发调用。甚至可以通过将属性附加到类本身，将整个类标记为<code>final</code>。<br>– <em>Wendy Lu (@wendyluwho),Pinterest</em> 的 <em>iOS</em> 工程师</p>
<h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><code>Switch/case</code>不是一个新概念：<strong>插入一个值，然后执行几个操作过程中的一个</strong>。<em>Swift</em> 对安全的关注增加了对混编的要求，所有可能的情况都要满足––如果没有启用特定的警告，你将无法在 <em>C</em> 中获得某些信息，但这是相当微不足道的。</p>
<p><em>Swift</em> 的<code>switch</code>语法之所以有趣，归功于它灵活、富有表现力的模式匹配。更有趣的是，自从 <em>Swift</em> 发布以来，大部分模式匹配都被扩展到了其他地方，所以在<code>if</code>条件和<code>for</code>循环中也可以使用同样灵活、有表现力的语法。</p>
<p>不可否认，如果你在深水区跳入水中，你更可能下沉而不是游泳，所以我想从基本的例子开始进行研究。为了刷新你的记忆，这里有一个基本的<code>switch</code>语句：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">"twostraws"</span>
<span class="token keyword">switch</span> name <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token string">"bilbo"</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token string">"twostraws"</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Authentication failed"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>当你处理一个简单的字符串时，这非常简单，但是当处理两个或多个值时，事情就变得更加复杂了。例如，如果我们想验证一个名称和密码，我们将把它们作为一个元组来计算：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">"twostraws"</span>
<span class="token keyword">let</span> password <span class="token operator">=</span> <span class="token string">"fr0st1es"</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>如果你愿意，可以将这两个值组合成一个元组，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> authentication <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"twostraws"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span>
<span class="token keyword">switch</span> authentication <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>在这种情况下，元组的两个部分都必须与<code>switch</code>匹配才能执行它。</p>
<h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><p>在处理元组时，有时需要部分匹配：<strong>你关心某些值是什么，但不关心其他值</strong>。在这种情况下，使用下划线表示<strong>任何值都可以</strong>，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> authentication <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"twostraws"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">,</span> ipAddress<span class="token punctuation">:</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span>
<span class="token keyword">switch</span> authentication <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>记住：<em>Swift</em> 将采用它发现的第一个匹配的案例，因此你需要确保首先查找最具体的内容。例如，下面的代码将打印 <em>You could be anybody!</em> 因为第一种情况会立即匹配，即使之后的案例会<strong>更好</strong>匹配，因为它们匹配的内容更多：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> authentication <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You could be anybody!"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>最后，如果你只想匹配元组的一部分，但仍然想知道另一部分是什么，那么应该使用<code>let</code>语法。</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> authentication <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token keyword">let</span> password<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson: your password was <span class="token interpolation"><span class="token delimiter variable">\(</span>password<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="匹配计算元组"><a href="#匹配计算元组" class="headerlink" title="匹配计算元组"></a>匹配计算元组</h3><p>到目前为止，我们的介绍已经覆盖了大多数开发人员使用模式匹配语法的基本范围。从这里开始，我想举一些其他不太为人所知的有用的模式匹配技术的例子。</p>
<p>元组最常使用静态值创建，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Paul"</span><span class="token punctuation">,</span> <span class="token string">"Hudson"</span><span class="token punctuation">)</span></code></pre>
<p>但元组和其他任何数据结构一样，都可以使用动态代码创建。当你希望将元组中的值范围缩小到较小的子集，以便只需要少数<code>case</code>语句时，这一点特别有用。</p>
<p>为了给你一个实际的例子，考虑 <strong><em>fizz buzz</em></strong> 测试：编写一个接受任何数字的函数，如果数字被 <em>3</em> 整除，则返回 <code>fizz</code>；如果数字被 <em>5</em> 整除，则返回 <code>buzz</code>；如果数字被 <em>3</em> 和 <em>5</em> 整除，则返回<code>fizzbuzz</code>；在其他情况下，返回原始输入数字。</p>
<p>我们可以计算一个元组来解决这个问题，然后将该元组传递到一个<code>switch</code>中以创建正确的输出。代码如下：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fizzbuzz</span><span class="token punctuation">(</span>number<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
   <span class="token keyword">switch</span> <span class="token punctuation">(</span>number <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> number <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token string">"Fizz"</span>
   <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token string">"Buzz"</span>
   <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token string">"FizzBuzz"</span>
   <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token function">fizzbuzz</span><span class="token punctuation">(</span>number<span class="token punctuation">:</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>这种方法将大的输入空间(任何数字)分解为真和假的简单组合，然后在<code>case</code>语句中使用元组模式匹配来选择正确的输出。</p>
<h3 id="循环-Loops"><a href="#循环-Loops" class="headerlink" title="循环(Loops)"></a>循环(Loops)</h3><p>正如你所看到的，使用元组的一部分进行模式匹配非常简单：你可以告诉 <em>Swift</em> 应该匹配什么，使用<code>let</code>将值绑定到局部常量，或者使用<code>_</code>表示你不关心值是什么。</p>
<p>在处理循环时，我们可以使用相同的方法，这允许我们只在项与我们指定的条件匹配时遍历项。让我们再次从一个基本示例开始：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> twostraws <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"twostraws"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> bilbo <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"bilbo"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"taylor"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> users <span class="token operator">=</span> <span class="token punctuation">[</span>twostraws<span class="token punctuation">,</span> bilbo<span class="token punctuation">,</span> taylor<span class="token punctuation">]</span>
<span class="token keyword">for</span> user <span class="token keyword">in</span> users <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>这将创建一个元组数组，然后循环遍历每个元组并打印其<code>name</code>的值。</p>
<p>就像我们前面看到的<code>switch</code>块一样，我们可以用<code>case</code>和元组来匹配<br>元组中的特定值。在之前的循环下面添加以下代码:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span> <span class="token keyword">in</span> users <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User twostraws has the password fr0st1es"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>我们也有相同的语法来将局部常量绑定到每个元组的值，例如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token keyword">let</span> name<span class="token punctuation">,</span> <span class="token keyword">let</span> password<span class="token punctuation">)</span> <span class="token keyword">in</span> users <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the password <span class="token interpolation"><span class="token delimiter variable">\(</span>password<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>不过，通常情况下，最好将<code>let</code>重新放置为：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token keyword">in</span> users <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the password <span class="token interpolation"><span class="token delimiter variable">\(</span>password<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>神奇的是，当你把这两种方法结合起来的时候，在语法上和我们已经看到的<code>switch</code>例子是一样的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span> <span class="token keyword">in</span> users <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the password \"fr0st1es\""</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>它过滤<code>users</code>数组，这样只有密码为<code>fr0st1es</code>的项才会在循环中使用，然后在循环中创建一个<code>name</code>常量供你使用。</p>
<p>如果你正盯着<code>for case let</code>，看到三个完全不同的关键字混在一起，不要担心：除非有人向你解释它，否则它做什么并不明显，而且要花一点时间才能理解。但我们才刚刚开始…</p>
<h3 id="匹配可选值-Matching-optionals"><a href="#匹配可选值-Matching-optionals" class="headerlink" title="匹配可选值(Matching optionals)"></a>匹配可选值(Matching optionals)</h3><p><em>Swift</em> 有两种匹配可选值的方法，你很可能会同时遇到这两种方法。首先是<br>使用<code>.some</code>和<code>.none</code>来匹配<strong>有值</strong>和<strong>没有值</strong>，在下面的代码中，它用于检查值并将它们绑定到本地常量:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"twostraws"</span>
<span class="token keyword">let</span> password<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"fr0st1es"</span>
<span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token keyword">none</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Please enter a password."</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>由于<code>name</code>和<code>password</code>用于输入常量和本地绑定的常量，这段代码变得更加容易混淆。但是，它们是不同的东西，这就是为什么 <code>print("Hello,\(name)")</code> 不会打印 <em>Hello, Optional(“twostraws”)</em> —— 这里所使用的<code>name</code>是本地绑定展开的可选名称。</p>
<p>如果想更容易阅读，下面是相同的代码，不同的名称用于匹配的常量：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>matchedName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>matchedPassword<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>matchedName<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>matchedName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token keyword">none</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Please enter a password."</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p><em>Swift</em> 匹配可选值的第二种方法是使用更简单的语法，尽管如果你害怕可选值，这只会让情况变得更糟:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token operator">?</span><span class="token punctuation">,</span> password<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>username<span class="token operator">?</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Please enter a password."</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>这一次问号的工作方式与可选链类似：<strong>仅当找到值时才继续</strong>。</p>
<p>这两种方法在<code>if case let</code>代码中都同样有效。下面的代码同时使用它们在循环中过滤掉的<code>nil</code>值:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span>
<span class="token keyword">let</span> data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Bill"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">,</span> <span class="token string">"Ted"</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>datum<span class="token punctuation">)</span> <span class="token keyword">in</span> data <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>datum<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> datum<span class="token operator">?</span> <span class="token keyword">in</span> data <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>datum<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="匹配范围-Matching-ranges"><a href="#匹配范围-Matching-ranges" class="headerlink" title="匹配范围(Matching ranges)"></a>匹配范围(Matching ranges)</h3><p>你可能已经在使用与范围匹配的模式，通常使用如下代码：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">36</span>
<span class="token keyword">switch</span> age <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and time, but not the money"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and money, but not the time"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the time and money, but not the energy"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>对于常规条件语句，也可以使用非常相似的语法–我们可以这样重写代码：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">case</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span> <span class="token operator">=</span> age <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and time, but not the money"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">case</span> <span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span> <span class="token operator">=</span> age <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and money, but not the time"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the time and money, but not the energy"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>在使用类似语法的情况下，这将产生与<code>switch</code>块相同的结果，但我不太喜欢这种方法。我不喜欢它的原因很简单：我不认为<strong>如果0到18的范围等于年龄</strong>是合理的，如果你还不知道它这意味着什么。一个更好的方法是使用模式匹配操作符<code>~=</code>，它看起来像这样:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span> <span class="token operator">~</span><span class="token operator">=</span> age <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and time, but not the money"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span> <span class="token operator">~</span><span class="token operator">=</span> age <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and money, but not the time"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the time and money, but not the energy"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>现在条件是<strong>如果0到18的范围与年龄相匹配</strong>，我认为这更有意义。</p>
<p>当你记住<code>0..&lt;18</code>创建了一个具有自己方法集的<code>Range</code>结构的实例时，一个更清晰的解决方案就浮出水面了。现在，它的<code>contains()</code>方法特别有用：它的输入时间比<code>~=</code>长，但更容易理解：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and time, but not the money"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and money, but not the time"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the time and money, but not the energy"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>你可以将此范围匹配组合到现有的元组匹配代码中，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"twostraws"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">36</span><span class="token punctuation">)</span>
<span class="token keyword">switch</span> user <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the energy and time, but no money"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the money and energy, but no time"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the time and money, but no energy"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>最后一种情况将用户名绑定到名为<code>name</code>的本地常量，而不考虑元组中的其他两个值。这是一个匹配所有的<code>case</code>，但因为 <em>Swift</em> 寻找第一个匹配的<code>case</code>，这不会与<code>switch</code>块中的其他两个冲突。</p>
<h3 id="匹配枚举和关联值-Matching-enums-and-associated-values"><a href="#匹配枚举和关联值-Matching-enums-and-associated-values" class="headerlink" title="匹配枚举和关联值(Matching enums and associated values)"></a>匹配枚举和关联值(Matching enums and associated values)</h3><p>根据我的经验，相当多的人并不真正理解枚举和关联值，因此他们很难利用它们进行模式匹配。本书后面有一整章都是关于枚举的，所以如果你对枚举和相关的值还不熟悉的话，你可能需要在这里暂停并首先阅读该章节。</p>
<p>基本枚举匹配是这样的:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> cloudy
   <span class="token keyword">case</span> sunny
   <span class="token keyword">case</span> windy 
<span class="token punctuation">}</span>

<span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span>cloudy

<span class="token keyword">switch</span> today <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>cloudy<span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>你还将在基本条件语句中使用枚举，如下所示:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> today <span class="token operator">==</span> <span class="token punctuation">.</span>cloudy <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>一旦你添加了关联值，事情就会变得更加复杂，因为你可以使用它们，过滤它们，或者根据你的目标忽略它们。</p>
<p>首先，最简单的选项：创建关联值，但忽略它：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>
   <span class="token keyword">case</span> sunny
   <span class="token keyword">case</span> windy
<span class="token punctuation">}</span>
<span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span>

<span class="token keyword">switch</span> today <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>cloudy<span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>使用这种方法，实际上<code>switch</code>代码是不变的。</p>
<p>第二：创建关联值并使用它。这使用了我们已经多次看到的相同的本地常量绑定：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>
   <span class="token keyword">case</span> sunny
   <span class="token keyword">case</span> windy
<span class="token punctuation">}</span>

<span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span>

<span class="token keyword">switch</span> today <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>最后：创建一个关联类型，将一个本地常量绑定到该类型，同时使用该绑定来筛选特定的值。它使用<code>where</code>关键字创建一个需求子句，以阐明你要查找的内容。在我们的例子中，下面的代码根据<code>cloudy</code>使用的关联值打印了两条不同的消息：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>
   <span class="token keyword">case</span> sunny
   <span class="token keyword">case</span> windy
<span class="token punctuation">}</span>

<span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span>

<span class="token keyword">switch</span> today <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> coverage <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> coverage <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You must live in the UK"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>现在，正如我所承诺的，我将从基本示例开始构建，但是如果你已经准备好了，我想向你展示如何将这两种技术组合在一起：<strong>关联值和范围匹配</strong>。下面的代码现在打印了四条不同的消息：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>
   <span class="token keyword">case</span> sunny
   <span class="token keyword">case</span> windy
<span class="token punctuation">}</span>
<span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token keyword">switch</span> today <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> coverage <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You must live in Death Valley"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>coverage<span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's a bit cloudy, with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token number">51</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>coverage<span class="token punctuation">)</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's very cloudy, with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> coverage <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You must live in the UK"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>如果要匹配循环中的关联值，添加<code>where</code>子句是错误的方法。事实上，这类代码甚至无法编译:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> forecast<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">WeatherType</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">,</span> <span class="token punctuation">.</span>windy<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">]</span>
<span class="token keyword">for</span> day <span class="token keyword">in</span> forecast <span class="token keyword">where</span> day <span class="token operator">==</span> <span class="token punctuation">.</span>cloudy <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>如果没有关联值，该代码就可以了，但是因为关联值意味着<code>where</code>子句不能胜任工作–它无法说<strong>并将关联的值绑定到本地常量</strong>。相反，你将回到<code>case-let</code>语法，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> forecast<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">WeatherType</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">,</span> <span class="token punctuation">.</span>windy<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">]</span>
<span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">)</span> <span class="token keyword">in</span> forecast <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>如果你想知道关联值，并想把它用作过滤条件，语法几乎是一样的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> forecast<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">WeatherType</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">,</span> <span class="token punctuation">.</span>windy<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">]</span>
<span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token keyword">in</span> forecast <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy with 40% coverage"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="匹配类型-Matching-types"><a href="#匹配类型-Matching-types" class="headerlink" title="匹配类型(Matching types)"></a>匹配类型(Matching types)</h3><p>你应该已经知道用于匹配的<code>is</code>关键字，但是你可能不知道它可以在循环和<code>switch</code>块中用于模式匹配。我觉得这个语法很好用，所以我想简单说明一下：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> view<span class="token punctuation">:</span> <span class="token builtin">AnyObject</span> <span class="token operator">=</span> <span class="token function">UIButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">switch</span> view <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UIButton</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a button"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UILabel</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a label"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UISwitch</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a switch"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UIView</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a view"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found something else"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>我以 <em>UIKit</em> 为例，因为你应该已经知道<code>UIButton</code>继承自<code>UIView</code>，我需要给你一个大大的警告…</p>
<p><strong>记住</strong>：<em>Swift</em> 将接受它找到的第一个匹配的情况，如果对象是特定类型或其父类之一，则<code>is</code>返回<code>true</code>。因此，上面的代码将打印 <strong>Found a button</strong>，而下面的代码将打印 <strong>Found a view</strong>：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> view<span class="token punctuation">:</span> <span class="token builtin">AnyObject</span> <span class="token operator">=</span> <span class="token function">UIButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">switch</span> view <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UIView</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a view"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UIButton</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a button"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UILabel</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a label"</span><span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UISwitch</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a switch"</span><span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found something else"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>为了给你提供一个更有用的示例，你可以使用此方法循环数组中的所有子视图并筛选<code>UILabel</code>：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> label <span class="token keyword">in</span> view<span class="token punctuation">.</span>subviews <span class="token keyword">where</span> label <span class="token keyword">is</span> <span class="token builtin">UILabel</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a label with frame <span class="token interpolation"><span class="token delimiter variable">\(</span>label<span class="token punctuation">.</span>frame<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>尽管<code>where</code>确保在循环中只处理<code>UILabel</code>对象，但实际上它不执行任何类型转换。这意味着，如果你想访问<code>label</code>的特定属性，比如它的<code>text</code>属性，你需要自己对它进行类型转换。在这种情况下，使用<code>for case let</code>更容易，因为它在过滤的同时进行类型转换:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> label <span class="token keyword">as</span> <span class="token builtin">UILabel</span> <span class="token keyword">in</span> view<span class="token punctuation">.</span>subviews <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a label with text <span class="token interpolation"><span class="token delimiter variable">\(</span>label<span class="token punctuation">.</span>text<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="使用WHERE关键词-Using-the-where-keyword"><a href="#使用WHERE关键词-Using-the-where-keyword" class="headerlink" title="使用WHERE关键词(Using the where keyword)"></a>使用WHERE关键词(Using the where keyword)</h3><p>为了总结模式匹配，我想演示一些有趣的使用<code>where</code>子句的方法，以便你了解它的功能。</p>
<p>首先，一个简单的方法：循环一组数字，只打印奇数。使用<code>where</code>和取模运算这很简单，但它表明<code>where</code>子句可以包含计算：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> number <span class="token keyword">in</span> numbers <span class="token keyword">where</span> number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>也可以调用方法，如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> celebrities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Michael Jackson"</span><span class="token punctuation">,</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> <span class="token string">"Michael Caine"</span><span class="token punctuation">,</span> <span class="token string">"Adele Adkins"</span><span class="token punctuation">,</span> <span class="token string">"Michael Jordan"</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> name <span class="token keyword">in</span> celebrities <span class="token keyword">where</span> <span class="token operator">!</span>name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>这将打印 <strong><em>Taylor Swift</em></strong> 和 <strong><em>Adele Adkins</em></strong>。如果要使<code>where</code>子句更复杂，只需添加<code>&amp;&amp;</code>等运算符即可。</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> celebrities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Michael Jackson"</span><span class="token punctuation">,</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> <span class="token string">"Michael Caine"</span><span class="token punctuation">,</span> <span class="token string">"Adele Adkins"</span><span class="token punctuation">,</span> <span class="token string">"Michael Jordan"</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> name <span class="token keyword">in</span> celebrities <span class="token keyword">where</span> name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>
name<span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">==</span> <span class="token number">13</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>这将打印 <strong><em>Michael Caine</em></strong>。</p>
<p>虽然可以使用<code>where</code>子句剔除可选值，但我不推荐。请考虑下面的示例：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> celebrities<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Michael Jackson"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Michael Caine"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Michael Jordan"</span><span class="token punctuation">]</span>
<span class="token keyword">for</span> name <span class="token keyword">in</span> celebrities <span class="token keyword">where</span> name <span class="token operator">!=</span> <span class="token constant">nil</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>这当然有用，但它对循环中的字符串的可选性没有任何影响，所以它输出如下:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token function">Optional</span><span class="token punctuation">(</span><span class="token string">"Michael Jackson"</span><span class="token punctuation">)</span>
<span class="token function">Optional</span><span class="token punctuation">(</span><span class="token string">"Michael Caine"</span><span class="token punctuation">)</span>
<span class="token function">Optional</span><span class="token punctuation">(</span><span class="token string">"Michael Jordan"</span><span class="token punctuation">)</span></code></pre>
<p>相反，使用<code>for case let</code>来处理可选值，并使用<code>where</code>来过滤值。下面是编写循环的首选方法:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> name<span class="token operator">?</span> <span class="token keyword">in</span> celebrities <span class="token keyword">where</span> name<span class="token punctuation">.</span><span class="token function">hasSuffix</span><span class="token punctuation">(</span><span class="token string">"Jackson"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>运行时，<code>name</code>只包含具有值且后缀为<code>Jackson</code>的字符串，因此其输出为:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Michael</span> <span class="token builtin">Jackson</span></code></pre>
<h2 id="空值合并-Nil-coalescing"><a href="#空值合并-Nil-coalescing" class="headerlink" title="空值合并(Nil coalescing)"></a>空值合并(Nil coalescing)</h2><p><em>Swift</em> 可选值是保证程序安全的基本方法之一：<strong>只有在变量确实具有值时才能使用它</strong>。问题是可选值使代码更难读和写，因为你需要安全地展开它们。</p>
<p>一种替代方法是使用<code>!</code>显式地展开可选值。这也被称为<strong>崩溃操作符</strong>，因为如果你在值为<code>nil</code>的可选值上使用<code>!</code>，你的程序将立即奔溃。</p>
<p>一个更聪明的选择是空合运算符<code>??</code>，它允许你访问可选值，并在可选值为<code>nil</code>时提供默认值。</p>
<p>考虑这个可选值:</p>
<pre><code>let name: String? = "Taylor"</code></pre><p>这是一个名为<code>name</code>的常量，包含一个字符串或<code>nil</code>。如果你试图用<code>print(name)</code>打印它，你会看到<code>Optional("Taylor")</code>，而不是<code>"Taylor"</code>，这不是你真正想要的。</p>
<p>使用空值合并允许我们使用可选的值，或者提供一个默认值（如果为<code>nil</code>）。所以，你可以这样写：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"Taylor"</span>
<span class="token keyword">let</span> unwrappedName <span class="token operator">=</span> name <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Anonymous"</span>
<span class="token function">print</span><span class="token punctuation">(</span>unwrappedName<span class="token punctuation">)</span></code></pre>
<p>这将打印<code>"Taylor"</code>: <code>name</code>是<code>String?</code>，但是<code>unwrappedName</code>保证是一个常量字符串(不是可选的)，因为使用了空合运算符。要查看默认值的实际操作，请尝试以下操作:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token constant">nil</span>
<span class="token keyword">let</span> unwrappedName <span class="token operator">=</span> name <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Anonymous"</span>
<span class="token function">print</span><span class="token punctuation">(</span>unwrappedName<span class="token punctuation">)</span></code></pre>
<p>现在将打印<code>"Anonymous"</code>，因为使用的是默认值。</p>
<p>当然，当使用空值合并时，你不需要一个单独的常量——你可以在内联中编写它，如下所示:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"Taylor"</span>
<span class="token function">print</span><span class="token punctuation">(</span>name <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Anonymous"</span><span class="token punctuation">)</span></code></pre>
<p>正如您可以想象的那样，空值合并对于确保在使用前合理的值已经就位是非常非常有用的，但是它对于从代码中删除一些可选性特别有用。例如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">returnsOptionalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token constant">nil</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> returnedName <span class="token operator">=</span> <span class="token function">returnsOptionalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Anonymous"</span>
<span class="token function">print</span><span class="token punctuation">(</span>returnedName<span class="token punctuation">)</span></code></pre>
<p>使用这种方法，<code>returnedName</code>是<code>String</code>而不是<code>String?</code>, 因为它是有值的。</p>
<p>到目前为止，一切都很简单。然而，当你将空值合并与<code>try?</code> 关键字结合起来时，它会变得更加有趣。</p>
<p>考虑一个简单的应用程序，它允许用户键入并保存文本。当应用程序运行时，它希望加载用户以前键入的任何内容，因此它可能使用如下代码：</p>
<pre><code>do {
   let savedText = try String(contentsOfFile: "saved.txt")
   print(savedText)
} catch {
   print("Failed to load saved text.")
}</code></pre><p>如果文件存在，它将加载到<code>savedText</code>常量中。否则 <code>contentsOfFile</code>初始化器将抛出异常，并打印<strong>未能加载保存的文本</strong>。在实际中，你想要扩展它，以便<code>savedText</code>总是有一个值，所以你最终得到这样的结果:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> savedText<span class="token punctuation">:</span> <span class="token builtin">String</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
   savedText <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">String</span><span class="token punctuation">(</span>contentsOfFile<span class="token punctuation">:</span> <span class="token string">"saved.txt"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Failed to load saved text."</span><span class="token punctuation">)</span>
   savedText <span class="token operator">=</span> <span class="token string">"Hello, world!"</span>
<span class="token punctuation">}</span>
<span class="token function">print</span><span class="token punctuation">(</span>savedText<span class="token punctuation">)</span></code></pre>
<p>这是很多代码，但实际上并没有完成很多工作。幸运的是，有一种更好的方法：空值合并。记住，<code>try</code>有三种变体：<code>try</code>尝试一些代码，并可能引发异常，<code>try！</code>尝试一些代码并在应用程序失败时崩溃，然后<code>try?</code>尝试一些代码，如果调用失败，则返回<code>nil</code>。</p>
<p>最后一个例子是空值合并的使用场景，因为这与前面的示例完全匹配：我们希望使用可选值，如果可选值为<code>nil</code>，则提供合理的默认值。事实上，使用空值合并，我们可以将所有这些代码重写为两行代码：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> savedText <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">try</span><span class="token operator">?</span> <span class="token function">String</span><span class="token punctuation">(</span>contentsOfFile<span class="token punctuation">:</span> <span class="token string">"saved.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Hello, world!"</span>
<span class="token function">print</span><span class="token punctuation">(</span>savedText<span class="token punctuation">)</span></code></pre>
<p>这意味着<strong>尝试加载文件，但如果加载失败，则使用此默认文本</strong>——更整洁的解决方案，可读性更高。</p>
<p>结合<code>try?</code>和空值合并非常适合于失败的<code>try</code>不是错误的情况，我认为你会发现这种模式在你自己的代码中非常有用。</p>
<h2 id="Guard"><a href="#Guard" class="headerlink" title="Guard"></a>Guard</h2><p>从 <em>Swift 2.0</em> 开始，<code>guard</code>这个关键字就一直伴随着我们，但是因为它一次性同时做了四件事，所以你没有充分使用它是值得原谅的。</p>
<p>第一种用法是最明显的：<code>guard</code>用于早期返回，这意味着如果某些前提条件不满足，则退出函数。例如，我们可以编写一个带有偏见的函数来给一个指定的人颁奖:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">giveAward</span><span class="token punctuation">(</span>to name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">guard</span> name <span class="token operator">==</span> <span class="token string">"Taylor Swift"</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No way!"</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span>
   <span class="token punctuation">}</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Congratulations, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">giveAward</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span></code></pre>
<p>使用<code>giveAward(to:)</code>方法中的<code>guard</code>声明可以确保只有<code>Taylor Swift</code>赢得奖项。正如我所说，这是有偏见的，但是前提条件是明确的，并且只有在满足我设置的需求时，这段代码才会运行。</p>
<p>这个最初的示例看起来几乎与使用<code>if</code>相同，但是<code>guard</code>有一个巨大的优势：它使你的意图变得清晰，不仅对人们，而且对编译器也是如此。这是一个早期返回，也就是说，如果不满足前提条件，你希望退出该方法。使用<code>guard</code>可以清楚地表明：这种情况不是方法功能的一部分，只是为了确保实际的代码可以安全运行。编译器也很清楚，这意味着如果删除<code>return</code>语句，代码将不再生成—— <em>Swift</em> 知道这是一个早期返回，因此它不会让你忘记退出。</p>
<p>使用<code>guard</code>的第二个好处是第一个好处的副作用：使用<code>guard</code>和早期返回可以降低缩进级别。一些开发人员坚信不能使用早期的返回，相反，每个函数应该只从一个地方返回。会在函数代码的主体中强制进行额外的缩进，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">giveAward</span><span class="token punctuation">(</span>to name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> message<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">"Taylor Swift"</span> <span class="token punctuation">{</span>
      message <span class="token operator">=</span> <span class="token string">"Congratulations, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>!"</span>
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      message <span class="token operator">=</span> <span class="token string">"No way!"</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">return</span> message
<span class="token punctuation">}</span>
<span class="token function">giveAward</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span></code></pre>
<p>有了<code>guard</code>，你的先决条件立刻得到解决，并丢弃额外的缩进——为整齐的代码欢呼!</p>
<p><code>guard</code>带给我们的第三件事是提高主逻辑的明显性。这是软件设计和测试中的一个常见概念，指的是当没有异常或错误发生时，代码将采用的路径。由于有了<code>guard</code>，常见的错误会立即被删除，代码的其余部分可能都是正确的路径。</p>
<p>这些都是很简单的事情，但是<code>guard</code>还有一个我想要讨论的特性，它是<code>guard</code>和<code>if</code>之间的一个重要区别：当你使用<code>guard</code>检查和解包一个可选值时，这个可选值会留在作用域中。</p>
<p>为了演示这一点，我将重写<code>giveAward(To:)</code>方法，使它接受一个可选的字符串:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">giveAward</span><span class="token punctuation">(</span>to name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">guard</span> <span class="token keyword">let</span> winner <span class="token operator">=</span> name <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No one won the award"</span><span class="token punctuation">)</span>
      <span class="token keyword">return</span>
    <span class="token punctuation">}</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Congratulations, <span class="token interpolation"><span class="token delimiter variable">\(</span>winner<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>如果使用常规的<code>if-let</code>，<code>winner</code>常量只能在属于<code>guard</code>的大括号内使用。然而，<code>guard</code>在作用域中保持其可选的展开，因此<code>winner</code>将在第二个<code>print()</code>语句中保留。这段代码读作<strong>尝试将<code>name</code>解包到<code>winner</code>，这样我就可以使用它了，但是如果你不能，那么就打印一条消息并退出。</strong>”</p>
<p>我想介绍一下<code>guard</code>的最后一个特性，但它并不新鲜。相反，它只是一种使用你已经知道的东西的不同方式。特性是：<strong>如果前提条件失败，<code>guard</code>允许你退出任何范围，而不仅仅是函数和方法。</strong>这意味着你可以使用<code>guard</code>退出<code>switch</code>块或循环，它具有相同的含义：<strong>只有当这些前提条件为真时，才应执行此范围的内容。</strong></p>
<p>举个简单的例子，这个循环从 <em>1</em> 到 <em>100*，打印出所有能被 *8</em> 整除的数:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">100</span> <span class="token punctuation">{</span>
   <span class="token keyword">guard</span> i <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">continue</span> <span class="token punctuation">}</span>
   <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> 
<span class="token punctuation">}</span></code></pre>
<p>你能用<code>where</code>重写一下吗？试一试——它比你想象的要容易！</p>
<pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// 答案</span>
<span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">100</span> <span class="token keyword">where</span>  i <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>
    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h2 id="懒加载-Lazy-loading"><a href="#懒加载-Lazy-loading" class="headerlink" title="懒加载(Lazy loading)"></a>懒加载(Lazy loading)</h2><p>延迟加载是 <em>Swift</em> 编码人员进行的最重要的全系统性能优化之一。它在 <em>iOS</em> 中很普遍，任何试图在视图控制器的视图显示之前操纵它的人都能告诉你。<em>Objective-C</em> 没有惰性属性的概念，因此每次需要这种行为时，都必须编写自己的样板代码。令人欣慰的是，<em>Swift</em> 已经将它完全融入其中，所以你几乎不需要任何代码就可以立即获得性能优势。</p>
<p>但首先：提醒一下什么是惰性属性。考虑一下这个类:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
   <span class="token punctuation">}</span>   
   <span class="token keyword">func</span> <span class="token function">reversedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">"\(name.uppercased()) backwards is \(String(name.uppercased().characters.reversed()))!"</span>
   <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>
<span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>taylor<span class="token punctuation">.</span><span class="token function">reversedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>这将在运行时打印 <strong><em>TAYLOR SWIFT backwards is TFIWS ROLYAT!</em></strong>。</p>
<p>每个<code>Singer</code>都有一个名为<code>name</code>的属性，还有一个方法对这个属性进行少量处理。显然，在你自己的代码中，这些函数可能会做更重要的工作，但是我在这里尽量保持简单。</p>
<p>每次你想打印消息 <strong><em>TAYLOR SWIFT reverse is TFIWS ROLYAT!</em></strong> 时，你都需要调用<code>reversedName()</code>方法——它所做的工作不会被存储，如果该工作不是琐碎的，那么重复调用该方法就是浪费。</p>
<p>另一种方法是创建一个额外的属性来存储<code>reversedName</code>，这样它只计算一次，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">let</span> reversedName<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
      reversedName <span class="token operator">=</span> <span class="token string">"\(name.uppercased()) backwards is \(String(name.uppercased().characters.reversed()))!"</span>
<span class="token punctuation">}</span> <span class="token punctuation">}</span>
<span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>taylor<span class="token punctuation">.</span>reversedName<span class="token punctuation">)</span></code></pre>
<p>对于经常使用<code>reversedName</code>的情况，这是一种性能改进，但是如果从不使用<code>reversedName</code>，则会导致代码运行得更慢——无论是否使用，都会计算它，而当<code>reversedName()</code>是一个方法时，它只会在调用时计算。</p>
<p>惰性属性是中间地带：它们是只计算一次并存储的属性，但是如果不使用它们，就永远不会计算。因此，如果你的代码重复使用惰性属性，那么只需要付出一次性能代价，如果这些属性从未使用过，那么代码就永远不会运行。这是双赢的!</p>
<h3 id="懒闭包-Lazy-closures"><a href="#懒闭包-Lazy-closures" class="headerlink" title="懒闭包(Lazy closures)"></a>懒闭包(Lazy closures)</h3><p>开始使用<code>lazy</code>关键字的最简单方法是使用闭包。 是的，我知道在同一个句子中看到 <strong><em>closures(闭包)</em></strong> 和<strong><em>easiest(最简单的)</em></strong> 的情况很少见，但有一个原因，这本书不叫<strong><em>Newbie Swift(新手Swift)！</em></strong></p>
<p>这里的语法一开始有点不寻常:</p>
<pre class=" language-Swift"><code class="language-Swift">lazy var yourVariableName: SomeType = {
   return SomeType(whatever: "foobar")
}()</code></pre>
<p>是的，你需要显式地声明类型。是的，你需要那个<code>=</code>号。是的，你需要在右大括号后面加上小括号。这有点不寻常，就像我说的，但它的存在是有原因的：你正在创建闭包，立即应用它(而不是稍后)，并将其结果分配回<code>variablename</code>。</p>
<p>使用这种方法，我们可以将<code>reversedName()</code>方法转换成如下所示的惰性属性：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
   <span class="token punctuation">}</span>
   <span class="token keyword">lazy</span> <span class="token keyword">var</span> reversedName<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">"\(self.name.uppercased()) backwards is \(String(self.name.uppercased().characters.reversed()))!"</span>
   <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
<span class="token punctuation">}</span>
<span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>taylor<span class="token punctuation">.</span>reversedName<span class="token punctuation">)</span></code></pre>
<blockquote>
<p><strong>注意</strong>：由于它现在是一个属性而不是方法，所以我们需要使用<code>print(taylor.reversedName)</code>而不是<code>print(taylor.reversedName())</code>来访问该值。</p>
</blockquote>
<p>就是这样：属性现在是惰性的，这意味着只有在第一次读取<code>reversedName</code>属性时才会执行闭包中的代码。</p>
<p>“<strong>但保罗，</strong>” 我听到你说，“<strong>你在一个由对象拥有的闭包中使用<code>self</code> - 为什么你给我一个循环引用？</strong>” 别担心：这段代码非常安全。 <em>Swift</em> 聪明到足以意识到正在发生的事情，并且不会创建任何循环引用。</p>
<p>在引擎下，任何这样的闭包 - 立即应用的 - 被认为是 <strong><em>non-escaping(非逃逸)</em></strong>，在我们的情况下意味着它不会在其他任何地方使用。 也就是说，此闭包不能存储为属性并稍后调用。 这不仅会自动确保<code>self</code>被认为是<code>unowned</code>，而且还使 <em>Swift</em> 编译器能够进行一些额外的优化，因为它有更多关于闭包的信息。</p>
<h3 id="懒方法-Lazy-methods"><a href="#懒方法-Lazy-methods" class="headerlink" title="懒方法(Lazy methods)"></a>懒方法(Lazy methods)</h3><p>在使用<code>lazy</code>时，人们经常抱怨它会使代码变得混乱：<code>lazy</code>属性不是属性和方法的简单分离，而是属性和功能混合在一起的灰色区域。对此有一个简单的解决方案：创建方法来将惰性属性从它们所依赖的代码中分离出来。</p>
<p>如果你想使用这种方法，我建议你将创建的单独方法标记为<code>private</code>，这样就不会意外地使用它。类似这样的东西应该会奏效：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
  <span class="token punctuation">}</span>
   <span class="token keyword">lazy</span> <span class="token keyword">var</span> reversedName<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">getReversedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">private</span> <span class="token keyword">func</span> <span class="token function">getReversedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token string">"\(name.uppercased()) backwards is \(String(name.uppercased().characters.reversed()))!"</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>taylor<span class="token punctuation">.</span>reversedName<span class="token punctuation">)</span></code></pre>
<h3 id="懒单例-Lazy-singletons"><a href="#懒单例-Lazy-singletons" class="headerlink" title="懒单例(Lazy singletons)"></a>懒单例(Lazy singletons)</h3><p>单例模式是我不太喜欢的几种常见编程模式之一。如果你不熟悉它们，那么单例就是一个值或对象，它被设计(和编码)为只创建一次，并在整个程序中共享。例如，如果你的应用程序使用一个日志程序，你可以在应用程序运行时创建一个日志程序对象，并让所有其他代码使用该共享实例。</p>
<p>我不太喜欢单例的原因很简单：<strong>它们经常被用作全局变量</strong>。许多人会鼓吹全局变量是不好的，然后很高兴地以几乎相同的方式滥用单例，这是草率的。</p>
<p>话虽如此，使用单例的理由也很充分，而且苹果有时也会使用单例。如果你的对象只能存在一次——比如一个<code>UIApplication</code>的实例——那么单例就有意义了。在 <em>iOS</em>系统中，像<code>UIDevice</code>这样的东西作为单例是有意义的，因为它们只能存在一次。如果你想在使用单例时添加额外的代码，单例也很有用(至少与全局变量相比)。</p>
<p>所以：只要你仔细考虑它们的使用，单例还是有一席之地的。如果你认为单例是完美的选择，我有个好消息：<em>Swift</em> 让单例变得异常容易。</p>
<p>举个实际的例子，我们将创建一个<code>Singer</code>类，它将有一个<code>MusicPlayer</code>类作为属性。这需要是一个单例，因为无论我们的应用程序中有多少歌手，我们都希望他们所有的歌曲通过同一个音乐播放器播放，这样音乐就不会重叠。</p>
<p>下面是<code>MusicPlayer</code>类:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span> <span class="token punctuation">{</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Ready to play songs!"</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>它只在创建消息时打印消息。</p>
<p>下面是基本的<code>Singer</code>类，它在创建消息时只打印消息：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Creating a new singer"</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>现在对于单例：如果我们想给<code>Singer</code>类一个<code>MusicPlayer</code> 单例属性，我们只需要在<code>Singer</code>类中添加一行代码:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">static</span> <span class="token keyword">let</span> musicPlayer <span class="token operator">=</span> <span class="token function">MusicPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>就是这样。<code>static</code>部分意味着这个属性由类共享，而不是由类的实例共享，这意味着你使用<code>Singer.musicPlayer</code>而不是<code>taylor.musicPlayer</code>。<code>let</code>部分当然意味着它是一个常量。</p>
<p>你可能想知道所有这些与惰性属性有什么关系，现在是时候找出答案了——将这段代码放到一个<code>playground</code>中:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span> <span class="token punctuation">{</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Ready to play songs!"</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>
   <span class="token keyword">static</span> <span class="token keyword">let</span> musicPlayer <span class="token operator">=</span> <span class="token function">MusicPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Creating a new singer"</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre>
<p>当它运行时，输出是 <strong>Creating a new singer</strong> — <strong>Ready to play songs!</strong> 消息将不会出现。如果你在<code>playground</code>的结尾再加一行，只有这样，信息才会出现:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token builtin">Singer</span><span class="token punctuation">.</span>musicPlayer</code></pre>
<p>是的：所有 <em>Swift</em> <code>static let</code>单例都是自动懒加载的——它们只有在需要时才会被创建。这很容易做到，但也非常有效。谢谢, <em>Swift</em> 开发团队!</p>
<h3 id="懒序列-Lazy-sequences"><a href="#懒序列-Lazy-sequences" class="headerlink" title="懒序列(Lazy sequences)"></a>懒序列(Lazy sequences)</h3><p>现在你已经了解了惰性属性，我想简要地解释一下惰性序列的用处。这些类似于延迟属性，因为它们将工作延迟到必要的时候，但是它们并不像你稍后将看到的那样高效。</p>
<p>让我们从一个简单的例子开始：斐波那契数列。提醒一下，这是从 <em>0</em> 和 <em>1</em>开始的数字序列，其中后面的每个数字都是前两个数字之和。序列是<code>0 1 1 2 3 5 8 13 21 34 55</code>，以此类推。</p>
<p>我们可以编写一个函数，该函数计算特定点的斐波那契数，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of num<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> num <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> num
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> num <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这是一个递归函数：它调用自己。这是一个 <strong>naïve (幼稚的)</strong> 实现，因为它不会在运行时缓存结果，这这意味着<code>fibonacci(of: num - 1</code>)所做的所有添加操作不会被<code>fibonacci(of: num - 2)</code>重用，即使它可以被重用。但是，这个实现非常适合演示延迟序列的好处(和缺点!)</p>
<p>打开一个 <em>Playground</em>，并添加以下代码:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of num<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> num <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> num
   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> num <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> fibonacciSequence <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>fibonacciSequence<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
<p>它计算斐波那契序列的前 <em>21</em> 个数字，并打印出第 <em>11<em>个数字：</em>55<em>。我让你把它放在</em>Playground*上，因为 *Xcode</em> 会告诉你代码执行的频率，你会看到返回 <em>num</em> 行被调用 <em>28656</em> 次——这是一个巨大的工作量。如果你尝试使用 <em>0…21</em> 作为范围-只是一个数字的提高！你会看到这个数字上升到 <em>46367</em> 次。</p>
<p>就像我说的，这是一个 <strong>naïve (幼稚的)</strong> 的实现,它的伸缩性不是很好。你能想象用 <em>0…199</em> 吗？如果你只需要几个数字，而不是所有的数字怎么办？</p>
<p>这就是延迟序列发挥作用的地方：你给它一个要处理的序列，并告诉它你想要运行什么代码，就像你对普通序列所做的一样，但是现在，当你访问项时，代码是按需执行的。因此，我们可以准备生成斐波那契数列的前 <em>200</em> 个数字，然后使用序列的惰性属性只使用第 <em>20</em> 个值:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lazyFibonacciSequence <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">199</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">lazy</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>lazyFibonacciSequence<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
<blockquote>
<p>注意：你需要使用 <em>Array*，以确保 *Swift</em> 在数组上创建延迟映射，而不是在 <em>0…199</em> 范围内创建延迟映射。</p>
</blockquote>
<p>新代码的运行需要少量的时间，因为所有其他计算都不会运行—不会浪费时间。</p>
<p>然而，尽管延迟序列很聪明，但是它们有一个延迟属性所没有的缺点：它们没有记忆。这是一种常见的优化技术，它存储计算代价高昂的代码的结果，因此不需要再次创建它。这本质上是常规惰性变量提供给我们的：它不仅保证了一个属性在不使用的情况下不会被创建，而且保证了它在一次又一次使用时不会被重复创建。</p>
<p>正如我所说，延迟序列没有记忆，这意味着两次请求相同的数据将需要做两次工作。试试这个:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lazyFibonacciSequence <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">199</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">lazy</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>lazyFibonacciSequence<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>lazyFibonacciSequence<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>lazyFibonacciSequence<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
<p>你将看到代码现在运行所需的时间是以前的三倍。因此，在必要时使用惰性序列，但是请记住，在某些情况下，它们实际上可能会减慢你的速度!</p>
<h2 id="析构-Destructuring"><a href="#析构-Destructuring" class="headerlink" title="析构(Destructuring)"></a>析构(Destructuring)</h2><p>析构(也称为分解)是将数据从元组传输到元组和从元组传输到元组的一种聪明的方法，当你开始理解它时，你将认识到析构和模式匹配是如何紧密地联系在一起的。析构有三种用途：<strong>将元组分成多个值，同时分配给多个对象，以及交换值</strong>。</p>
<p>考虑一下这个元组:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">)</span></code></pre>
<p>如果你想从这三个值中创建三个不同的常量，而不进行析构，你需要这样写:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> one <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token number">0</span>
<span class="token keyword">let</span> two <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token number">1</span>
<span class="token keyword">let</span> three <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token number">2</span></code></pre>
<p>通过析构，你可以这样写:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span>one<span class="token punctuation">,</span> two<span class="token punctuation">,</span> three<span class="token punctuation">)</span> <span class="token operator">=</span> data</code></pre>
<p><em>Swift</em> 将<code>data</code>元组分成三个单独的常量，所有这些都在一行代码中。</p>
<p>当你处理返回元组的函数时，这种技术尤其有用，当你希望返回多个值时，通常使用这种方法。通常需要分割这些返回值，以便你可以根据 <strong>terms(条款)</strong>引用它们，尤其是在元组中没有名称的情况下。例如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> is <span class="token interpolation"><span class="token delimiter variable">\(</span>age<span class="token delimiter variable">)</span></span> years old"</span><span class="token punctuation">)</span></code></pre>
<p>如果你想在析构过程中忽略值，请使用<code>_</code>，如下所示:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"That person is <span class="token interpolation"><span class="token delimiter variable">\(</span>age<span class="token delimiter variable">)</span></span> years old"</span><span class="token punctuation">)</span></code></pre>
<p>你可以使用相同的技术同时分配多个内容，使用固定值或使用函数调用。例如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span>captain<span class="token punctuation">,</span> chef<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Janeway"</span><span class="token punctuation">,</span> <span class="token string">"Neelix"</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> <span class="token punctuation">(</span>engineer<span class="token punctuation">,</span> pilot<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">getEngineer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getPilot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<p>这在处理密切相关的值时尤其有用，比如矩形的坐标，并且可以帮助提高可读性。</p>
<p>最后，元组析构适合于交换值。现在，我要诚实地说:这种技巧在面试之外很少有用，即使在面试中，它也是一个相当糟糕的选择。然而，我想向你们展示它，因为我认为它展示了 <em>Swift</em> 是多么优雅。</p>
<p>那么，这里开始：给定两个整数 <em>A</em> 和 <em>B</em> ，如何在不使用第三个变量的情况下交换它们? 想一想，甚至可以在 <em>Playground</em> 上尝试一些代码。下面是用大多数语言解决这个问题的方法:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">20</span>
a<span class="token operator">=</span>a<span class="token operator">+</span>b
b<span class="token operator">=</span>a<span class="token operator">-</span>b 
a<span class="token operator">=</span>a<span class="token operator">-</span>b
<span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span></code></pre>
<p>在Swift中，多亏了析构，你可以把它写在一行:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span></code></pre>
<p>我认为她优雅、高效，而且相当漂亮。如果你在面试中被问到这个问题，你应该能够把它答好!</p>
<h2 id="带标签的语句-Labeled-statements"><a href="#带标签的语句-Labeled-statements" class="headerlink" title="带标签的语句(Labeled statements)"></a>带标签的语句(Labeled statements)</h2><p>标签已经使用了很长时间，但当开发人员开始对<code>goto</code>不满时，它们在很大程度上就不受欢迎了。<em>Swift</em> 把它们带回来，但没有<code>goto</code>：相反，它们与循环一起使用，让你更容易退出它们。</p>
<p>这里有一些代码可以创建一个字符串网格，并标记其中一个带有 <strong>x</strong> 的正方形，其中有一些宝藏 - 这是一个硬编码的位置，但在真实的游戏中，你显然会将其随机化。然后代码有两个循环试图找到宝藏，一个循环嵌套在另一个循环中：循环遍历板中的所有行，然后循环遍历每一行中的每一列。</p>
<p>这是代码：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> board <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span>
board<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"x"</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span>rowIndex<span class="token punctuation">,</span> cols<span class="token punctuation">)</span> <span class="token keyword">in</span> board<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>colIndex<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token keyword">in</span> cols<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> col <span class="token operator">==</span> <span class="token string">"x"</span> <span class="token punctuation">{</span>
         <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found the treasure at row <span class="token interpolation"><span class="token delimiter variable">\(</span>rowIndex<span class="token delimiter variable">)</span></span> col <span class="token interpolation"><span class="token delimiter variable">\(</span>colIndex<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span></code></pre>
<p>考虑到宝藏可以出现在面板上出现一次，这段代码是相当浪费的：即使在搜索的早期就发现了宝藏，它也会继续查找。如果你认为是时候部署 <code>break</code>了，那么你是对的，至少在一定程度上是对的。它可能是这样的:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token punctuation">(</span>rowIndex<span class="token punctuation">,</span> cols<span class="token punctuation">)</span> <span class="token keyword">in</span> board<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>colIndex<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token keyword">in</span> cols<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> col <span class="token operator">==</span> <span class="token string">"x"</span> <span class="token punctuation">{</span>
        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found the treasure at row <span class="token interpolation"><span class="token delimiter variable">\(</span>rowIndex<span class="token delimiter variable">)</span></span> col <span class="token interpolation"><span class="token delimiter variable">\(</span>colIndex<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span>
         <span class="token keyword">break</span>
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>但是，<code>break</code>只退出一个循环级别，因此它将退出<code>for(colIndex,colo)</code>循环，然后继续运行<code>for(rowIndex，cols)</code>循环。是的，它浪费的时间更少，但它仍在浪费一些。你可以添加一个布尔变量，在找到宝藏时将其设置为<code>true</code>，然后你可以使用它来打破外部循环，但 <em>Swift</em> 有一个更好的解决方案：<strong>带标签的语句</strong>。</p>
<p>带标签的语句允许你为任何循环命名，这允许你在使用<code>break</code>或<code>continue</code>时引用特定循环。要创建标签，只需在任何循环之前写一个名称然后写一个冒号。然后，你可以使用<code>break yourLabelName</code>或<code>continue yourLabelName</code>直接引用它。</p>
<p>因此，编写该代码的最不浪费的方式是这样的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> board <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span>
board<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"x"</span>
rowLoop<span class="token punctuation">:</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>rowIndex<span class="token punctuation">,</span> cols<span class="token punctuation">)</span> <span class="token keyword">in</span> board<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">for</span> <span class="token punctuation">(</span>colIndex<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token keyword">in</span> cols<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> col <span class="token operator">==</span> <span class="token string">"x"</span> <span class="token punctuation">{</span>
         <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found the treasure at row <span class="token interpolation"><span class="token delimiter variable">\(</span>rowIndex<span class="token delimiter variable">)</span></span> col <span class="token interpolation"><span class="token delimiter variable">\(</span>colIndex<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span>
         <span class="token keyword">break</span> rowLoop
     <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>它会立即跳出两个循环，并在<code>for(rowIndex, cols)</code>循环结束后继续执行——非常好。</p>
<p>标记循环是聪明的，但是 <em>Swift</em> 更进一步：它允许你标记 <code>if</code> 语句，然后像标记循环一样从中中断。并且想要立即摆脱困境时，这是非常有用的，如果没有这些条件，你可能会得到一个由越来越多的缩进条件组成的金字塔。</p>
<p>下面是一个很好的例子，你可以看到它的实际应用：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token function">userRequestedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token function">documentSaved</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token function">userAuthenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
         <span class="token keyword">if</span> <span class="token function">connectToNetwork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token function">uploadDocument</span><span class="token punctuation">(</span><span class="token string">"resignation.doc"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
               <span class="token keyword">if</span> <span class="token function">printDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Printed successfully!"</span><span class="token punctuation">)</span>
               <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
         <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>这段代码要经过一系列检查才能允许用户打印文档：不要尝试运行它，因为那些函数不是真的!</p>
<p>如果所有条件都为<code>true</code>，那么你将看到<strong>打印成功!</strong></p>
<p>标记语句允许你为<code>if</code>语句创建早期返回。它们正常运行，但在你认为有必要的任何时候，你都可以退出任何条件语句。例如，我们可以将上面的金字塔重写为:</p>
<pre class=" language-swift"><code class="language-swift">printing<span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token function">userRequestedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">documentSaved</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">userAuthenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">connectToNetwork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">uploadDocument</span><span class="token punctuation">(</span><span class="token string">"work.doc"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">printDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Printed successfully!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>这样占用的行数更少，对读取代码的人的缩进也更少，而且很快就能找到满意的解决方案。</p>
<p>如果你愿意，你甚至可以使用<code>guard</code>来使你的意图更加清晰，就像这样:</p>
<pre class=" language-swift"><code class="language-swift">printing<span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token function">userRequestedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token keyword">guard</span> <span class="token function">documentSaved</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token keyword">guard</span> <span class="token function">userAuthenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token keyword">guard</span> <span class="token function">connectToNetwork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token keyword">guard</span> <span class="token function">uploadDocument</span><span class="token punctuation">(</span><span class="token string">"work.doc"</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token keyword">guard</span> <span class="token function">printDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Printed successfully!"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>为了可读性，我更喜欢测试正面条件，而不是反面条件。也就是说，我宁愿测试<code>if documentsaved()</code>而不是<code>if !documentsaved()</code>是因为它更容易理解，而<code>guard</code>就是这样做的。</p>
<h2 id="嵌套函数、类和结构-Nested-functions-classes-and-structs"><a href="#嵌套函数、类和结构-Nested-functions-classes-and-structs" class="headerlink" title="嵌套函数、类和结构(Nested functions, classes and structs)"></a>嵌套函数、类和结构(Nested functions, classes and structs)</h2><p><em>Swift</em> 允许你将一种数据类型嵌套到另一种数据类型中，例如结构体中的结构体，类中的枚举或函数中的函数。这是最常用来帮助你按照逻辑行为在心理上将事物分组在一起的方法，但有时会附加访问语义，以防止不正确地使用嵌套数据类型。</p>
<p>让我们首先处理简单的情况：使用嵌套类型进行逻辑分组。考虑下面的代码，它定义了一个名为<code>London</code>的枚举:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">London</span> <span class="token punctuation">{</span>
   <span class="token keyword">static</span> <span class="token keyword">let</span> coordinates <span class="token operator">=</span> <span class="token punctuation">(</span>lat<span class="token punctuation">:</span> <span class="token number">51.507222</span><span class="token punctuation">,</span> long<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">0.1275</span><span class="token punctuation">)</span>
   <span class="token keyword">enum</span> <span class="token builtin">SubwayLines</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> bakerloo<span class="token punctuation">,</span> central<span class="token punctuation">,</span> circle<span class="token punctuation">,</span> district<span class="token punctuation">,</span> elizabeth<span class="token punctuation">,</span> hammersmithCity<span class="token punctuation">,</span> jubilee<span class="token punctuation">,</span> metropolitan<span class="token punctuation">,</span> northern<span class="token punctuation">,</span> piccadilly<span class="token punctuation">,</span> victoria<span class="token punctuation">,</span> waterlooCity
   <span class="token punctuation">}</span>
   <span class="token keyword">enum</span> <span class="token builtin">Places</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> buckinghamPalace<span class="token punctuation">,</span> cityHall<span class="token punctuation">,</span> oldBailey<span class="token punctuation">,</span> piccadilly<span class="token punctuation">,</span> stPaulsCathedral
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>该枚举有一个称为<code>coordinates</code>(坐标)的常量，然后是两个嵌套枚举：<strong><em>SubwayLines(地铁线路)</em></strong> 和 <strong><em>Places(位置)</em></strong>。但是，值得注意的是，它没有自己的<code>case</code> ——它只是被用作其他数据的包装器。</p>
<p>这样做有两个直接的好处：首先，任何具有代码完成功能的 <strong>IDE</strong> 都可以通过在键入时列出可能的选项(例如<code>London.Places.cityHall</code>)来快速、方便地深入到特定的项。其次，因为你实际上是在创建名称空间常量，所以你可以使用<code>Piccadilly</code>这样的合理名称，而不必担心你指的是地铁线路还是那个地方，或者你指的是 <strong><em>London Piccadilly</em></strong> 还是 <strong><em>Manchester Piccadilly</em></strong>。</p>
<p>如果你进一步扩展此技术，你将认识到你可以将其用于故事板 <em>ID*、表视图单元 *ID</em> 、图像名称，以及更有效地处理在苹果平台上非常流行的字符形式的资源类型。例如：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> R <span class="token punctuation">{</span>
   <span class="token keyword">enum</span> <span class="token builtin">Storyboards</span><span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> main<span class="token punctuation">,</span> detail<span class="token punctuation">,</span> upgrade<span class="token punctuation">,</span> share<span class="token punctuation">,</span> help
   <span class="token punctuation">}</span>
   <span class="token keyword">enum</span> <span class="token builtin">Images</span><span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> welcome<span class="token punctuation">,</span> home<span class="token punctuation">,</span> about<span class="token punctuation">,</span> button
  <span class="token punctuation">}</span> 
<span class="token punctuation">}</span></code></pre>
<p>如果你能理解为什么我用 <strong><em>R</em></strong> 来表示它，那就更好了。要使该技术适用于图像，只需将图像命名为与枚举<code>case</code>相同的名称，并在末尾加上 <em>.png</em> ，例如 <em>about.png</em>。</p>
<p>嵌套类型也适用于其他数据类型，例如，你可以有一个结构体，其中包含它自己的枚举:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Cat</span> <span class="token punctuation">{</span>
   <span class="token keyword">enum</span> <span class="token builtin">Breed</span> <span class="token punctuation">{</span>
      <span class="token keyword">case</span> britishShortHair<span class="token punctuation">,</span> burmese<span class="token punctuation">,</span> persian<span class="token punctuation">,</span> ragdoll<span class="token punctuation">,</span> russianBlue<span class="token punctuation">,</span> scottishFold<span class="token punctuation">,</span> siamese
   <span class="token punctuation">}</span>
   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>
   <span class="token keyword">var</span> breed<span class="token punctuation">:</span> <span class="token builtin">Breed</span>
<span class="token punctuation">}</span></code></pre>
<p>你也可以把结构体放在结构体中，当它们一起使用时，例如:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Deck</span> <span class="token punctuation">{</span>
   <span class="token keyword">struct</span> <span class="token builtin">Card</span> <span class="token punctuation">{</span>
      <span class="token keyword">enum</span> <span class="token builtin">Suit</span> <span class="token punctuation">{</span>
         <span class="token keyword">case</span> hearts<span class="token punctuation">,</span> diamonds<span class="token punctuation">,</span> clubs<span class="token punctuation">,</span> spades
      <span class="token punctuation">}</span>
      <span class="token keyword">var</span> rank<span class="token punctuation">:</span> <span class="token builtin">Int</span>
      <span class="token keyword">var</span> suit<span class="token punctuation">:</span> <span class="token builtin">Suit</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">var</span> cards <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Card</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>正如你在最后一个示例中所看到的，你可以根据需要多次嵌套，结构体嵌套结构体再嵌套枚举是完全合法的。</p>
<h3 id="嵌套语义-Nesting-with-semantics"><a href="#嵌套语义-Nesting-with-semantics" class="headerlink" title="嵌套语义(Nesting with semantics)"></a>嵌套语义(Nesting with semantics)</h3><p>逻辑分组的嵌套不会阻止你引用任何嵌套类型，但是如果嵌套太多，就会有点麻烦:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> home <span class="token operator">=</span> R<span class="token punctuation">.</span><span class="token builtin">Images</span><span class="token punctuation">.</span>home
<span class="token keyword">let</span> burmese <span class="token operator">=</span> <span class="token builtin">Cat</span><span class="token punctuation">.</span><span class="token builtin">Breed</span><span class="token punctuation">.</span>burmese
<span class="token keyword">let</span> hearts <span class="token operator">=</span> <span class="token builtin">Deck</span><span class="token punctuation">.</span><span class="token builtin">Card</span><span class="token punctuation">.</span><span class="token builtin">Suit</span><span class="token punctuation">.</span>hearts</code></pre>
<p>但是，<em>Swift</em> 允许你为嵌套类型分配访问控制修饰符，以控制它们的使用方式。当嵌套类型被设计为专门在其父级内部工作时，这很有用：如果<code>Card</code>结构体只能由<code>Deck</code>体结构使用，那么你需要访问控制。</p>
<blockquote>
<p>警告：如果属性使用私有类型，则属性本身必须是私有的。为了演示，让我们再次看一下<code>Deck</code>示例：</p>
</blockquote>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Deck</span> <span class="token punctuation">{</span>
   <span class="token keyword">struct</span> <span class="token builtin">Card</span> <span class="token punctuation">{</span>
      <span class="token keyword">enum</span> <span class="token builtin">Suit</span> <span class="token punctuation">{</span>
         <span class="token keyword">case</span> hearts<span class="token punctuation">,</span> diamonds<span class="token punctuation">,</span> clubs<span class="token punctuation">,</span> spades
      <span class="token punctuation">}</span>
      <span class="token keyword">var</span> rank<span class="token punctuation">:</span> <span class="token builtin">Int</span>
      <span class="token keyword">var</span> suit<span class="token punctuation">:</span> <span class="token builtin">Suit</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">var</span> cards <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Card</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>如果我们希望<code>Suit</code>枚举是私有的，以便只有<code>Card</code>实例可以使用它，我们需要使用<code>private enum Suit</code>。然而，这具有连锁效应，要求<code>Card</code>的<code>suit</code>属性也是私有的，否则它将在<code>Suit</code>枚举不可用的地方进入。所以，更新之后的代码是这样的：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Deck</span> <span class="token punctuation">{</span>
   <span class="token keyword">struct</span> <span class="token builtin">Card</span> <span class="token punctuation">{</span>
      <span class="token keyword">private</span> <span class="token keyword">enum</span> <span class="token builtin">Suit</span> <span class="token punctuation">{</span>
         <span class="token keyword">case</span> hearts<span class="token punctuation">,</span> diamonds<span class="token punctuation">,</span> clubs<span class="token punctuation">,</span> spades
      <span class="token punctuation">}</span>
      <span class="token keyword">var</span> rank<span class="token punctuation">:</span> <span class="token builtin">Int</span>
      <span class="token keyword">private</span> <span class="token keyword">var</span> suit<span class="token punctuation">:</span> <span class="token builtin">Suit</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">var</span> cards <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Card</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="嵌套函数-Nested-functions"><a href="#嵌套函数-Nested-functions" class="headerlink" title="嵌套函数(Nested functions)"></a>嵌套函数(Nested functions)</h3><p>嵌套函数是嵌套类型访问控制的一个有趣的小例子，因为除非你您另有指定，否则它们将自动限制在其封闭函数中。<em>Swift</em> 将嵌套函数实现为命名闭包，这意味着它们将自动从其封闭函数中捕获值。</p>
<p>为了演示嵌套函数，我将创建一个函数，它使用三种距离计算技术之一计算两点之间的距离: 欧几里德(使用毕达哥拉斯定理)、欧几里德平方(使用毕达哥拉斯定理，但出于性能原因避免调用<code>sqrt()</code>和曼哈顿距离。如果你不熟悉这些术语，“欧几里得距离”基本上是在两点之间画一条直线，“曼哈顿距离”使用直线几何来计算两个笛卡尔坐标的绝对差。</p>
<p>首先，我们要使用的类型的代码:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span>

<span class="token keyword">struct</span> <span class="token builtin">Point</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token builtin">Double</span>
   <span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token builtin">Double</span>
<span class="token punctuation">}</span>
<span class="token keyword">enum</span> <span class="token builtin">DistanceTechnique</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> euclidean
   <span class="token keyword">case</span> euclideanSquared
   <span class="token keyword">case</span> manhattan
<span class="token punctuation">}</span></code></pre>
<p>我创建了自己的<code>Point</code>类，以避免依赖于<code>CGPoint</code>和 <strong>Core Graphics</strong>。我们将创建三个函数，每个函数都嵌套在一个父函数中。本章的重点不是解释距离计算，所以让我们快速地把它们排除在外：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> deltaX <span class="token operator">=</span> start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x
   <span class="token keyword">let</span> deltaY <span class="token operator">=</span> start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y
   <span class="token keyword">return</span> deltaX <span class="token operator">*</span> deltaX <span class="token operator">+</span> deltaY <span class="token operator">*</span> deltaY
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
   <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>第一个函数<code>calculateEuclideanDistanceSquared()</code>使用毕达哥拉斯定理（勾股定理）计算两点之间的直线距离。如果你上学已经有一段时间了，这个函数认为两点之间的 <em>X</em> 和 <em>Y</em> 是三角形的两条边，然后计算出三角形的斜边就是两点之间的距离。</p>
<p>第二个函数<code>calculateEuclideanDistance()</code>建立在<code>calculateEuclideanDistanceSquared()</code>函数的基础上，通过计算结果的平方根来给出真实距离。如果需要非常频繁地计算距离，例如每次用户的手指移动时，调用<code>sqrt()</code>可能会影响性能，这就是<code>calculateEuclideanDistanceSquared()</code>函数存在的原因。</p>
<p>最后，第三个函数是<code>calculateManhattanDistance()</code>，它计算两个点的 <em>X</em> 和 <em>Y</em> 坐标之间的绝对距离之和，就好像你坐在一辆出租车上围绕城市中一个正方形街区行驶。</p>
<p>有了这三个嵌套函数，现在只需根据所要求的技术选择正确的选项:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> technique <span class="token punctuation">{</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">:</span>
   <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>euclideanSquared<span class="token punctuation">:</span>
   <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span>
<span class="token keyword">case</span> <span class="token punctuation">.</span>manhattan<span class="token punctuation">:</span>
   <span class="token keyword">return</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
<p>就是这样！以下是完整的代码:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span>
<span class="token keyword">struct</span> <span class="token builtin">Point</span> <span class="token punctuation">{</span>
   <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token builtin">Double</span>
   <span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token builtin">Double</span>
<span class="token punctuation">}</span>
<span class="token keyword">enum</span> <span class="token builtin">DistanceTechnique</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> euclidean
   <span class="token keyword">case</span> euclideanSquared
   <span class="token keyword">case</span> manhattan
<span class="token punctuation">}</span>
<span class="token keyword">func</span> <span class="token function">calculateDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> technique<span class="token punctuation">:</span> <span class="token builtin">DistanceTechnique</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> deltaX <span class="token operator">=</span> start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x
      <span class="token keyword">let</span> deltaY <span class="token operator">=</span> start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y
      <span class="token keyword">return</span> deltaX <span class="token operator">*</span> deltaX <span class="token operator">+</span> deltaY <span class="token operator">*</span> deltaY
   <span class="token punctuation">}</span>
   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">func</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">switch</span> technique <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span>
   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclideanSquared<span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span>
   <span class="token keyword">case</span> <span class="token punctuation">.</span>manhattan<span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token builtin">distance</span> <span class="token operator">=</span> <span class="token function">calculateDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> technique<span class="token punctuation">:</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">)</span></code></pre>
<p>现在，所有这些代码都是完全有效的，但它也比需要的更冗长。提醒一下，函数只是命名闭包，因此它们从其封闭函数中捕获任何值。</p>
<p>在这个上下文中，这意味着我们不需要让这三个嵌套函数接受任何参数，因为它们与封闭函数接受的参数相同——如果我们删除它们，它们就会被自动捕获。这有助于使我们的意图更清楚：这些嵌套函数只是在相同数据上操作的不同方式，而不是使用特定的值。</p>
<p>下面是<code>calculateDistance()</code>函数重写之后的代码，这样它就可以从嵌套函数中删除参数，而是依赖于捕获：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">calculateDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> technique<span class="token punctuation">:</span> <span class="token builtin">DistanceTechnique</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> deltaX <span class="token operator">=</span> start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x
      <span class="token keyword">let</span> deltaY <span class="token operator">=</span> start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y
      <span class="token keyword">return</span> deltaX <span class="token operator">*</span> deltaX <span class="token operator">+</span> deltaY <span class="token operator">*</span> deltaY
   <span class="token punctuation">}</span>
   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">func</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">switch</span> technique <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclideanSquared<span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">case</span> <span class="token punctuation">.</span>manhattan<span class="token punctuation">:</span>
      <span class="token keyword">return</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<h3 id="返回嵌套函数-Returning-nested-functions"><a href="#返回嵌套函数-Returning-nested-functions" class="headerlink" title="返回嵌套函数(Returning nested functions)"></a>返回嵌套函数(Returning nested functions)</h3><p>嵌套函数被自动限制在它们的封闭函数中，除非你另有指定，即如果你返回它们。记住，函数在 <em>Swift</em> 中属于一等公民 <em>(first-class data types)</em>，因此你可以使用一个函数根据特定条件返回另一个函数。在我们的例子中，我们可以将<code>calculatedDistance()</code>函数转换为<code>createdDistanceAlgorithm()</code>，它只接受一个技术参数，并根据请求的技术返回其三个嵌套函数之一。</p>
<p>我知道这是显而易见的，值得重复的是，当你使用这种方法时，嵌套函数将不再是私有的——它将作为返回值返回给任何人使用。</p>
<p>下面是重写<code>calculateDistance()</code>的代码，使它返回以下三个函数之一：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">createDistanceAlgorithm</span><span class="token punctuation">(</span>technique<span class="token punctuation">:</span> <span class="token builtin">DistanceTechnique</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token builtin">Point</span><span class="token punctuation">,</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> deltaX <span class="token operator">=</span> start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x
      <span class="token keyword">let</span> deltaY <span class="token operator">=</span> start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y
      <span class="token keyword">return</span> deltaX <span class="token operator">*</span> deltaX <span class="token operator">+</span> deltaY <span class="token operator">*</span> deltaY
   <span class="token punctuation">}</span>
   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">func</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y<span class="token punctuation">)</span>
   <span class="token punctuation">}</span>
   <span class="token keyword">switch</span> technique <span class="token punctuation">{</span>
   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">:</span>
      <span class="token keyword">return</span> calculateEuclideanDistance
   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclideanSquared<span class="token punctuation">:</span>
      <span class="token keyword">return</span> calculateEuclideanDistanceSquared
   <span class="token keyword">case</span> <span class="token punctuation">.</span>manhattan<span class="token punctuation">:</span>
      <span class="token keyword">return</span> calculateManhattanDistance
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
<p>注意，这三个函数现在都需要接受参数，因为稍后将像这样调用它们：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> distanceAlgorithm <span class="token operator">=</span> <span class="token function">createDistanceAlgorithm</span><span class="token punctuation">(</span>technique<span class="token punctuation">:</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">)</span>
<span class="token keyword">let</span> <span class="token builtin">distance</span> <span class="token operator">=</span> <span class="token function">distanceAlgorithm</span><span class="token punctuation">(</span><span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
<h2 id="文档标记-Documentation-markup"><a href="#文档标记-Documentation-markup" class="headerlink" title="文档标记(Documentation markup)"></a>文档标记(Documentation markup)</h2><p><em>Swift</em> 有特殊的语法，允许你将 <em>Markdown</em> 格式的文本嵌入到源代码中，源代码由 <em>Xcode</em> 解析并显示在 <em>Quick Help</em> 系统面板中——在编码时按 <em>Alt+Cmd+2</em> 将其显示在 <em>Xcode</em> 窗口的右侧。使用特殊格式的代码注释，你可以记录应该传入哪些参数、返回值将包含哪些内容、可以抛出的任何错误等等。</p>
<p>此文档与添加到特定代码中的常规内联注释不同。这些特殊的注释放在函数和类之前，用于在 <em>Quick Help</em> 和代码提示弹出窗口中显示信息，并进行了格式化，以便人类和 <em>Xcode</em> 都能阅读它们。</p>
<p>让我们先把简单的事情解决掉：除非你使用后面介绍的特殊关键字之一，否则你在 <em>Markdown</em> 注释中编写的所有内容都将在 <em>Quick Help</em> 面板中显示为描述文本。如果你刚开始输入文本，你所写的内容将在代码提示弹出窗口中作为简要描述使用。<em>Xcode</em> 通常可以在自动补全的空间中填入 <em>20-30</em> 个单词，但这对于实际使用来说太长了——目标是大约 <em>10</em> 个单词的简洁描述。</p>
<p><em>Markdown<em>注释以/\</em>*开头，以\</em>/结尾，像这样：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/**
Call this function to grok some globs.
*/</span>
<span class="token keyword">func</span> <span class="token function">myGreatFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// do stuff</span>
<span class="token punctuation">}</span></code></pre>
<p>在本文中，你可以使用一系列 <em>Markdown</em> 格式，如下所示：</p>
<pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/**
  将文本放在`反引号`中以标记代码; 在你的键盘上这通常与波浪号〜共享一个键。
  * 你可以用星号和空格开头来写项目描述。
     * 缩进星号来创建子列表
  1. 你可以以1.开始编写编号列表
  1. 后续条目也可以以1.开始，Xcode会自动重新编号。
   如果你想写一个链接，[把你的文本放在中括号里](链接放在小括号里)
  # 标题以#号开始
  ## 副标题以##开头
  ### 子副标题以###开头，是你会遇到的最常见的标题样式
  在文本前后写一个*星号*，使它成为斜体
  在文本前后写**两个星号**，使它加粗
*/</span></code></pre>
<h3 id="文档关键字-Documentation-keywords"><a href="#文档关键字-Documentation-keywords" class="headerlink" title="文档关键字(Documentation keywords)"></a>文档关键字(Documentation keywords)</h3><p>除了使用文本来描述函数外，<em>Swift</em> 还允许你添加在 <em>Quick Help</em> 窗格中显示的特殊关键字。有很多这样的工具，但是大多数都只显示一个标题和一些文本。我通常推荐六种有用的方法，你可以在几分钟内学会它们。</p>
<p>首先: <code>Returns</code>关键字允许你指定调用者在函数成功运行时期望返回的值。请记住代码自动补全提示已经显示了返回值的数据类型，所以这个字段用于描述数据的实际含义——我们知道它是一个字符串，但是它将如何格式化?</p>
<pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Returns</span><span class="token punctuation">:</span> A string containing a date formatted <span class="token keyword">as</span> <span class="token constant">RFC</span><span class="token operator">-</span><span class="token number">822</span></code></pre>
<p>接下来是<code>Parameter</code>关键字。这允许你指定参数的名称并描述它包含的内容。同样，代码自动补全提示会显示必须使用的数据类型，所以这是你提供一些细节的机会：*”The name of a Taylor Swift album”*。你可以包含尽可能多的参数行。</p>
<pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Parameter</span> album<span class="token punctuation">:</span> <span class="token builtin">The</span> name of a <span class="token builtin">Taylor</span> <span class="token builtin">Swift</span> album
<span class="token operator">-</span> <span class="token builtin">Parameter</span> track<span class="token punctuation">:</span> <span class="token builtin">The</span> track number to load</code></pre>
<p>第三个是<code>Throws</code>关键字，它允许你指定一个用逗号分隔的错误类型列表，该函数可以抛出:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Throws</span><span class="token punctuation">:</span> <span class="token builtin">LoadError</span><span class="token punctuation">.</span>networkFailed<span class="token punctuation">,</span> <span class="token builtin">LoadError</span><span class="token punctuation">.</span>writeFailed</code></pre>
<p>第四个是<code>Precondition</code>，它应该用于在调用函数之前描述程序的正确状态。如果使用纯函数，这个先决条件应该只依赖于传递给函数的参数，例如<code>inputArray.count &gt; 0</code>:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Precondition</span><span class="token punctuation">:</span> inputArray<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">></span> <span class="token number">0</span></code></pre>
<p>第五是<code>Complexity</code>，它在 <em>Swift</em> 标准库中很流行。在 <em>Quick Help</em> 中，这不是特别格式化的，但是对于使用代码的其他人来说，这是有用的信息。这应该用大O符号来写，例如:</p>
<pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Complexity</span><span class="token punctuation">:</span> <span class="token function">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre>
<p>最后是<code>Authors</code>关键字，一开始听起来很有用，但我表示怀疑。可以想象，这用于将函数作者的名称写入 <em>Quick Help</em> 面板，当你需要确定应该向谁抱怨或表扬他们的工作时，这将非常有用。但是由于 <em>Xcode</em> 将<code>Authors</code>放在<code>Returns</code>、<code>Throws</code>和<code>Parameter</code>之前，添加一个认证信息只会把重要的字段往下推。尝试一下，看看你是怎么想的，但是请记住，文档首先是有用的。</p>
<pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Authors</span><span class="token punctuation">:</span> <span class="token builtin">Paul</span> <span class="token builtin">Hudson</span></code></pre>
<p>如果你在文档关键字之间包含更多的自由格式文本，那么它将在 <em>Quick Help</em> 中被正确地放置。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            

    <div class="reprint" id="reprint-statement">
        <p class="reprint-tip">
            <i class="fa fa-exclamation-triangle"></i>&nbsp;&nbsp;
            <span>转载规则</span>
        </p>
        
            <span xmlns:dct="http://purl.org/dc/terms/" href="http://purl.org/dc/dcmitype/Text"
                  property="dct:title" rel="dct:type">
                    《第一章 语法（Syntax）》
                </span> 由
            <a xmlns:cc="http://creativecommons.org/ns#" href="/2019/09/03/pro-swift-yi-wen/chapter1-syntax/" property="cc:attributionName"
               rel="cc:attributionURL">
                影痕
            </a> 采用
            <a rel="license" href="https://creativecommons.org/licenses/by/4.0/deed.zh">
                知识共享署名 4.0 国际许可协议
            </a>进行许可。
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>


        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: 'f3f4b0e75a31c33690a1',
        clientSecret: 'c7a167d236ca9107a6728fcc08468b5237eabe4f',
        repo: 'BlogComments',
        owner: 'LucioLee',
        admin: ["LucioLee"],
        id: '2019-09-03T19-43-22',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fa fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/09/04/pro-swift-yi-wen/chapter2-types/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/0.jpg" class="responsive-img" alt="第二章 类型（Types）">
                        
                        <span class="card-title">第二章 类型（Types）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            高效初始化器、枚举、数组、集合、元组、范型
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2019-09-04
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Pro-Swift/" class="post-category" target="_blank">
                                    Pro Swift
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Swift/" target="_blank">
                        <span class="chip bg-color">Swift</span>
                    </a>
                    
                    <a href="/tags/Pro-Swift/" target="_blank">
                        <span class="chip bg-color">Pro Swift</span>
                    </a>
                    
                    <a href="/tags/范型/" target="_blank">
                        <span class="chip bg-color">范型</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="fa fa-dot-circle-o"></i>
            </div>
            <div class="card">
                <a href="/2019/09/03/pro-swift-yi-wen/chapter1-syntax/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="第一章 语法（Syntax）">
                        
                        <span class="card-title">第一章 语法（Syntax）</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            从模式匹配、空值合并、Guard、懒加载、标记语句和嵌套类型等方面，介绍Swift语言中好用却又容易被开发者忽视的语法特性。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2019-09-03
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Pro-Swift/" class="post-category" target="_blank">
                                    Pro Swift
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Swift/" target="_blank">
                        <span class="chip bg-color">Swift</span>
                    </a>
                    
                    <a href="/tags/Pro-Swift/" target="_blank">
                        <span class="chip bg-color">Pro Swift</span>
                    </a>
                    
                    <a href="/tags/模式匹配/" target="_blank">
                        <span class="chip bg-color">模式匹配</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('1')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;

        newdiv.innerHTML += '<br />'
            + '来源: Li&apos;s Note<br />'
            + '作者: 影痕<br />'
            + '链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归@影痕所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="fa fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fa fa-list"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            // headingsOffset: -205,
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).slideUp(500);
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).slideDown(500);
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>
    

</main>


<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站版权归&copy;<a href="https://luciolee.github.io/" target="_blank">影痕</a>所有.

            
                &nbsp;<i class="fa fa-area-chart"></i>&nbsp;站点总字数:&nbsp;
                <span class="white-color">55.4k</span>
            

            
			
                <br>
                
                <span id="busuanzi_container_site_pv">
                    <i class="fa fa-heart-o"></i>
                    本站总访问量 <span id="busuanzi_value_site_pv" class="white-color"></span>
                </span>
                
                
                <span id="busuanzi_container_site_uv">
                    <i class="fa fa-users"></i>
                    次,&nbsp;访客数 <span id="busuanzi_value_site_uv" class="white-color"></span> 人.
                </span>
                
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/LucioLee/" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fa fa-github"></i>
    </a>



    <a href="mailto:lixinxin990467229@gmail.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fa fa-envelope-open"></i>
    </a>



    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=990467229" class="tooltipped" data-tooltip="QQ联系我: 990467229" data-position="top" data-delay="50">
        <i class="fa fa-qq"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fa fa-rss"></i>
    </a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fa fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>

<!-- Global site tag (gtag.js) - Google Analytics -->




    <script async src="/libs/others/busuanzi.pure.mini.js"></script>


</body>
</html>