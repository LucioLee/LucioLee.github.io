<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>第一章 Hello, RxSwift!</title>
      <link href="/2019/09/30/rxswift-yi-wen/chapter1-hello-rxswift/"/>
      <url>/2019/09/30/rxswift-yi-wen/chapter1-hello-rxswift/</url>
      
        <content type="html"><![CDATA[<p>这本书的目的是向读者介绍 <em>RxSwift</em> 库，以及如何使用 <em>Swift</em> 编写响应式 <em>iOS</em> 应用程序。</p><p>“但什么是 <em>RxSwift</em> 呢？” 这里有一个很好的定义：</p><blockquote><p><em>RxSwift</em> 是一个库，通过使用可观察序列和函数式操作符来组合异步和基于事件的代码，允许通过调度程序进行参数化执行。</p></blockquote><p>听起来复杂？ 如果是这样，也不用担心。编写响应式程序，理解程序背后的许多概念，浏览大量相关的、常用的术语，这些都是令人生畏的——尤其是当你试图一次把所有内容都看完，或者当你还没有以一种结构化的方式被介绍给它的时候。</p><p>这就是本书的目标：通过解释如何使用每一个 <em>API</em> ，并介绍它们在 <em>iOS</em> 应用程序中的实际应用，逐步向你介绍各种 <em>RxSwift API</em> 和 <em>Rx</em> 概念。</p><p>你将从 <em>RxSwift</em> 的基本特性开始，然后逐步学习中级和高级主题。在学习过程中，花时间广泛地练习新概念，这将使你在本书的最后更容易掌握 <em>RxSwift</em> 。<em>Rx</em> 是一个太广泛的主题，不能完全涵盖在一本书里；相反，我们的目标是让你对它有一个坚实的了解，这样你就可以继续发展自己的 <em>Rx</em> 技能。</p><p>我们还没有完全确定什么是 <em>RxSwift</em> ，是吗？ 让我们先从一个简单易懂的定义开始，然后在本章稍后的内容中讨论响应式编程时，再进一步讨论一个更好、更有表现力的定义。</p><blockquote><p><em>RxSwift</em> 本质上简化了异步程序的开发，它允许代码对新数据做出反应，并以顺序的、隔离的方式对其进行处理。</p></blockquote><p>作为 <em>iOS</em> 应用程序开发人员，与本章前面阅读的第一个定义相比，这应该更清楚，也更能告诉你什么是 <em>RxSwift</em>。</p><p>即使你仍然不清楚细节，也应该清楚 <em>RxSwift</em> 帮助你编写异步代码。而且你知道开发好的、确定性的、异步的代码是很困难的，所以任何帮助都是非常受欢迎的!</p><h2 id="异步编程介绍（Introduction-to-asynchronous-programming）"><a href="#异步编程介绍（Introduction-to-asynchronous-programming）" class="headerlink" title="异步编程介绍（Introduction to asynchronous programming）"></a>异步编程介绍（Introduction to asynchronous programming）</h2><p>如果你试图用一种简单的、实际的语言来解释异步编程，你可能会得到以下内容。</p><p>iOS应用程序在任何时候都可能会做以下任何事情，甚至更多:</p><ul><li>对按钮点击做出反应</li><li>在文本字段失去焦点时设置键盘动画</li><li>从网上下载一张大图片</li><li>将数据保存到磁盘</li><li>播放音频</li></ul><p>所有这些事情似乎同时发生。每当键盘在屏幕外显示动画时，应用程序中的音频在动画完成之前不会暂停，对吗？</p><p><img src="https://upload-images.jianshu.io/upload_images/1024068-86ed935f8632f3aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p><p>你的程序的所有不同部分都不会互相阻止对方的执行。<em>iOS</em> 提供了各种 <em>API</em> ，允许你在不同的线程上执行不同的工作，并在设备 <em>CPU</em> 的不同核心上执行它们。</p><p>然而，编写真正并行运行的代码相当复杂，尤其是当不同的代码位需要处理相同的数据块时。很难说哪段代码首先更新数据，或者哪段代码读取最新值。</p><h3 id="Cocoa-和-UIKit-异步API（Cocoa-and-UIKit-asynchronous-APIs）"><a href="#Cocoa-和-UIKit-异步API（Cocoa-and-UIKit-asynchronous-APIs）" class="headerlink" title="Cocoa 和 UIKit 异步API（Cocoa and UIKit asynchronous APIs）"></a>Cocoa 和 UIKit 异步API（Cocoa and UIKit asynchronous APIs）</h3><p>苹果在 <em>iOS SDK</em> 中提供了很多 <em>API</em> 来帮助你编写异步代码。你在自己的项目中使用过这些功能，但可能从来没有考虑过，因为它们是编写移动应用程序的基础。</p><p>你可能已经使用了以下大部分：</p><ul><li><strong>通知中心(NotificationCenter)</strong>：在发生感兴趣的事件时执行一段代码，如用户更改设备的方向或屏幕上显示或隐藏的软件键盘。</li><li><strong>委托模式(The delegate pattern)</strong>：允许你定义一个代表另一个对象或与另一个对象协作的对象。例如，在你的 <em>APP</em> 委托中，你定义了当一个新的远程通知到达时会发生什么，但是你不知道这段代码什么时候会被执行，或者它会被执行多少次。</li><li><strong>GCD(Grand Central Dispatch)</strong>：帮助你抽象执行工作片段。你可以在串行队列中调度要顺序执行的代码，或者在具有不同优先级的不同队列上并发运行大量任务。</li><li><strong>闭包(Closures)</strong>：创建可以在代码中传递的分离代码段，以便其他对象可以决定是否执行、执行多少次以及在什么上下文中执行。</li></ul><p>由于大多数典型代码都会异步执行一些工作，而且所有 <em>UI</em> 事件本质上都是异步的，所以不可能假设整个应用程序代码执行的顺序。</p><p>毕竟，应用程序的代码运行方式取决于各种外部因素，比如用户输入、网络活动或其他OS事件。每次用户启动应用程序时，根据这些外部因素，代码运行的顺序可能完全不同。</p><p>我们并不是说编写好的异步代码是不可能的。毕竟，上面列出的苹果的 <em>API</em> 非常先进，非常专业，公平地说，与其他平台相比，它们的功能非常强大。</p><p>问题在于，复杂的异步代码变得非常难以编写，部分原因在于苹果的 <em>SDK</em> 提供了多种 <em>API</em> :</p><p><img src="https://upload-images.jianshu.io/upload_images/1024068-e0b53198ef4a7d57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p><p>使用代理要求你采用一种特定的模式，另一种模式用于闭包，还有另一种方法用于订阅 <em>NotificationCenter</em> ，等等。由于所有异步 <em>API</em> 之间没有通用语言，因此阅读和理解代码并对其执行进行推理变得非常困难。</p><p>为了结束本节并将讨论放到更大的上下文中，你将比较两段代码：一段同步代码和一段异步代码。</p><h4 id="同步代码（Synchronous-code）"><a href="#同步代码（Synchronous-code）" class="headerlink" title="同步代码（Synchronous code）"></a>同步代码（Synchronous code）</h4><p>为数组的每个元素执行操作是你已经做过很多次的事情。这是一个非常简单但坚实的应用程序逻辑构建块，因为它保证了两件事:它同步执行，当你在其上迭代时，集合是不可变的。</p><p>花点时间想想这意味着什么。当你遍历一个集合时，你不需要检查所有元素是否仍然存在，也不需要回滚，以防另一个线程在集合的开头插入一个元素。假定总是在循环开始时对集合进行整体迭代。</p><p>如果你想在 <em>for</em> 循环的这些方面玩得更多一些，可以在 <em>playground</em> 上试试：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">for</span> number <span class="token keyword">in</span> array <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>  array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span></code></pre><p><code>array</code>在<code>for</code>循环体内是否可变？循环迭代的集合是否发生更改？所有命令的执行顺序是什么？如果需要，你能修改<code>number</code>吗？</p><h4 id="异步代码-Asynchronous-code"><a href="#异步代码-Asynchronous-code" class="headerlink" title="异步代码(Asynchronous code)"></a>异步代码(Asynchronous code)</h4><p>考虑类似的代码，但是假设每次迭代都是对按钮点击的反应。当用户反复点击按钮时，应用程序就会打印出数组中的下一个元素：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">var</span> currentIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token comment" spellcheck="true">// This method is connected in Interface Builder to a button</span><span class="token atrule">@IBAction</span> <span class="token keyword">func</span> <span class="token function">printNext</span><span class="token punctuation">(</span><span class="token number">_</span> sender<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">print</span><span class="token punctuation">(</span>array<span class="token punctuation">[</span>currentIndex<span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token keyword">if</span> currentIndex <span class="token operator">!=</span> array<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">{</span>    currentIndex <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>请在与前面代码相同的上下文中考虑这段代码。当用户点击按钮时，会打印出数组的所有元素吗?你真的不好说。</p><p>另一段异步代码可能会在打印之前删除最后一个元素。或者，在继续之后，另一段代码可能会在集合的开头插入一个新元素。此外，你假定只有<code>printNext(_:)</code>会更改<code>currentIndex</code>，但是另一段代码也可能修改<code>currentIndex</code>——也许是在创建了上述函数之后添加的一些“聪明的”代码。</p><p>你可能已经意识到编写异步代码的一些核心问题是:</p><ul><li>执行任务的顺序</li><li>共享可变数据</li></ul><p>幸运的是，这是 <em>RxSwift</em> 的一些强项!</p><p>接下来，你需要一个很好的入门语言，这将帮助你开始理解 <em>RxSwift</em> 是如何工作的，以及它解决了哪些问题；这最终会让你跳过这个温和的介绍，在下一章中编写你的第一个 <em>Rx</em> 代码。</p><h3 id="异步编程术语表"><a href="#异步编程术语表" class="headerlink" title="异步编程术语表"></a>异步编程术语表</h3><p><em>RxSwift</em> 中的一些语言与异步、响应式或函数式编程紧密地绑定在一起，如果你首先理解以下基本术语，就会更容易理解。</p><p>总的来说，<em>RxSwift</em> 试图解决以下问题:</p><h4 id="1-状态，特别是共享可变状态"><a href="#1-状态，特别是共享可变状态" class="headerlink" title="1.状态，特别是共享可变状态"></a>1.状态，特别是共享可变状态</h4><p>状态有点难以定义。要理解状态，请考虑下面的实际示例。</p><p>当你启动你的笔记本电脑时，它运行得很好，但是，在你使用它几天甚至几周后，它可能会开始表现得古怪或突然挂起，拒绝和你说话。硬件和软件保持不变，但改变的是状态。一旦重新启动，相同的硬件和软件组合将再次正常工作。</p><p>内存中的数据、存储在磁盘上的数据、对用户输入做出反应的所有控件、从云服务获取数据后留下的所有痕迹——这些总和就是你的笔记本电脑的状态。</p><p>管理应用程序的状态，尤其是在多个异步组件之间共享时，是本书中你将学习如何处理的问题之一。</p><h4 id="2-命令式编程-Imperative-programming"><a href="#2-命令式编程-Imperative-programming" class="headerlink" title="2. 命令式编程(Imperative programming)"></a>2. 命令式编程(Imperative programming)</h4><p>命令式编程是一种使用语句改变程序状态的编程范式。就像你在和你的狗狗玩耍时使用命令语言一样——“去拿回来!躺下!装死!” - 你使用命令式代码告诉应用程序确切的时间和如何做事情。</p><p>命令式代码与计算机能够理解的代码类似。<em>CPU</em> 所做的就是遵循冗长的简单指令序列。问题是，对于人类来说，为复杂的异步应用程序编写命令式代码非常具有挑战性——尤其是涉及到共享可变状态时。</p><p>例如，以在 <em>iOS</em> 视图控制器的 <code>viewDidAppear(_:)</code>中找到的代码为例：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">override</span> <span class="token keyword">func</span> <span class="token function">viewDidAppear</span><span class="token punctuation">(</span><span class="token number">_</span> animated<span class="token punctuation">:</span> <span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">viewDidAppear</span><span class="token punctuation">(</span>animated<span class="token punctuation">)</span>  <span class="token function">setupUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">connectUIControls</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">createDataSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">listenForChanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>目前还不知道这些方法有什么用。它们是否更新视图控制器本身的属性？更令人不安的是，它们的调用顺序是否正确?也许有人无意中交换了这些方法调用的顺序，并将更改提交给了源代码管理。现在，由于调用顺序的交换，应用程序的行为可能会有所不同。</p><h4 id="3-副作用-Side-effects"><a href="#3-副作用-Side-effects" class="headerlink" title="3.副作用(Side effects)"></a>3.副作用(Side effects)</h4><p>既然你对可变状态和命令式编程有了更多的了解，你就可以把这两件事的大部分问题归结为副作用。</p><p>副作用表示代码当前作用域之外状态的任何更改。例如，考虑上面例子中的最后一段代码。<code>connectUIControls()</code>可能将某种事件处理程序附加到某些 <em>UI</em> 组件。这会产生一个副作用，因为它改变了视图的状态：应用程序在执行<code>connectUIControls()</code>之前以一种方式执行，之后以另一种方式执行。</p><p>任何时候修改存储在磁盘上的数据或更新屏幕上标签的文本，都会产生副作用。</p><p>副作用本身并不是坏事。毕竟，产生副作用是任何程序的最终目标!你需要在你的程序执行完毕后以某种方式改变世界的状态。</p><p>运行一段时间，什么都不做，会让应用程序变得非常无用。</p><p><img src="https://upload-images.jianshu.io/upload_images/1024068-0d327521f6905888.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt=""></p><p>产生副作用的一个重要方面是用一种可控的方式。你需要能够确定哪些代码片段会导致副作用，以及哪些代码片段只处理和输出数据。</p><p><em>RxSwift</em> 试图通过处理以下几个概念来解决上面列出的问题。</p><h4 id="4-声明式的代码-Declarative-code"><a href="#4-声明式的代码-Declarative-code" class="headerlink" title="4.声明式的代码(Declarative code)"></a>4.声明式的代码(Declarative code)</h4><p>在命令式编程中，你可以随意改变状态。在函数式编程中，您的目标是最小化引起副作用的代码。既然你没有生活在一个完美的世界里，那么平衡就在两者之间。<em>RxSwift</em> 结合了命令式代码和函数式代码的一些最佳方面。</p><p>声明性代码允许你定义行为片段。只要有相关事件，<em>RxSwift</em> 就会运行这些行为，并提供一个不可变的、独立的数据块来处理。</p><p>通过这种方式，你可以处理异步代码，但是要做出与简单的 <em>for</em> 循环相同的假设:你正在处理不可变数据，并且可以以顺序的、确定的方式执行代码。</p><h4 id="5-响应式系统"><a href="#5-响应式系统" class="headerlink" title="5.响应式系统"></a>5.响应式系统</h4><p>响应式系统是一个相当抽象的术语，涵盖了 <em>web</em> 或 <em>iOS</em> 应用程序，这些应用程序大多或全部具备以下品质:</p><ul><li><strong>响应性</strong>：始终保持UI最新，表示最新的应用程序状态。</li><li><strong>可恢复</strong>：每个行为都是独立定义的，提供了灵活的错误恢复。</li><li><strong>灵活性</strong>：代码处理不同的工作负载，通常实现诸如延迟下拉式数据收集、事件节流和资源共享等特性。</li><li><strong>消息驱动</strong>：组件使用基于消息的通信来改进可重用性和隔离性，解耦类的生命周期和实现。</li></ul><p>既然你已经很好地理解了 <em>RxSwift</em> 帮助解决的问题以及它是如何处理这些问题的，那么现在就可以讨论 <em>Rx</em> 的构建块以及它们如何协同工作了。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Swift响应式编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 响应式编程 </tag>
            
            <tag> RxSwift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第六章 函数式编程(Functional Programming)</title>
      <link href="/2019/09/16/pro-swift-yi-wen/chapter6-functional-programming/"/>
      <url>/2019/09/16/pro-swift-yi-wen/chapter6-functional-programming/</url>
      
        <content type="html"><![CDATA[<p>如果需要每个元素的索引及其值，可以使用<code>enumerated()</code>方法遍历数组：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> element<span class="token punctuation">)</span> <span class="token keyword">in</span> loggerContent<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   logfiles<span class="token punctuation">[</span><span class="token string">"logfile<span class="token interpolation"><span class="token delimiter variable">\(</span>index<span class="token delimiter variable">)</span></span>.txt"</span><span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">}</span></code></pre><p>– <em>Veronica Ray (@nerdonica), software engineer at LinkedIn</em></p><h2 id="什么是函数式编程？"><a href="#什么是函数式编程？" class="headerlink" title="什么是函数式编程？"></a>什么是函数式编程？</h2><p>取决于你来自哪里，函数式编程可能是一种非常正常的代码编码方式，它可能是某种偷偷溜出大学校园的学术工具，也可能是你用来吓唬孩子睡觉的东西。事实上，函数式编程的使用范围很广，从“我基本上在阅读代数”到“我主要使用面向对象的代码，以及一些我需要的函数式技术”。</p><p>我读过很多关于函数式编程的教程，这些教程的本意是好的，但最终可能弊大于利。你看，函数式编程并不难用实际的方法来学习和使用，但是你也可以用 <strong><em>monad</em></strong> 和 <strong><em>functor</em></strong> 来压倒人们。我的目的是教会你函数式编程的好处，同时也减少你不太可能从中受益的部分。我不道歉：这整本书都是教你如何立即动手改进编码，而不是解释什么是引用透明性。</p><p>我想用 <strong>Andy Matuschak</strong> 所说的“轻量级接触”来教你一些函数式编程。这意味着我们将集中精力寻找简单、小的好处，您可以立即理解和使用。<strong>Andy</strong> 是一位经验丰富的函数式编程人员，但他在学习方法方面也很务实——我希望他不会对我简化(甚至抛弃)这么多理论太反感！</p><p>在讨论函数代码之前，我想让你大致了解一下为什么我们可能要更改当前的工作方式。你可能在过去广泛地使用过面向对象：你已经创建了类，从这些类生成子类，添加了方法和属性，等等。如果你已经阅读了关于引用和值类型的章节，你还将知道对象是引用类型，这意味着属性可以由它的任何多个所有者进行更改。</p><p>我们认为面向对象很简单，因为这是我们所知道的。如果我告诉你<code>PoodlePoodle</code>继承自<code>Dog</code>，具有<code>barkVolume</code>属性和<code>biteStrength</code>属性，以及<code>barkWorseThanBite()</code>方法，你马上就会明白这意味着什么。但这并不简单。它很复杂：一个“简单”的类混合了状态、功能、继承等等，所以你需要在脑子里记住很多东西才能跟上。</p><p>函数式编程——或者至少是我将在这里使用的稍微简化的定义——可以极大地简化代码。首先，这将导致问题，因为你正在有效地对抗面向对象的肌肉记忆：你通过创建一个新类来解决每个问题的本能需要暂时搁置，至少目前是这样。</p><p>相反，我们将应用 <em>5</em> 条原则，帮助你在不使用代数的情况下实现函数式编程的好处。</p><p>首先，函数是一等数据类型。这意味着它们可以像整数和字符串一样被创建、复制和传递。其次，因为函数是一等数据类型，所以它们可以用作其他函数的参数。第三，为了使我们的函数能够以不同的方式重用，当给定特定的输入时，它们应该总是返回相同的输出，并且不会产生任何副作用。第四，由于函数总是为某些给定的输入返回相同的输出，所以我们应该使用不可变的数据类型，而不是使用函数来更改可变变量。第五，也是最后一点，因为我们的函数不会产生副作用，而且变量都是不可变的，所以我们可以减少我们在程序中跟踪的状态的数量——并且常常可以完全消除它。</p><p>我知道一下子要理解很多东西，所以让我试着把每一个都分解得更详细些。</p><p>你应该已经知道函数在 <em>Swift</em> 中是一等数据类型——毕竟，你可以复制闭包并传递它们。这是第一条。接下来，将函数作为参数传递给其他函数也是你可能已经做过的事情，比如使用闭包调用<code>sort()</code>。你可能会遇到“高阶函数”这个名称，它是为接受另一个函数作为参数的函数指定的名称。</p><p>当我们编写的函数总是为给定的输入生成相同的输出时，事情就变得有点复杂了——但有趣得多。这意味着，如果你编写一个函数<code>lengthOf(string:)</code>，它接受一个字符串数组并根据每个字符串的长度返回一个整数数组，那么当给定<code>["Taylor", "Paul", "Adele"]</code>时，该函数将返回<code>[6, 4, 5]</code>。不管程序中发生了什么，也不管函数被调用的频率：相同的输入必须返回相同的输出。</p><p>因此，函数不应该产生可能影响其他函数的副作用。例如，如果我们有另一个函数<code>fetchSystemTime()</code>返回时间，那么调用<code>fetchSystemTime()</code>不会影响<code>lengthOf(strings:)</code>的结果。对于给定的输入，总是返回相同的结果而不会产生副作用的函数通常称为纯函数。我想这就使得所有的函数都不纯了，你不想写很脏很脏的函数，对吧?</p><p>关于纯函数的混淆的一个来源是围绕<strong>副作用</strong>的含义。如果一个函数做了写磁盘之类的事情，这是一个副作用还是实际上只是函数的要点？关于这个有很多争论，我就不深入了。相反，我要说的是，函数式程序员应该渴望创建纯函数，但是当涉及到关键问题时，应该优先考虑已知输入的可预测输出，而不是避免副作用。也就是说，如果你想编写一个将一些数据写入磁盘的函数(一个副作用？实际效果如何？你想怎么调用就怎么调用！），然后继续，但至少要确保在给定相同的数据时，它所写的内容完全相同。</p><p>我已经讨论了不可变数据类型和值(而不是引用)的重要性，所以我不会再讨论它们，只是说类在函数代码中就像在血友病公约中刺猬一样受欢迎。</p><p>最后，状态的缺乏是很棘手的，因为它已经深入到对象定向中。“状态”是由程序存储的一系列值，这并不总是一件坏事——它包括缓存一些东西来提高性能，以及一些重要的东西，比如用户设置。当在函数中使用这种状态时，问题就出现了，因为这意味着函数不再是可预测的。</p><p>使用<code>lengthOf(strings:)</code>的例子，考虑如果我们有一个名为<code>returnLengthsAsBinary</code>的布尔值设置会发生什么——当给定<code>["Taylor", "Paul", "Adele"]</code>时，该函数可能返回<code>[6, 4, 5]</code>，也可能返回<code>['110', '10', '101']</code>，这取决于一个外部的布尔值。要务实，不要不惜任何代价避免状态，但绝不要让它污染你的函数代码，并尽可能地减少它的使用。</p><p>当这五个原则结合在一起时，你会得到许多即时的、有价值的好处。当你编写产生可预测输出的函数时，你可以为它们编写简单的单元测试。当你使用不可变的值类型而不是引用类型时，你将删除应用程序中不可预料的依赖项，并使你的代码更容易推理。当你构建一些小的、可组合的功能，这些功能可以与高阶功能结合，并以多种方式重新使用，你可以通过将许多小的、简单的部件组合在一起来构建功能强大的应用程序。</p><p>注意：我将在后面的章节中提到这五个原则。我不想一遍又一遍地重复，我只想说希望你能记住这五个函数原则：</p><ul><li>一等数据类型</li><li>高阶函数</li><li>纯函数</li><li>不变性</li><li>减少状态</li></ul><p>好吧，理论足够了。我希望我已经成功地说服了你，函数式编程可以为每个人提供一些东西，即使你只从下面几节中获取一些概念，这也是一个很大的改进。</p><h2 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h2><p>让我们从函数编程的最简单的<code>map()</code>方法开始。这将从容器中取出一个值，对其应用一个函数，然后将该函数的结果放回返回给你的新容器中。<em>Swift</em> 的数组、字典和集合都内置了<code>map()</code>方法，它通常用于遍历数组中的每一项，同时将函数应用于每个值。</p><p>我已经提到过一个<code>lengthOf(string:)</code>函数，它接受一个字符串数组并根据输入字符串的大小返回一个整数数组。你可以这样写：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">lengthOf</span><span class="token punctuation">(</span>strings<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> string <span class="token keyword">in</span> strings <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>string<span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> result<span class="token punctuation">}</span></code></pre><p>该函数接受一个字符串数组，并基于这些字符串返回一个整数数组。这是<code>map()</code>的完美用法，实际上我们可以用这个替换所有代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">lengthOf</span><span class="token punctuation">(</span>strings<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> strings<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>很明显，函数式方法更短，但它的好处不仅仅是编写更少的代码。相反，函数式版本向编译器传达了更重要的含义：现在很明显，我们想要对数组中的每一项应用一些代码，而要高效地实现这一点，取决于 <em>Swift</em> 。就我们所知，<em>Swift</em> 可以并行化你的闭包，这样它可以一次处理 <em>4</em> 项，或者它可以以比从头到尾更有效的顺序处理这些项。</p><p>使用<code>map()</code>也向其他程序员表明了我们的意图：它将遍历数组中的每一项并对其应用一个函数。使用传统的<code>for</code>循环，你可能会在执行到一半的时候有一个中断—<code>map()</code>不可能做到这一点—而找到这个中断的惟一方法是读取所有代码。如果你遵循我已经列出的 <em>5</em> 条函数原则(特别是使用纯函数和避免状态)，那么阅读你代码的人就会立即知道<code>map()</code>使用的闭包不会试图存储全局状态。</p><p>这种简化是很重要的，这是一个关注点的改变。<em>Javier Soto</em> — <em>Twitter</em> 著名的功能支持者和敏捷黑客—这样总结<code>map()</code>的用处：它允许我们表达我们想要实现什么，而不是如何实现。也就是说，我们只需说这是我们想对这个数组中的项做的事情，这比手工编写循环和手工创建数组更容易读、写和维护。</p><p>另一件事：注意类型签名没有发生变化。这意味着我们编写<code>func lengthOf(String: [String]) -&gt; [Int]</code>，不管我们是否在内部使用函数方法。这意味着你可以更改函数的内部结构，以采用函数方法，而不影响它们与应用程序其余部分的交互方式——你可以一点一点地更新代码，而不是一次更新所有代码。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>为了帮助你更好地使用<code>map()</code>，这里有一些示例。</p><p>这段代码将字符串转换为大写：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> fruits <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Apple"</span><span class="token punctuation">,</span> <span class="token string">"Cherry"</span><span class="token punctuation">,</span> <span class="token string">"Orange"</span><span class="token punctuation">,</span> <span class="token string">"Pineapple"</span><span class="token punctuation">]</span><span class="token keyword">let</span> upperFruits <span class="token operator">=</span> fruits<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span><span class="token function">uppercased</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>该代码段将整型表示的得分数组转换为格式化的字符串：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">]</span><span class="token keyword">let</span> formatted <span class="token operator">=</span> scores<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token string">"Your score was <span class="token interpolation"><span class="token delimiter variable">\(</span>$<span class="token number">0</span><span class="token delimiter variable">)</span></span>"</span> <span class="token punctuation">}</span></code></pre><p>这两个代码段使用三目运算符创建字符串数组，根据特定的条件匹配每个项。第一段代码检查在 <em>85</em> 分以上的得分，第二段检查在 <em>45 - 55</em>  (含 <em>45 - 55</em> )范围内的位置：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span> <span class="token number">80</span><span class="token punctuation">,</span> <span class="token number">85</span><span class="token punctuation">]</span><span class="token keyword">let</span> passOrFail <span class="token operator">=</span> scores<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">></span> <span class="token number">85</span> <span class="token operator">?</span> <span class="token string">"Pass"</span> <span class="token punctuation">:</span> <span class="token string">"Fail"</span> <span class="token punctuation">}</span><span class="token keyword">let</span> position <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">60</span><span class="token punctuation">,</span> <span class="token number">40</span><span class="token punctuation">]</span><span class="token keyword">let</span> averageResults <span class="token operator">=</span> position<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token number">45</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">55</span> <span class="token operator">~</span><span class="token operator">=</span> $<span class="token number">0</span>  <span class="token operator">?</span> <span class="token string">"Withinaverage"</span> <span class="token punctuation">:</span> <span class="token string">"Outside average"</span> <span class="token punctuation">}</span></code></pre><p>最后，这个例子使用<code>sqrt()</code>函数来计算数字的平方根：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">let</span> numbers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Double</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token number">36</span><span class="token punctuation">,</span> <span class="token number">49</span><span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>sqrt<span class="token punctuation">)</span></code></pre><p>如你所见，<code>map()</code>之所以叫这个名称，是因为它指定了从一个数组到另一个数组的映射。也就是说，如果你给它传递一个数组<code>[a, b, c]</code>和函数<code>f()</code>， <em>Swift</em> 会给你等价的<code>[f(a),f(b), f(c)]</code>。</p><h3 id="Optional-map"><a href="#Optional-map" class="headerlink" title="Optional map"></a>Optional map</h3><p>重复我前面所说的，<code>map()</code>从容器中取出一个值，应用一个函数，然后将该函数的结果放回一个返回给你的新容器中。到目前为止，我们一直在使用数组，但是如果你仔细想想， <strong><em>Optional</em></strong> 其实就是一个存放值的容器。它们的定义如下：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Optional</span><span class="token operator">&lt;</span><span class="token builtin">Wrapped</span><span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token keyword">none</span>   <span class="token keyword">case</span> <span class="token function">some</span><span class="token punctuation">(</span><span class="token builtin">Wrapped</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>因为它们只是单个值的简单容器，所以我们也可以在 <em>Optional</em> 上使用<code>map()</code>。原理是一样的：从容器中取出值，应用函数，然后再将值放回容器中。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> i<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">let</span> j <span class="token operator">=</span> i<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span></code></pre><p>这将打印 <strong><em>Optional(20)</em></strong> ：值 <em>10</em> 从 <em>Optional</em> 容器中取出，乘以 <em>2</em> ，然后放回 <em>Optional</em> 容器中。如果<code>i</code>是<code>nil</code>，<code>map()</code>只会返回<code>nil</code>。此行为使<code>map()</code>在操作可选值时非常有用，特别是与空值合并运算符组合时。</p><p>举个例子，考虑下面的函数：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fetchUsername</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> id <span class="token operator">==</span> <span class="token number">1989</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token string">"Taylor Swift"</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token constant">nil</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>它返回一个可选字符串，因此我们要么返回 <code>Taylor Swift</code> 要么返回<code>nil</code>。如果我们想打印一条欢迎信息——但只有当我们得到一个用户名时——那么可选的<code>map</code>是完美的选择：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> username<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token function">fetchUsername</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token number">1989</span><span class="token punctuation">)</span><span class="token keyword">let</span> formattedUsername <span class="token operator">=</span> username<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> <span class="token string">"Welcome, <span class="token interpolation"><span class="token delimiter variable">\(</span>$<span class="token number">0</span><span class="token delimiter variable">)</span></span>!"</span> <span class="token punctuation">}</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Unknown user"</span><span class="token function">print</span><span class="token punctuation">(</span>formattedUsername<span class="token punctuation">)</span></code></pre><p>要用非函数式的方法来写，另一种方法要长得多：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> username <span class="token operator">=</span> <span class="token function">fetchUsername</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token number">1989</span><span class="token punctuation">)</span><span class="token keyword">let</span> formattedUsername<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token keyword">if</span> <span class="token keyword">let</span> username <span class="token operator">=</span> username <span class="token punctuation">{</span>   formattedUsername <span class="token operator">=</span> <span class="token string">"Welcome, <span class="token interpolation"><span class="token delimiter variable">\(</span>username<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   formattedUsername <span class="token operator">=</span> <span class="token string">"Unknown user"</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>formattedUsername<span class="token punctuation">)</span></code></pre><p>我们可以使用一个更短的替代方法，但它涉及到三目运算符和强制展开：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> username <span class="token operator">=</span> <span class="token function">fetchUsername</span><span class="token punctuation">(</span>id<span class="token punctuation">:</span> <span class="token number">1989</span><span class="token punctuation">)</span><span class="token keyword">let</span> formattedUsername <span class="token operator">=</span> username <span class="token operator">!=</span> <span class="token constant">nil</span> <span class="token operator">?</span> <span class="token string">"Welcome, <span class="token interpolation"><span class="token delimiter variable">\(</span>username<span class="token operator">!</span><span class="token delimiter variable">)</span></span>!"</span> <span class="token punctuation">:</span> <span class="token string">"Unknown user"</span><span class="token function">print</span><span class="token punctuation">(</span>formattedUsername<span class="token punctuation">)</span></code></pre><h3 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h3><p><code>map()</code>有一个名为<code>forEach()</code>的紧密关系，它也遍历数组并对每个项执行一个函数。主要的区别在于返回值：<code>map()</code>返回一个新的项数组，而<code>forEach()</code>根本不返回任何项——这只是循环每个项的函数方法。</p><p>这为编译器和代码的读者提供了更多的信息：通过使用<code>forEach()</code>，你清楚地表明你没有操纵数组的内容，这使得 <em>Swift</em> 优化器可以做得更好。</p><p>除了返回值外，<code>forEach()</code>与<code>map()</code>使用相同：</p><pre class=" language-swift"><code class="language-swift"><span class="token punctuation">[</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Paul"</span><span class="token punctuation">,</span> <span class="token string">"Adele"</span><span class="token punctuation">]</span><span class="token punctuation">.</span>forEach <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p><code>forEach()</code>和<code>map()</code>之间还有一个不同之处，即执行顺序：<code>forEach()</code>保证按照数组的顺序遍历数组中的元素，而<code>map()</code>可以按照它喜欢的任何顺序执行。</p><p>在幕后，<code>forEach()</code>实际上可以归结为一个常规的<code>for-in</code>循环——它没有什么特别之处。下面是<code>forEach()</code>的内部 <em>Swift</em> 源代码，直接取自 <em>Apple</em> ：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function">forEach</span><span class="token punctuation">(</span><span class="token number">_</span> body<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">Iterator</span><span class="token punctuation">.</span><span class="token builtin">Element</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token punctuation">{</span>   <span class="token keyword">for</span> element <span class="token keyword">in</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token function">body</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h2><p>我不打算骗你，<code>flatMap()</code>一开始看起来很吓人。我把它放在这里，直接跟在令人惊讶的简单和有用的<code>map()</code>函数后面，因为这两个函数是紧密相关的，而不是因为我想用<code>flatMap()</code>让你在函数式生涯的早期感到震惊！</p><p>如你所见，<code>map()</code>从容器(如数组)中取出一个项，对其应用一个函数，然后将其放回容器中。最直接的用例是数组，但是 <strong><em>Optional</em></strong> 也可以。</p><p>当数组包含数组时，即数组的数组，你可以访问<code>join()</code>方法的一个版本，该方法将数组的数组转换为单个数组，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token keyword">let</span> joined <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>numbers<span class="token punctuation">.</span><span class="token function">joined</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// [1, 2, 3, 4, 5, 6]</span></code></pre><p>因此，<code>join()</code>将数组复杂度降低了一层：通过连接项，二维数组变成了一维数组。</p><p><code>flatMap()</code>函数是在一个调用中有效地组合使用<code>map()</code>和<code>join()</code>，按这个顺序。它使用你提供的函数将数组 <em>A</em> 中的项映射到数组 <em>B</em> 中，然后连接结果。当你记住数组和 <strong><em>Optional</em></strong> 都是容器时，这就变得很有价值了，因此<code>flatMap()</code>能够删除一个层级的容器确实非常受欢迎。</p><p>首先，让我们看看我们的朋友<code>map()</code>：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> albums<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Fearless"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Speak Now"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Red"</span><span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> albums<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><p>使用<code>$0</code>映射只意味着“返回现有值”，因此代码将打印以下内容：</p><pre class=" language-swift"><code class="language-swift"><span class="token punctuation">[</span><span class="token function">Optional</span><span class="token punctuation">(</span><span class="token string">"Fearless"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token function">Optional</span><span class="token punctuation">(</span><span class="token string">"Speak Now"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token function">Optional</span><span class="token punctuation">(</span><span class="token string">"Red"</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p>这是很多的可选值，一些<code>nil</code>分布其中。切换到<code>flatMap()</code>而不是<code>map()</code>可以帮助：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> albums<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Fearless"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Speak Now"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Red"</span><span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> albums<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><p>只需将<code>map { $0 }</code>更改为<code>flatMap { $0 }</code>，结果就会发生显著变化：</p><pre class=" language-swift"><code class="language-swift"><span class="token punctuation">[</span><span class="token string">"Fearless"</span><span class="token punctuation">,</span> <span class="token string">"Speak Now"</span><span class="token punctuation">,</span> <span class="token string">"Red"</span><span class="token punctuation">]</span></code></pre><p>可选值没有了，<code>nil</code>也被移除——完美！</p><p>这种魔力的原因在于<code>flatMap()</code>的返回值：<code>map()</code>将保留它处理的项的可选性，而<code>flatMap()</code>将删除它。因此，在下面的代码中，<code>mapResult</code>的类型是<code>[String?]</code>，<code>flatMapResult</code>类型为<code>[String]</code>：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> mapResult <span class="token operator">=</span> albums<span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token keyword">let</span> flatMapResult <span class="token operator">=</span> albums<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span></code></pre><h3 id="Optional-flat-map"><a href="#Optional-flat-map" class="headerlink" title="Optional flat map"></a>Optional flat map</h3><p>如果<code>flatMap()</code>的用处还不是很清楚，请跟我来！让我们再来看看这个例子：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> albums<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Fearless"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Speak Now"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Red"</span><span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> albums<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span></code></pre><p><code>albums</code>数组的类型是<code>[string?]</code>，因此它包含一个可选字符串数组。在这里使用<code>flatmap()</code>去掉了可选性，但实际上这只是连接可选容器的效果——它不做任何类型的映射转换。</p><p>现在，<code>flatmap()</code>变得非常棒：因为连接发生在映射之后，你可以有效地说“对这些项做一些有趣的事情，然后删除返回<code>nil</code>的任何项。”</p><p>举个实际的例子，假设有一个学校成绩计算器：学生被要求输入各种考试的分数，它将输出他们的估计成绩。这需要将用户输入的数字转换为整数，这是有问题的，因为它们可能出错或输入无意义的数字。因此，从字符串创建一个整数将返回一个可选整数——如果输入是“Fish”，则返回<code>nil</code>; 如果输入是“100”，则返回<code>100</code>。</p><p>这对于<code>flatMap()</code>来说是一个完美的问题：我们可以取一个像<code>["100"，"90"，"Fish"， "85"]</code>这样的数组，映射每个值，将其转换为一个可选的整数，然后加入得到的数组，删除可选性和任何无效的值：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"100"</span><span class="token punctuation">,</span> <span class="token string">"90"</span><span class="token punctuation">,</span> <span class="token string">"Fish"</span><span class="token punctuation">,</span> <span class="token string">"85"</span><span class="token punctuation">]</span><span class="token keyword">let</span> flatMapScores <span class="token operator">=</span> scores<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> <span class="token function">Int</span><span class="token punctuation">(</span>$<span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>flatMapScores<span class="token punctuation">)</span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pro Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Pro Swift </tag>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第五章 错误处理(Errors)</title>
      <link href="/2019/09/06/pro-swift-yi-wen/chapter5-errors/"/>
      <url>/2019/09/06/pro-swift-yi-wen/chapter5-errors/</url>
      
        <content type="html"><![CDATA[<p>你可以扩展集合，使其具有安全的下标，当值不存在时返回<code>nil</code>：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">Array</span> <span class="token punctuation">{</span>    <span class="token keyword">subscript</span><span class="token punctuation">(</span><span class="token keyword">safe</span> index<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Element</span><span class="token operator">?</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token builtin">indices</span> <span class="token operator">~</span><span class="token operator">=</span> index <span class="token operator">?</span> <span class="token keyword">self</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token constant">nil</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>– <em>Chris Eidhof (@chriseidhof), author of Advanced Swift</em> </p><h2 id="错误基础-Error-fundamentals"><a href="#错误基础-Error-fundamentals" class="headerlink" title="错误基础(Error fundamentals)"></a>错误基础(Error fundamentals)</h2><p><em>Swift</em> 有一个独特的错误处理方式，只要你完全理解所提供的服务，它就非常灵活。我将以相对简单的方式开始，并介绍所有的错误处理技术。苹果公司的 <em>Swift</em> 参考指南说：<strong><em>throw语句的性能特征可以与return语句的性能特征相媲美</em></strong>，这意味着它们非常快——我们没有理由忽视它们。</p><p>让我们从一个简单的例子开始。你想抛出的所有错误必须是一个符合 <em>Error</em> 协议的枚举，<em>Swift</em> 可以桥接 <em>Objective-C</em> 中的 <em>NSError</em> 类。所以，我们定义一个这样的错误枚举：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">PasswordError</span><span class="token punctuation">:</span> <span class="token builtin">Error</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> empty   <span class="token keyword">case</span> short<span class="token punctuation">}</span></code></pre><p>这是一个普通枚举，就像其他枚举一样，所以我们可以添加一个关联值，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">PasswordError</span><span class="token punctuation">:</span> <span class="token builtin">Error</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> empty   <span class="token keyword">case</span> short   <span class="token keyword">case</span> <span class="token function">obvious</span><span class="token punctuation">(</span>message<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>要将函数或方法标记为有可能抛出错误，请在其返回类型之前添加<code>throws</code>，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token number">_</span> str<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> with password<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// complicated encryption goes here</span>   <span class="token keyword">let</span> encrypted <span class="token operator">=</span> password <span class="token operator">+</span> str <span class="token operator">+</span> password   <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>encrypted<span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>然后使用<code>do</code>、<code>try</code>和<code>catch</code>的组合来运行风险代码。至少，调用我们当前的代码应该是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">do</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> encrypted <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token string">"Secret!"</span><span class="token punctuation">,</span> with<span class="token punctuation">:</span> <span class="token string">"T4yl0r"</span><span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span>encrypted<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Encryption failed"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>它要么打印调用<code>encrypt()</code>的结果，要么打印错误消息。使用<code>catch</code>本身捕获所有可能的错误，这在 <em>Swift</em> 中是必需的。这是有时被称为<em>Pokémon(口袋精灵)</em> 错误处理，因为“你必须抓住他们。” 注：此限制不适用于 <em>Playground</em> 的顶层代码；如果你正在使用一个<em>Playground</em>，你应该把你的<code>do</code>模块放在一个函数中进行测试：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">testCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">do</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> encrypted <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token string">"Secret!"</span><span class="token punctuation">,</span> with<span class="token punctuation">:</span> <span class="token string">"T4yl0r"</span><span class="token punctuation">)</span>      <span class="token function">print</span><span class="token punctuation">(</span>encrypted<span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Encryption failed"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">testCatch</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>有时候，在一个<code>catch</code>块中处理所有错误可能对你有用，但是更常见的情况是，你希望捕获个别的情况。要做到这一点，请分别列出每种情况，确保通用捕获是最后一个捕获，这样只有在没有其他匹配的情况下才会使用它：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">do</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> encrypted <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token string">"secret information!"</span><span class="token punctuation">,</span> with<span class="token punctuation">:</span> <span class="token string">"T4ylorSw1ft"</span><span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span>encrypted<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span>empty <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You must provide a password."</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span>short <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Your password is too short."</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span>obvious <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Your password is obvious"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Error"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>要处理关联值，需要将其绑定到<code>catch</code>块中的常量：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">catch</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span><span class="token function">obvious</span><span class="token punctuation">(</span><span class="token keyword">let</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Your password is obvious: <span class="token interpolation"><span class="token delimiter variable">\(</span>message<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如果你想要在实际中测试它，请将<code>encrypt()</code>方法修改为：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">encrypt</span><span class="token punctuation">(</span><span class="token number">_</span> str<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> with password<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// complicated encryption goes here</span>   <span class="token keyword">if</span> password <span class="token operator">==</span> <span class="token string">"12345"</span> <span class="token punctuation">{</span>      <span class="token keyword">throw</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span><span class="token function">obvious</span><span class="token punctuation">(</span>message<span class="token punctuation">:</span> <span class="token string">"I have the same number on my luggage"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">let</span> encrypted <span class="token operator">=</span> password <span class="token operator">+</span> str <span class="token operator">+</span> password   <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>encrypted<span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在继续之前，还有最后一件事：在处理关联值时，还可以使用模式匹配。为此，首先使用<code>let</code>将关联值绑定到局部常量，然后使用<code>where</code>子句进行筛选。例如，我们可以修改<code>PasswordError</code>。返回应该提供多少字符的简写形式：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">case</span> <span class="token function">short</span><span class="token punctuation">(</span>minChars<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span></code></pre><p>有了这些变化，我们就可以通过<code>minChars</code>关联值过滤来捕捉<code>short</code>的变化：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">catch</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span><span class="token function">short</span><span class="token punctuation">(</span><span class="token keyword">let</span> minChars<span class="token punctuation">)</span> <span class="token keyword">where</span> minChars <span class="token operator">&lt;</span> <span class="token number">5</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"We have a lax security policy: passwords must be at least <span class="token interpolation"><span class="token delimiter variable">\(</span>minChars<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span><span class="token function">short</span><span class="token punctuation">(</span><span class="token keyword">let</span> minChars<span class="token punctuation">)</span> <span class="token keyword">where</span> minChars <span class="token operator">&lt;</span> <span class="token number">8</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"We have a moderate security policy: passwords must be at least <span class="token interpolation"><span class="token delimiter variable">\(</span>minChars<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span><span class="token function">short</span><span class="token punctuation">(</span><span class="token keyword">let</span> minChars<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"We have a serious security policy: passwords must be at least <span class="token interpolation"><span class="token delimiter variable">\(</span>minChars<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="错误传递-Error-propagation"><a href="#错误传递-Error-propagation" class="headerlink" title="错误传递(Error propagation)"></a>错误传递(Error propagation)</h2><p>当你使用<code>try</code>调用函数时，<em>Swift</em> 会强制你处理任何可能的错误。这有时是无益的行为：如果函数 <em>A</em> 调用函数 <em>B</em>，函数 <em>B</em> 调用函数 <em>C</em>，那么谁应该处理由 <em>C</em> 抛出的错误？如果你的答案是 <em>B</em>，那么你现有的错误处理知识就足够了。</p><p>如果你的答案是 <em>A</em> ——也就是说，一个调用者应该处理它调用的任何函数中的一些或所有错误，以及这些函数调用的函数中的任何错误，等等，你需要了解一下错误传递。</p><p>让我们对 <code>A()、B()、C()</code> 函数调用以及我们已经使用的 <code>PasswordError</code>枚举的精简版本建模：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">PasswordError</span><span class="token punctuation">:</span> <span class="token builtin">Error</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> empty<span class="token keyword">case</span> short   <span class="token keyword">case</span> obvious<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">functionA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">functionB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">functionB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">functionC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">functionC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span>short<span class="token punctuation">}</span></code></pre><p>该代码不能按原样编译，因为<code>functionC()</code>会抛出一个错误，但没有使用<code>throws</code>标记。如果我们加上这个，代码如下：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">functionC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span>short<span class="token punctuation">}</span></code></pre><p>但是现在代码仍然无法编译，因为<code>functionB()</code>在不使用<code>try</code>的情况下调用了一个抛出函数。现在我们看到了几个选项，我想单独研究它们。</p><p>第一个选项是捕获<code>functionB()</code>中的所有错误。如果希望<code>functionA()</code>忽略其下面发生的任何错误，则可以使用此选项，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">functionA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">functionB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">functionB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">do</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token function">functionC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Error!"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">functionC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span>short<span class="token punctuation">}</span></code></pre><p>你可以向<code>functionB()</code>添加单独的<code>catch</code>块，但是原理是一样的。</p><p>第二个选项是<code>functionB()</code>忽略错误，让它们向上冒泡到自己的调用者，这称为错误传递。为此，我们需要将<code>do/catch</code>代码从<code>functionB()</code>移到<code>functionA()</code>。然后我们只需要用<code>throws</code>来标记<code>functionB()</code>，就像这样：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">functionA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">do</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token function">functionB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Error!"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">functionB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token punctuation">{</span>   <span class="token keyword">try</span> <span class="token function">functionC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">functionC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span>short<span class="token punctuation">}</span></code></pre><p>在讨论第三个选项之前，我希望你仔细研究一下<code>functionB()</code>的当前代码：这是一个使用<code>try</code>的函数，周围没有<code>do/catch</code>块。这非常好，只要函数本身被标记为<code>throws</code>，那么任何错误都可以继续向上传递。</p><p>第三个选项是将错误处理的部分委托给最合适的函数。例如，你可能希望<code>functionB()</code>捕捉空密码，而<code>functionA()</code>处理所有其他错误。<em>Swift</em> 通常希望所有的<code>try/catch</code>块都是详尽的，但是如果你在一个抛出函数中，这个要求就被放弃了——任何你没有捕获的错误都会向上传播。</p><p>下面的代码中<code>functionB()</code>处理空密码，<code>functionA()</code>处理其他所有事情：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">functionA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">do</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token function">functionB</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Error!"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">functionB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token punctuation">{</span>   <span class="token keyword">do</span> <span class="token punctuation">{</span>      <span class="token keyword">try</span> <span class="token function">functionC</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span>empty <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Empty password!"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">functionC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token builtin">PasswordError</span><span class="token punctuation">.</span>short<span class="token punctuation">}</span></code></pre><p>最终，必须捕获所有错误用例，因此在某个时候，你需要一个通用的<code>catch all</code>语句。</p><h2 id="将抛出函数作为参数-Throwing-functions-as-parameters"><a href="#将抛出函数作为参数-Throwing-functions-as-parameters" class="headerlink" title="将抛出函数作为参数(Throwing functions as parameters)"></a>将抛出函数作为参数(Throwing functions as parameters)</h2><p>现在我将介绍一下 <em>Swift</em> 的一个非常有用的特性，我之所以这么说，是因为如果你发现自己在质疑为什么它有用，我想确保你能坚持下去——相信我，这是值得的!</p><p>首先，这里有一条来自 <em>Swift 参考指南</em> 的重要引用：<strong><em>非抛出函数是抛出函数的子类型</em></strong>。因此，你可以在与抛出函数相同的位置使用非抛出函数。</p><p>想一想，让它深入：非抛出函数是抛出函数的子类型，因此可以在需要抛出函数的任何地方使用它们。如果你愿意，甚至可以编写如下代码，尽管你会收到编译器警告，因为这是不必要的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">definitelyWontThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Shiny!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">try</span> <span class="token function">definitelyWontThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>真正重要的是，当你使用一个抛出函数作为参数时，我想给你一个实际的例子，这样你就能在实际环境中学习所有这些。</p><p>设想一个应用程序必须远程或本地获取用户数据，然后对其进行操作。有一个函数可以获取远程用户数据，如果存在网络问题，这个函数可能会抛出一个错误。还有第二个函数来获取本地用户数据，它保证能够工作，因此不会抛出。最后，还有第三个函数调用这两个获取函数中的一个，然后对结果执行操作。</p><p>把最后一个函数放到一边，初始代码可能是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Failure</span><span class="token punctuation">:</span> <span class="token builtin">Error</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token function">badNetwork</span><span class="token punctuation">(</span>message<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span>   <span class="token keyword">case</span> broken<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">fetchRemote</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// complicated, failable work here</span>   <span class="token keyword">throw</span> <span class="token builtin">Failure</span><span class="token punctuation">.</span><span class="token function">badNetwork</span><span class="token punctuation">(</span>message<span class="token punctuation">:</span> <span class="token string">"Firewall blocked port."</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">fetchLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// this won't throw</span>   <span class="token keyword">return</span> <span class="token string">"Taylor"</span><span class="token punctuation">}</span></code></pre><p>第三个函数是有趣的地方：它需要调用<code>fetchRemote()</code>或<code>fetchLocal()</code>并对获取的数据进行处理。这两个函数都不接受任何参数，并返回一个字符串，但是一个函数被标记为<code>throws</code>，另一个函数没有。</p><p>回想一下我几分钟前写的：你可以在任何需要抛出函数的地方使用非抛出函数。我们可以这样写一个函数：<code>fetchUserData(using closure: () throws -&gt; String)</code>。让我们来分解一下:</p><ul><li>名为<code>fetchUserData()</code></li><li>它接受闭包作为参数</li><li>该闭包必须不接受任何参数并返回字符串。</li></ul><p>但是闭包不需要抛出：我们说过它可以抛出，但它不必抛出。记住这一点，第一次传递<code>fetchUserData()</code>函数可能是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fetchUserData</span><span class="token punctuation">(</span>using closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">do</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> userData <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User data received: <span class="token interpolation"><span class="token delimiter variable">\(</span>userData<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token builtin">Failure</span><span class="token punctuation">.</span><span class="token function">badNetwork</span><span class="token punctuation">(</span><span class="token keyword">let</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>   <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Fetch error"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">fetchUserData</span><span class="token punctuation">(</span>using<span class="token punctuation">:</span> fetchLocal<span class="token punctuation">)</span></code></pre><p>如你所见，我们可以从本地获取切换到远程获取，只需要改变最后一行：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">fetchUserData</span><span class="token punctuation">(</span>using<span class="token punctuation">:</span> fetchRemote<span class="token punctuation">)</span></code></pre><p>所以，我们传入的闭包是否抛出并不重要，只要我们声明它可能抛出并适当地处理它。</p><p>当你想用一个可能会抛出异常的闭包作为参数来使用错误传递时，事情就会变得有趣——有趣的是，我的意思是非常棒。坚持住——我们快结束了！</p><p>一个简单的解决方案可以将<code>fetchUserData()</code>声明为抛出，然后捕获调用者的错误，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fetchUserData</span><span class="token punctuation">(</span>using closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> userData <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User data received: <span class="token interpolation"><span class="token delimiter variable">\(</span>userData<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">do</span> <span class="token punctuation">{</span>   <span class="token keyword">try</span> <span class="token function">fetchUserData</span><span class="token punctuation">(</span>using<span class="token punctuation">:</span> fetchLocal<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token builtin">Failure</span><span class="token punctuation">.</span><span class="token function">badNetwork</span><span class="token punctuation">(</span><span class="token keyword">let</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Fetch error"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在这种情况下，这是可行的，但是 <em>Swift</em> 有一个更聪明的解决方案。这个<code>fetchUserData()</code>可以在我们的应用程序的其他地方调用，可能不止一次——如果所有的<code>try/catch</code>代码都在其中，这会变得非常混乱，特别是当我们使用<code>fetchLocal()</code>并且知道它不会抛出的时候。</p><p><em>Swift</em> 的解决方案是<code>rethrow</code>关键字，我们可以用它来替换<code>fetchUser</code>函数中的常规抛出，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fetchUserData</span><span class="token punctuation">(</span>using closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> userData <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User data received: <span class="token interpolation"><span class="token delimiter variable">\(</span>userData<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>因此，闭包会<code>throws</code>，但是<code>fetchUserData()</code>函数会<code>rethrows</code>。区别可能看起来很细微，但这段代码现在将在 <em>Xcode</em> 中产生一个警告：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">do</span> <span class="token punctuation">{</span>   <span class="token keyword">try</span> <span class="token function">fetchUserData</span><span class="token punctuation">(</span>using<span class="token punctuation">:</span> fetchLocal<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token builtin">Failure</span><span class="token punctuation">.</span><span class="token function">badNetwork</span><span class="token punctuation">(</span><span class="token keyword">let</span> message<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Fetch error"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如果将<code>try fetchUserData(using: fetchLocal)</code>替换为<code>fetchUserData(using: fetchRemote)</code>，则警告将消失。现在发生的情况是，<em>Swift</em> 编译器正在逐个检查每个对<code>fetchUserData()</code>的调用，现在只需要在传入有可能抛出异常的闭包时使用<code>try/catch</code>。</p><p>因此，当你使用<code>fetchUserData(using: fetchLocal)</code>时，编译器可以看到<code>try/ catch</code>是不必要的，但当你使用<code>fetchUserData(using: fetchRemote)</code>时，<em>Swift</em> 将确保你正确地捕获错误。</p><p>所以，当你传递一个会抛出异常的闭包的时候，你会得到你想从 <em>Swift</em> 得到的所有安全，但是当你传递一个不会抛出异常的闭包的时候，你不需要添加无意义的<code>try/catch</code>代码。</p><p>有了这些知识，再看看短路逻辑<code>&amp;&amp;</code>运算符的代码，从 <em>Swift</em> 源代码中获取：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Bool</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> @<span class="token function">autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> lhs <span class="token operator">?</span> <span class="token keyword">try</span> <span class="token function">rhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><p>现在你应该能够准确地分解它的作用：<code>&amp;&amp;</code>的右边是一个自动闭包，因此只有当左边的值为<code>true</code>时才会执行它。<code>rhs</code>被标记为会抛出异常(即使可能没有)，而整个函数被标记为<code>rethrow</code>，以便调用者仅在必要时才需要使用<code>try/catch</code>。</p><p>我希望你能同意 <em>Swift</em> 的错误处理方法是非常漂亮的：你越深入研究它，你就越能欣赏它的精妙之处。</p><h2 id="try-vs-try-vs-try"><a href="#try-vs-try-vs-try" class="headerlink" title="try vs try? vs try!"></a>try vs try? vs try!</h2><p><em>Swift</em> 的错误处理有三种形式，它们都有各自的用途。在调用被标记为<code>throws</code>函数时都会用到，但其含义有细微的不同：</p><ol><li>当使用<code>try</code>时，必须有一个<code>catch</code>块来处理发生的任何错误。</li><li>当使用<code>try?</code>时，如果抛出任何错误，你调用的函数将自动返回<code>nil</code>。你不需要捕获它们，但是你需要知道你的返回值是可选的。</li><li>当使用<code>try!</code>，如果抛出任何错误，该函数将使应用程序崩溃。</li></ol><p>我对它们进行了编号，因为这是你应该使用它们的顺序：到目前为止，通常<code>try</code>是最常见的，其行为就像我们目前看到的那样；<code>try?</code>是一种安全而有用的后备方法，如果使用得当，将大大提高代码的可读性；<code>try!</code>意思是“抛出错误不太可能——或者不太受欢迎——以至于我愿意接受崩溃”，这是不常见的。</p><p>现在，你可能想知道为什么要<code>try!</code>甚至存在：如果你确定它不会抛出错误，那么为什么函数一开始就标记为<code>throws</code>呢？那么，考虑一下从应用程序包中读取文件的代码。如果文件不存在或不可读，从字符串内容加载文件可能会引发错误，但如果出现这种情况，则你的应用显然处于非常坏的状态——强制崩溃很可能是理想的结果，而不是允许用户继续使用损坏的应用。选择权在你。</p><p>在这三种方法中，只有常规的<code>try</code>需要一个<code>do/catch</code>块，所以如果你正在寻找简洁的代码，你可能想要使用<code>try?</code>。我已经介绍过<code>try</code>了，<code>try!</code>和<code>try?</code>实际上是一样的，只是你得到的不是<code>nil</code>返回值，而是崩溃，所以我将重点在这里使用<code>try?</code>。</p><p>用<code>try?</code>表示安全地展开其可选返回值，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> savedText <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> <span class="token function">String</span><span class="token punctuation">(</span>contentsOfFile<span class="token punctuation">:</span> <span class="token string">"saved.txt"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">loadText</span><span class="token punctuation">(</span>savedText<span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token function">showFirstRunScreen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>你也可以使用空值合并操作符<code>??</code>。若返回<code>nil</code>，则使用默认值，从而完全消除可选性：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> savedText <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">try</span><span class="token operator">?</span> <span class="token function">String</span><span class="token punctuation">(</span>contentsOfFile<span class="token punctuation">:</span> <span class="token string">"saved.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Hello, world!"</span></code></pre><p>在极少数情况下，我使用<code>try?</code>有点像 <em>UDP</em> ：试试这个，但我不在乎它是否失败。互联网背后最重要的两种协议是 <em>TCP</em> 和 <em>UDP<em>。</em>TCP</em> 保证所有的数据包都会到达，并且会一直尝试重新发送，直到某个时间过期；例如，它用于下载，因为如果缺少 <em>ZIP</em> 文件的一部分，那么就什么都没有了。</p><p><em>UDP</em> 只发送一次所有的数据包，并希望是最好的：如果它们到达，很好；如果不是，就等到下一个到达。<em>UDP</em> 对于视频流之类的事情很有用，在视频流中，你不在乎是否丢失了一秒的实时视频流，更重要的是新视频不断出现。</p><p>所以，<code>try?</code>可以像 <em>UDP</em> 一样使用：如果你不关心返回值是什么，而只想尝试做一些事情，那么<code>try?</code>适合你：</p><pre class=" language-swift"><code class="language-swift"><span class="token number">_</span> <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> string<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>toFile<span class="token punctuation">:</span> somePathHere<span class="token punctuation">,</span> atomically<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token builtin">Encoding</span><span class="token punctuation">.</span>utf8<span class="token punctuation">)</span></code></pre><h2 id="断言-Assertions"><a href="#断言-Assertions" class="headerlink" title="断言(Assertions)"></a>断言(Assertions)</h2><p>断言允许你声明某些条件必须为真。这个条件由你决定，可以像你希望的那样复杂，但是如果它的计算结果为<code>false</code>，你的程序将立即停止。断言在 <em>Swift</em> 中被巧妙地设计，以至于阅读其源代码是一项有价值的练习。</p><p>在 <em>Xcode</em> 中编写断言时，代码提示将为你提供两个选项：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">assert</span><span class="token punctuation">(</span>condition<span class="token punctuation">:</span> <span class="token builtin">Bool</span><span class="token punctuation">)</span><span class="token function">assert</span><span class="token punctuation">(</span>condition<span class="token punctuation">:</span> <span class="token builtin">Bool</span><span class="token punctuation">,</span> message<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span></code></pre><p>在第一个选项中，你需要提供要测试的条件；在第二个选项中，如果条件的计算结果为<code>false</code>，你还需要提供要显示的消息。在下面的代码中，第一个断言将计算为<code>true</code>，因此不会发生任何事情；在第二个断言中，它将失败，因为条件为<code>false</code>，因此将打印消息：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Danger, Will Robinson: mathematics failure!"</span><span class="token punctuation">)</span></code></pre><p>很明显，断言基本算法并没有多大用处，因此你通常会编写如下代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> success <span class="token operator">=</span> <span class="token function">runImportantOperation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">assert</span><span class="token punctuation">(</span>success <span class="token operator">==</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token string">"Important operation failed!"</span><span class="token punctuation">)</span></code></pre><p>断言在编写复杂的应用程序时非常有用，因为你可以将它们分散到整个代码中，以确保一切正常。你可以想测试多少就测试多少，这意味着你的应用程序中出现了任何意想不到的状态——当你想知道某些变量是如何设置的？—— 在开发早期就被捕获。</p><p>要了解断言如何工作，请查看 <em>Swift</em> 源代码中的实际类型签名：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">func</span> <span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">_</span> condition<span class="token punctuation">:</span> @<span class="token function">autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span><span class="token punctuation">,</span> <span class="token number">_</span> message<span class="token punctuation">:</span> @<span class="token function">autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">:</span> <span class="token builtin">StaticString</span> <span class="token operator">=</span> #file<span class="token punctuation">,</span> line<span class="token punctuation">:</span> <span class="token builtin">UInt</span> <span class="token operator">=</span> #line<span class="token punctuation">)</span></code></pre><p>最后两个参数是 <em>Swift</em> 编译器提供的默认值，你不太可能想要更改它们：<code>#file</code>替换为当前文件的名称，<code>#line</code>替换为触发断言的代码行号。这些参数以默认值的形式传入(而不是在函数中指定)，以便 <em>Swift</em> 使用调用站点的文件名和行号，而不是<code>assert()</code>中的某些行。</p><p>前两个参数更有趣：条件参数和消息参数都使用<code>@autoclosure</code>，这意味着它们不会立即执行。这很重要，因为内部 <em>Swift</em> 只有在调试模式下才会执行断言。这意味着你可以在应用程序中断言数百次甚至数千次，但所有这些工作只有在调试时才能完成。当 <em>Swift</em> 编译器以 <em>Release</em> 模式运行时，将跳过此工作。</p><p>这里是<code>assert()</code>的主体，直接来自 <em>Swift</em> 源代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token function">_isDebugAssertConfiguration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">_branchHint</span><span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> expected<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">_assertionFailed</span><span class="token punctuation">(</span><span class="token string">"assertion failed"</span><span class="token punctuation">,</span> <span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> file<span class="token punctuation">,</span> line<span class="token punctuation">,</span> flags<span class="token punctuation">:</span> <span class="token function">_fatalErrorFlags</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>带下划线前缀的函数是内部函数，但是你应该能够猜到它们的作用：</p><ul><li><code>_isDebugAssertConfiguration()</code>如果未处于调试模式，则返回<code>false</code>。这就是在为发布而构建时导致断言消失的原因。</li><li><code>!_branchHint(condition(),expected:true)</code>运行<code>@autoclosure</code>创建的条件闭包。它告诉编译器期望条件计算成功（大多数情况下应该是这样），这有助于优化代码。这只会影响调试，但有助于你的断言更快地运行。</li><li>如果在调试模式下，调用<code>condition()</code>返回<code>false</code>，则调用<code>_assertionfailed()</code>终止程序。此时，将调用<code>message()</code>闭包以打印有用的错误。</li></ul><p><code>@autoclosure</code>的使用非常适合这种情况，因为只有在调试模式下才会运行它。但是你可能想知道为什么<code>message</code>参数也是一个自动闭包—它不只是一个字符串吗?这就是<code>assert()</code>变得非常聪明的地方：因为<code>message</code>是一个闭包，所以你可以在最终返回字符串之前运行任何其他代码，除非断言失败，否则不会调用任何代码。</p><p>最常见的用法是在使用日志系统时：在将消息返回到<code>assert()</code>之前，消息闭包可以将错误写入日志。下面是一个简单的示例，它在返回消息之前将消息写到文件中—基本上只是一个传递，添加了一些额外的功能：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">saveError</span><span class="token punctuation">(</span>message<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> file<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> #file<span class="token punctuation">,</span> line<span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> #line<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>   <span class="token number">_</span> <span class="token operator">=</span> <span class="token keyword">try</span><span class="token operator">?</span> message<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>toFile<span class="token punctuation">:</span> pathToDebugFile<span class="token punctuation">,</span> atomically<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> encoding<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">.</span><span class="token builtin">Encoding</span><span class="token punctuation">.</span>utf8<span class="token punctuation">)</span>   <span class="token keyword">return</span> message<span class="token punctuation">}</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token function">saveError</span><span class="token punctuation">(</span>message<span class="token punctuation">:</span> <span class="token string">"Fatal error!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="先决条件-Preconditions"><a href="#先决条件-Preconditions" class="headerlink" title="先决条件(Preconditions)"></a>先决条件(Preconditions)</h2><p>只有当应用程序在调试模式下运行时才会检查断言，这在开发时很有用，但在发布模式下会自动停用断言。如果你希望在发布模式下进行断言(请记住，失败会导致你的应用程序立即终止)，那么应该使用<code>precondition()</code>。</p><p>它和<code>assert()</code>使用相同的参数，但编译方式不同：如果使用<code>-onone</code>或<code>-o</code>（无优化或标准优化）生成，则失败的先决条件将导致应用程序终止。如果使用<code>-ounchecked</code>（最快的优化级别）构建，则仅会忽略前提条件。如果你使用的是 <em>Xcode</em>，这意味着 <strong><em>Disable Safety Checks</em></strong>选项设置为 <strong><em>Yes</em></strong>。</p><p>就像使用<code>try!</code>一样，有一个很好的理由让你可能想在发布模式下崩溃你的应用程序：如果某个东西出了致命的错误，表明你的应用程序处于不稳定、未知、甚至可能是危险的状态，那么与其继续下去，冒着严重数据丢失的风险，不如出手相救。</p><p>在关于运算符重载的一章中，我对<code>*</code>运算符进行了修改，它允许我们将两个数组相乘：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token operator">*</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token keyword">guard</span> lhs<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">==</span> rhs<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> lhs <span class="token punctuation">}</span>   <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> int<span class="token punctuation">)</span> <span class="token keyword">in</span> lhs<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>int <span class="token operator">*</span> rhs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> result<span class="token punctuation">}</span></code></pre><p>如您所见，该函数以一个<code>guard</code>开始，以确保两个数组的大小完全相同——如果不是，我们只返回左侧的操作数。在许多情况下，这是安全的编程，但也有可能，如果我们的程序最终有两个不同大小的数组，那么严重的问题已经发生，我们应该停止执行。在这种情况下，使用<code>precondition()</code>可能更好：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token operator">*</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token function">precondition</span><span class="token punctuation">(</span>lhs<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">==</span> rhs<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">,</span> <span class="token string">"Arrays were not the same size"</span><span class="token punctuation">)</span>   <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> int<span class="token punctuation">)</span> <span class="token keyword">in</span> lhs<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>int <span class="token operator">*</span> rhs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> result<span class="token punctuation">}</span><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token keyword">let</span> c <span class="token operator">=</span> a <span class="token operator">*</span> b</code></pre><p>记住，启用<code>-Ounchecked</code>将有效地禁用你的先决条件，但它也禁用其他边界检查——这就是为什么它这么快的原因!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pro Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Pro Swift </tag>
            
            <tag> 错误处理 </tag>
            
            <tag> 断言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第四章 函数(Functions)</title>
      <link href="/2019/09/06/pro-swift-yi-wen/chapter4-functions/"/>
      <url>/2019/09/06/pro-swift-yi-wen/chapter4-functions/</url>
      
        <content type="html"><![CDATA[<p>当编写代码在两个数字之间进行插值时，很容易默认为线性插值。然而，在两个值之间平稳过渡通常会更好。所以我的建议是避免步进，并使用函数(如<code>smooterstep()</code>)进行插值：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">smootherStep</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token builtin">CGFloat</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">CGFloat</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> x <span class="token operator">=</span> value <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> value <span class="token operator">></span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token punctuation">:</span> value   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">6</span> <span class="token operator">-</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>—— <em>Simon Gladman (@flexmonkey), Swift</em> 版 <em>Core Image</em> 的作者</p><h3 id="可变参数函数（Variadic-functions）"><a href="#可变参数函数（Variadic-functions）" class="headerlink" title="可变参数函数（Variadic functions）"></a>可变参数函数（Variadic functions）</h3><p>可变参数函数是具有不确定性的函数，这是一种奇特的说法，就是说它们接受的参数和发送的参数一样多。在一些基本函数(甚至<code>print()</code>)中都使用了这种方法，以使代码编写更简单、更安全。</p><p>让我们使用<code>print()</code>，因为它是一个你很熟悉的函数。你习惯看到这样的代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"I'm Commander Shepard and this is my favorite book"</span><span class="token punctuation">)</span></code></pre><p>但是<code>print()</code>是一个可变参数函数，这意味着您可以传递任意数量的要打印的内容：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span></code></pre><p>这将与为每个数字调用一次<code>print()</code>产生不同的输出：使用一次性调用将在一行中打印所有数字，而使用多次调用将逐行打印数字。</p><p>一旦添加了可选的额外参数：<code>separator</code>和<code>terminator</code>，<code>print()</code>的可变参数特性将变得更加有用。第一个参数在传递的每个值之间放置一个字符串，第二个参数在打印完所有值后放置一个字符串。例如，这将打印 “<em>1、2、3、4、5、6 !</em> ”：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> separator<span class="token punctuation">:</span> <span class="token string">", "</span><span class="token punctuation">,</span> terminator<span class="token punctuation">:</span> <span class="token string">"!"</span><span class="token punctuation">)</span></code></pre><p>这就是如何调用可变参数函数。现在我们来谈谈如何制作它们，我认为你会发现这在 <em>Swift</em> 中相当巧妙。</p><p>考虑下面的代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> total <span class="token operator">=</span> <span class="token number">0</span>   <span class="token keyword">for</span> number <span class="token keyword">in</span> numbers <span class="token punctuation">{</span>      total <span class="token operator">+</span><span class="token operator">=</span> number   <span class="token punctuation">}</span>   <span class="token keyword">return</span> total<span class="token punctuation">}</span><span class="token function">add</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>该函数接受一个整数数组，然后将每个数字相加，得到一个总数。有更有效的方法可以做到这一点，但这不是本章的重点!</p><p>要使该函数拥有可变参数，即它接受任何数量的单个整数而不是单个数组，需要进行两次更改。首先，我们需要将参数写成<code>Int...</code>，而不是写成<code>[int]</code>。其次，我们不需要这样调用<code>add(numbers: [1, 2, 3, 4, 5])</code>，而是应该这样调用<code>add(numbers: 1, 2, 3, 4, 5)</code>。</p><p>就是这样。最后的代码是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> total <span class="token operator">=</span> <span class="token number">0</span>   <span class="token keyword">for</span> number <span class="token keyword">in</span> numbers <span class="token punctuation">{</span>      total <span class="token operator">+</span><span class="token operator">=</span> number   <span class="token punctuation">}</span>   <span class="token keyword">return</span> total<span class="token punctuation">}</span><span class="token function">add</span><span class="token punctuation">(</span>numbers<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span></code></pre><p>你可以将可变参数放在函数的参数列表中的任何位置，但是每个函数只能有一个可变参数。</p><h3 id="操作符重载（Operator-overloading）"><a href="#操作符重载（Operator-overloading）" class="headerlink" title="操作符重载（Operator overloading）"></a>操作符重载（Operator overloading）</h3><p>这是一个人们既爱又恨的话题。操作符重载是实现你自己的操作符甚至调整现有操作符(如<code>+</code>或 <code>*</code>)的能力。</p><p>使用操作符重载的主要原因是它提供了非常清晰、自然和富有表现力的代码。你已经理解了 <em>5 + 5 = 10</em> ，因为你了解基础数学，所以允许 <em>myShoppingList + yourShoppingList</em> 是一个逻辑扩展，即将两个自定义结构相加。</p><p>操作符重载有几个缺点。首先，它的含义可能是不透明的：如果我说<code>henrytheeight + AnneBoleyn</code>，结果是一对幸福的夫妇(暂时!)、一个未来伊丽莎白女王( <em>Queen Elizabeth</em> )形状的婴儿，还是某个四肢相连的人类?</p><p>其次，它没有做任何方法不能做的事情：<code>HenryTheEighth.marry(AnneBoleyn)</code>也会有同样的结果，而且明显更清晰。第三，它隐藏了复杂性：<em>5 + 5</em> 是一个微不足道的操作，但是 <em>Person + Person</em> 可能涉及到安排一个仪式、找到一件婚纱等等。</p><p>第四，可能也是最严重的，操作符重载可能会产生意想不到的结果，特别是因为你可以不受惩罚地调整现有的操作符。</p><h3 id="基础操作符-The-basics-of-operators"><a href="#基础操作符-The-basics-of-operators" class="headerlink" title="基础操作符(The basics of operators)"></a>基础操作符(The basics of operators)</h3><p>为了演示操作符重载是多么令人困惑，我想先给出一个重载<code>==</code>操作符的基本示例。考虑以下代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Match!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No match!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>就像你想得那样，它会打印 “<em>Match!</em> ” 因为 <em>4</em> 总是等于 <em>4</em>。还是……？</p><p>进入操作符重载。只需三行代码，我们就可以对几乎所有应用程序造成严重损害：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token operator">==</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">4</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Match!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No match!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>当代码运行时，它将输出 “ <em>No match !</em> ”，因为我们重载了<code>==</code>操作符，所以它总是返回<code>false</code>。正如你所看到的，函数的名称是操作符本身，即<code>func ==</code>，所以你要修改的内容非常清楚。你还可以看到，这个函数期望接收两个整数(左边和右边分别是<code>lhs</code>和<code>rhs</code>)，并返回一个布尔值，该值报告这两个数字是否相等。</p><p>除了完成实际工作的函数外，操作符还具有优先级和关联性，这两者都会影响操作的结果。当多个运算符一起使用而没有括号时，<em>Swift</em> 首先使用优先级最高的运算符——你可能学习过PEMDAS(括号、指数、乘除、加减)、<em>BODMAS</em> 或类似的运算符，取决于你在哪里上学。如果仅凭优先级不足以决定操作的顺序，则使用结合律。</p><p><em>Swift</em> 允许你控制优先级和关联性。现在让我们尝试一个实验：下面操作的结果是什么？</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">1</span></code></pre><p>根据 <em>PEMDAS</em> ，应该首先执行乘法(<em>5 * 10 = 50</em> )，然后执行加法(<em>50 + 1 = 51</em> )，因此结果是 <em>51</em>  。这个优先级被直接写入了 <em>Swift</em> ——以下是来自 <em>Swift</em>  标准库的确切代码：</p><pre class=" language-swift"><code class="language-swift">precedencegroup <span class="token builtin">AdditionPrecedence</span> <span class="token punctuation">{</span>   <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>   higherThan<span class="token punctuation">:</span> <span class="token builtin">RangeFormationPrecedence</span><span class="token punctuation">}</span>precedencegroup <span class="token builtin">MultiplicationPrecedence</span> <span class="token punctuation">{</span>   <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>   higherThan<span class="token punctuation">:</span> <span class="token builtin">AdditionPrecedence</span><span class="token punctuation">}</span><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">*</span> <span class="token punctuation">:</span> <span class="token builtin">MultiplicationPrecedence</span><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">+</span> <span class="token punctuation">:</span> <span class="token builtin">AdditionPrecedence</span><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">-</span> <span class="token punctuation">:</span> <span class="token builtin">AdditionPrecedence</span></code></pre><p>这将声明两个操作符优先组，然后声明 <code>*</code>、<code>+</code> 和 <code>-</code> 操作符位于这些组中。你可以看到，<code>MultiplicationPrecedence</code>被标记为高于<code>AdditionPrecedence</code>，这就是 <code>*</code> 在 <code>+</code> 之前被计算的原因。</p><p>这三个操作符被称为<strong>中缀操作符</strong>，因为它们被放在两个操作数中，即 <em>5 + 5</em> ，而不是像<code>!</code>这样的前缀操作符，例如:<code>!loggedIn</code>。</p><p><em>Swift</em> 允许我们通过将现有操作符分配给新的组来重新定义它们的优先级。如果需要，可以创建自己的优先组，或者重用现有的优先组。</p><p>在上面的代码中，你可以看到顺序是乘法优先级(用于<code>*</code>、<code>/</code>、<code>%</code>和更多)，然后是加法优先级(用于<code>+</code>、<code>-</code>、<code>|</code>和更多)，然后是范围优先级(用于<code>...</code>和 <code>..&lt;</code>。)</p><p>在我们的小算术中，我们可以通过像这样重写<code>*</code>运算符来引起各种奇怪的行为：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">*</span> <span class="token punctuation">:</span> <span class="token builtin">RangeFormationPrecedence</span></code></pre><p>这就重新定义了<code>*</code>的优先级比<code>+</code>低，这意味着这段代码现在将返回<code>55</code>：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> <span class="token number">1</span></code></pre><p>这是与之前相同的代码行，但现在将执行加法(<em>10 + 1 = 11</em>)，然后乘法(<em>5 * 11</em>) 得到 <em>55</em>。</p><p>当两个操作符具有相同的优先级时，就会发挥结合律的作用。例如，考虑以下问题:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">-</span> <span class="token number">5</span> <span class="token operator">-</span> <span class="token number">1</span></code></pre><p>再看看 <em>Swift</em> 自己的代码是如何声明 <em>AdditionPrecedence</em> 组的，<code>-</code>运算符属于这个组：</p><pre class=" language-swift"><code class="language-swift">precedencegroup <span class="token builtin">AdditionPrecedence</span> <span class="token punctuation">{</span>   <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>   higherThan<span class="token punctuation">:</span> <span class="token builtin">RangeFormationPrecedence</span><span class="token punctuation">}</span></code></pre><p>如你所见，它被定义为具有左结合性，这意味着 <em>10 - 5 - 1</em> 被执行为 <em>(10 - 5) - 1</em>，而不是 <em>10 - (5 - 1)</em>。</p><p>这种差别很细微，但很重要：除非我们改变它，否则 <em>10 - 5 - 1</em> 将得到 <em>4</em> 。当然，如果你想造成一点破坏，你可以这样做：</p><pre class=" language-swift"><code class="language-swift">precedencegroup <span class="token builtin">AdditionPrecedence</span> <span class="token punctuation">{</span>   <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">right</span>   higherThan<span class="token punctuation">:</span> <span class="token builtin">RangeFormationPrecedence</span><span class="token punctuation">}</span><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">-</span> <span class="token punctuation">:</span> <span class="token builtin">AdditionPrecedence</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">-</span> <span class="token number">5</span> <span class="token operator">-</span> <span class="token number">1</span></code></pre><p>这将修改现有的加法优先组，然后随着改变被更新，式子将被解释为 <em>10 - (5 - 1)</em>，即结果等于 <em>6</em>。</p><h3 id="添加到现有操作符-Adding-to-an-existing-operator"><a href="#添加到现有操作符-Adding-to-an-existing-operator" class="headerlink" title="添加到现有操作符(Adding to an existing operator)"></a>添加到现有操作符(Adding to an existing operator)</h3><p>现在你已经了解了操作符的工作原理，让我们修改<code>*</code>操作符，使它可以像这样对整数数组进行乘法操作：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span></code></pre><p>完成之后，将返回一个包含<code>[1,4,9]</code>的新数组，即<code>1x1</code>, <code>2x2</code>和<code>3x3</code>。</p><p><code>*</code>操作符已经存在，所以我们不需要声明它。相反，我们只需要创建一个新的<code>func *</code>，它接受我们的新数据类型。这个函数将创建一个新数组，该数组由所提供的两个数组中的每一项相乘组成。这是代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token operator">*</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token keyword">guard</span> lhs<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">==</span> rhs<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> lhs <span class="token punctuation">}</span>   <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>index<span class="token punctuation">,</span> int<span class="token punctuation">)</span> <span class="token keyword">in</span> lhs<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      result<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>int <span class="token operator">*</span> rhs<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> result<span class="token punctuation">}</span></code></pre><p>注意，我在开头添加了一个<code>guard</code>，以确保两个数组包含相同数量的项。</p><p>因为<code>*</code>操作符已经存在，所以重要的是<code>lhs</code>和<code>rhs</code>参数，它们都是整数数组：当两个整数数组相乘时，这些参数确保选择这个新函数。</p><h3 id="添加一个新的操作符（Adding-a-new-operator）"><a href="#添加一个新的操作符（Adding-a-new-operator）" class="headerlink" title="添加一个新的操作符（Adding a new operator）"></a>添加一个新的操作符（Adding a new operator）</h3><p>当你添加一个新的操作符时，你需要提供足够的 <em>Swift</em> 信息来使用它。至少需要指定新操作符的位置(前缀、后缀或中缀)，但如果不指定优先级或关联性 <em>Swift</em> 将提供默认值，使其成为低优先级、非关联操作符。</p><p>让我们添加一个新的操作符<code>**</code>，它返回一个值的幂。也就是说，<em>2 ** 4</em> 应该等于 <em>2 * 2 * 2 * 2</em> ，即 <em>16</em>。我们将使用<code>pow()</code>函数，所以你需要导入<code>Foundation</code>框架：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span></code></pre><p>一旦完成，我们需要告诉 <em>Swift</em>  <code>**</code>将是一个中缀操作符，因为我们将在其左侧有一个操作数，在其右侧有另一个操作数：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">*</span><span class="token operator">*</span></code></pre><p>它没有指定优先级或关联，因此将使用默认值。</p><p>最后，新的<code>**</code>函数本身。我已经让它接受双精度值以获得最大的灵活性，<code>Swift</code>足够聪明，当与这个操作符一起使用时，可以推断<code>2</code>和<code>4</code>是双精度值：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token function">pow</span><span class="token punctuation">(</span>lhs<span class="token punctuation">,</span> rhs<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如你所见，由于<code>pow()</code>，函数本身非常简单。自己试试：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token number">4</span></code></pre><p>到目前为止，一切顺利。然而，像这样的表达是行不通的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token number">2</span></code></pre><p>事实上，甚至像这样的东西也不会奏效：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">2</span></code></pre><p>这是因为我们使用的是默认优先级和结合性。为了解决这个问题，我们需要决定与其他操作符相比<code>**</code>应该排在什么位置，为此，你可以返回到 <em>PEMDAS</em> (它是 <em>E</em> !)，或者查看其他语言的功能。例如，<em>Haskell</em> 把它放在乘法和除法之前，在<em>PEMDAS</em> 之后。<em>Haskell<em>还声明幂运算右结合性，这意味着 *4 *</em> 3 ** 2</em> 将被解析为 <em>4 *<em>(3 *</em> 2)</em> 。</p><p>我们可以使我们自己的<code>**</code>操作符的行为相同的方式，修改其声明如下:</p><pre class=" language-swift"><code class="language-swift">precedencegroup <span class="token builtin">ExponentiationPrecedence</span> <span class="token punctuation">{</span>   higherThan<span class="token punctuation">:</span> <span class="token builtin">MultiplicationPrecedence</span>   <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">right</span><span class="token punctuation">}</span><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">:</span> <span class="token builtin">ExponentiationPrecedence</span></code></pre><p>有了这个更改，你现在可以在同一个表达式中使用<code>**</code>两次，还可以将它与其他操作符组合使用——这样做会更好!</p><h3 id="修改现有的操作符-Modifying-an-existing-operator"><a href="#修改现有的操作符-Modifying-an-existing-operator" class="headerlink" title="修改现有的操作符(Modifying an existing operator)"></a>修改现有的操作符(Modifying an existing operator)</h3><p>现在来看一些更复杂的东西：修改现有的操作符。我选择了一个稍微复杂一点的例子，因为如果你能看到我在这里解决它，我希望它能帮助你解决你自己的操作符重载问题。</p><p>我要修改的运算符是<code>...</code>，它已经作为闭区间运算符存在。所以，你可以写<code>1...10</code>，然后得到覆盖 <em>1</em> 到<em>10</em> 的范围 。在默认情况下这是一个中缀操作符，范围的低端在左侧，高端在右侧，但我要修改它，以便它还接受左侧的范围和右侧的另一个整数，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> range <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1</span></code></pre><p>当代码运行时，它将返回一个数组，其中包含数字<code>1、2、3、4、5、6、6、7、8、9、10、9、8、7、6、5、4、3、2、1</code>——它先递增再递减。这是可能的，因为运算符出现了两次：第一次它将看到<code>1...10</code>，这是一个闭合范围运算符，第二次它将看到<code>CountableClosedRange&lt;Int&gt;...1</code>，这将是我们的新操作。在此函数中，<code>CountableClosedRange&lt;Int&gt;</code>是左侧操作数，而<code>Int 1</code>是右侧操作数。</p><p>新<code>...</code>函数需要做两件事：</p><ol><li>计算一个新的区间，从右边的整数到左边区间的最高点，然后反转这个区间。</li><li>将左边的区间追加到新创建的递减区间，并作为函数的结果返回该区间。</li></ol><p>在代码中，它看起来是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">CountableClosedRange</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> downwards <span class="token operator">=</span> <span class="token punctuation">(</span>rhs <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> lhs<span class="token punctuation">.</span>upperBound<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span> <span class="token operator">+</span> downwards<span class="token punctuation">}</span></code></pre><p>如果你尝试使用该代码，你将看到它无法工作—至少目前还不能。要知道为什么，看看Swift对<code>...</code>操作符的定义：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">infix</span> <span class="token keyword">operator</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">:</span> <span class="token builtin">RangeFormationPrecedence</span>precedencegroup <span class="token builtin">RangeFormationPrecedence</span> <span class="token punctuation">{</span>   higherThan<span class="token punctuation">:</span> <span class="token builtin">CastingPrecedence</span><span class="token punctuation">}</span></code></pre><p>现在再来看看我们的代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> range <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1</span></code></pre><p>你可以看到我们用到了<code>...</code>操作符两次，这意味着 <em>Swift</em> 需要知道我们想要<code>(1...10)...1</code>还是<code>1...(10...1)</code>。正如你在上面看到的，<em>Swift</em> 的定义的<code>...</code>操作符没有提到它的结合律，所以 <em>Swift</em> 不知道在这种情况下该怎么做。所以，就目前情况来看，我们的新操作符只能处理这样的代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> range <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1</span></code></pre><p>如果我们想要相同的行为而不需要用户添加括号，我们需要告诉 <em>Swift</em> <code>...</code>操作符有左结合性，像这样：</p><pre class=" language-swift"><code class="language-swift">precedencegroup <span class="token builtin">RangeFormationPrecedence</span> <span class="token punctuation">{</span>   <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>   higherThan<span class="token punctuation">:</span> <span class="token builtin">CastingPrecedence</span><span class="token punctuation">}</span><span class="token keyword">infix</span> <span class="token keyword">operator</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">:</span> <span class="token builtin">RangeFormationPrecedence</span></code></pre><p>就是这样：现在代码在没有括号的情况下可以正常工作，并且我们有了一个有用的新操作符。不要忘记，在 <em>Playground</em> ，你的代码顺序很重要——你的最终代码应该是这样的：</p><pre class=" language-swift"><code class="language-swift">precedencegroup <span class="token builtin">RangeFormationPrecedence</span> <span class="token punctuation">{</span>   <span class="token keyword">associativity</span><span class="token punctuation">:</span> <span class="token keyword">left</span>   higherThan<span class="token punctuation">:</span> <span class="token builtin">CastingPrecedence</span><span class="token punctuation">}</span><span class="token keyword">infix</span> <span class="token keyword">operator</span>  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">:</span> <span class="token builtin">RangeFormationPrecedence</span><span class="token keyword">func</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">CountableClosedRange</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> downwards <span class="token operator">=</span> <span class="token punctuation">(</span>rhs <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> lhs<span class="token punctuation">.</span>upperBound<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reversed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">return</span> <span class="token function">Array</span><span class="token punctuation">(</span>lhs<span class="token punctuation">)</span> <span class="token operator">+</span> downwards<span class="token punctuation">}</span><span class="token keyword">let</span> range <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">10</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1</span><span class="token function">print</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span></code></pre><h2 id="闭包-Closures"><a href="#闭包-Closures" class="headerlink" title="闭包(Closures)"></a>闭包(Closures)</h2><p>和元组一样，闭包在 <em>Swift</em> 中是特有的：全局函数是闭包，嵌套函数是闭包，<code>sort()</code>和<code>map()</code>等函数方法接受闭包，惰性属性使用闭包，这只是冰山一角。在你的 <em>Swift</em> 开发职业生涯中，你将需要使用闭包，如果你想晋升到高级开发职位，那么你也需要轻松地创建闭包。</p><p>我知道有些人对闭包有不同寻常的理解，所以让我们从一个简单的定义开始：闭包是一段代码，可以像变量一样传递和存储，它还能够捕获它使用的任何值。这种捕获确实使闭包难以理解，所以我们稍后再讨论它。</p><h3 id="创建简单的闭包-Creating-simple-closures"><a href="#创建简单的闭包-Creating-simple-closures" class="headerlink" title="创建简单的闭包(Creating simple closures)"></a>创建简单的闭包(Creating simple closures)</h3><p>让我们创建一个简单的闭包来让事情运行起来：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> greetPerson <span class="token operator">=</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello there!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>它创建一个名为<code>greetPerson</code>的闭包，然后可以像函数一样使用：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">greetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>因为闭包是第一类数据类型——也就是说，就像整数、字符串和其他类型一样——所以你可以复制它们并将它们用作其他函数的参数。以下是实际复制：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> greetCopy <span class="token operator">=</span> greetPerson<span class="token function">greetCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>复制闭包时，请记住闭包是引用类型——这两个“副本”实际上指向同一个共享闭包。</p><p>要将闭包作为参数传递给函数，请指定闭包自己的参数列表并将返回值作为其数据类型。也就是说，你不需要编写<code>param: String</code>，而是编写类似<code>param: () -&gt; Void</code>这样的东西来接受没有参数且没有返回值的闭包。是的，<code>-&gt; Void</code>是必需的，否则<code>param:()</code>将意味着一个空元组。</p><p>如果我们想将<code>greetPerson</code>闭包传递给一个函数并在那里调用它，我们将使用如下代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">runSomeClosure</span><span class="token punctuation">(</span><span class="token number">_</span> closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">runSomeClosure</span><span class="token punctuation">(</span>greetPerson<span class="token punctuation">)</span></code></pre><p>为什么需要闭包？在那个例子中不是，但是如果我们想在 <em>5</em> 秒后调用闭包呢？或者我们只是想偶尔调用它？或者是否满足某些条件？这就是闭包变得有用的地方:它们是一些功能，你的应用程序可以将它们存储起来，以便以后需要时使用。</p><p>闭包开始变得混乱的地方是当它们接受自己的参数时，部分原因是它们的参数列表放在一个不寻常的位置，还因为这些闭包的类型语法可能看起来非常混乱!</p><p>首先：如何使闭包接受参数。要做到这一点，请在闭包的括号内写入参数列表，然后输入关键字<code>in</code>：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> greetPerson <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token keyword">in</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">greetPerson</span><span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">)</span></code></pre><p>如果需要，还可以在这里指定捕获列表。这是最常用的，以避免<code>self</code>引用循环，通过使它<code>unowned</code>，像这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> greetPerson <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token keyword">unowned</span> <span class="token keyword">self</span><span class="token punctuation">]</span> <span class="token keyword">in</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">greetPerson</span><span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">)</span></code></pre><p>现在，讨论如何使用闭包将参数传递给函数。这很复杂，有两个原因：1)它可能看起来像一个冒号和括号的海洋，2)调用约定根据你做的事情而变化。</p><p>让我们回到<code>runSomeClosure()</code>函数。为了让它接受一个参数——一个本身接受一个参数的闭包——我们需要这样定义它：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">runSomeClosure</span><span class="token punctuation">(</span><span class="token number">_</span> closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span></code></pre><p>闭包是一个函数，它接受一个字符串，但什么也不返回。这是一个新的功能：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> greetPerson <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token keyword">in</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">runSomeClosure</span><span class="token punctuation">(</span><span class="token number">_</span> closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">closure</span><span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">runSomeClosure</span><span class="token punctuation">(</span>greetPerson<span class="token punctuation">)</span></code></pre><h3 id="闭包捕获（Closure-capturing）"><a href="#闭包捕获（Closure-capturing）" class="headerlink" title="闭包捕获（Closure capturing）"></a>闭包捕获（Closure capturing）</h3><p>我已经讨论了闭包是如何作为引用类型的，它对捕获的值有巧妙的含义：当两个变量指向同一个闭包时，它们都使用相同的捕获数据。</p><p>让我们从基础开始：当一个闭包引用一个值时，它需要确保该值在运行闭包时仍然存在。这看起来像是闭包在复制数据，但实际上它比这更微妙。这个过程称为捕获，它允许闭包引用和修改它引用的值，即使原始值不再存在。</p><p>区别很重要：如果闭包复制了它的值，那么就会应用值类型语义，并且闭包内的值类型的任何更改都将发生在一个惟一的副本上，不会影响原来的调用方。相反，闭包捕获数据。</p><p>我知道这一切听起来都是假设，所以让我给你一个实际的例子：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">testCapture</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>   <span class="token keyword">return</span> <span class="token punctuation">{</span>      counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Counter is now <span class="token interpolation"><span class="token delimiter variable">\(</span>counter<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> greetPerson <span class="token operator">=</span> <span class="token function">testCapture</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">greetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">greetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">greetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> greetCopy <span class="token operator">=</span> greetPerson<span class="token function">greetCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">greetPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">greetCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>这段代码声明了一个名为<code>testCapture()</code>的函数，该函数的返回值为<code>()-&gt; Void</code>，即它返回一个不接受任何参数且什么也不返回的函数。在<code>testCapture()</code>中，我创建了一个名为<code>counter</code>的新变量，初始值为<code>0</code>。但是，函数内的变量没有发生任何变化。相反，它返回一个闭包，该闭包将<code>counter</code>加 <em>1</em> 并打印出它的新值。它不调用那个闭包，它只返回它。</p><p>有趣的地方是函数之后：<code>greetPerson</code>被设置为<code>testCapture()</code>返回的函数，它被调用了三次。该闭包引用了在<code>testCapture()</code>中创建的<code>counter</code>值，现在显然超出了范围，因为该函数已经完成。因此，<em>Swift</em> 捕捉到了这个值：这个闭包现在有了自己对<code>counter</code>的独立引用，可以在调用它时使用。每次调用<code>greetPerson()</code>函数时，你将看到<code>counter</code>加 <em>1</em> 。</p><p>让事情变得加倍有趣的是<code>greetCopy</code>。这就是我所说的闭包是引用，并且使用相同的捕获数据。当调用<code>greetCopy()</code>时，它将增加与<code>greetPerson</code>相同的<code>counter</code>值，因为它们都指向相同的捕获数据。这意味着在一次又一次地调用闭包时<code>counter</code>值将从 <em>1</em> 增加到 <em>6</em>。这个怪癖我已经讲过两次了，所以如果它伤害了你的大脑，不要担心：它不会再被覆盖了!</p><h3 id="闭包简写语法-Closure-shorthand-syntax"><a href="#闭包简写语法-Closure-shorthand-syntax" class="headerlink" title="闭包简写语法(Closure shorthand syntax)"></a>闭包简写语法(Closure shorthand syntax)</h3><p>在讨论更高级的内容之前，我想快速地全面介绍一下闭包简写语法，这样我们就完全处于同一种思路。当你把一个内联闭包传递给一个函数时，<em>Swift</em> 有几种技术，所以你不需要写太多的代码。</p><p>为了给你提供一个好例子，我将使用数组的<code>filter()</code>方法，它接受一个带有一个字符串参数的闭包，如果该字符串应该在一个新的数组中，则返回<code>true</code>。下面的代码过滤一个数组，这样我们就得到了一个新的数组，每个人的名字都以<code>Michael</code>开头：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Michael Jackson"</span><span class="token punctuation">,</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> <span class="token string">"Michael Caine"</span><span class="token punctuation">,</span> <span class="token string">"Adele Adkins"</span><span class="token punctuation">,</span> <span class="token string">"Michael Jordan"</span><span class="token punctuation">]</span><span class="token keyword">let</span> result1 <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token keyword">in</span>   <span class="token keyword">if</span> name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>result1<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span></code></pre><p>从中可以看出<code>filter()</code>希望接收一个闭包，该闭包接受一个名为<code>name</code>的字符串参数，并返回<code>true</code>或<code>false</code>。然后闭包检查名称是否具有前缀 “ <em>Michael</em> ” 并返回一个值。</p><p><em>Swift</em> 知道传递给<code>filter()</code>的闭包必须接受一个字符串并返回一个布尔值，所以我们可以删除它，只使用一个变量的名称，该变量将用于对每个条目进行过滤：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result2 <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name <span class="token keyword">in</span>   <span class="token keyword">if</span> name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>接下来，我们可以直接返回<code>hasPrefix()</code>的结果，如下：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result3 <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name <span class="token keyword">in</span>   <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>尾随闭包允许我们删除一组括号，这总是受欢迎的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result4 <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> name <span class="token keyword">in</span>   <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>因为我们的闭包只有一个表达式——即现在我们已经删除了很多代码，它只做一件事——我们甚至不再需要<code>return</code>关键字。<em>Swift</em> 知道我们的闭包必须返回一个布尔值，因为我们只有一行代码，<em>Swift</em> 知道它必须是返回值的那一行。代码现在看起来是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result4 <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> name <span class="token keyword">in</span>   <span class="token keyword">return</span> name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>许多人在此止步，理由很充分：下一步开始可能会相当混乱。你看，当这个闭包被调用时，<em>Swift</em> 会自动创建匿名参数名，这些匿名参数名由一个美元符号和一个从 <em>0</em> 开始计数的数字组成。<em>$0, $1, $2</em>，以此类推。你不允许在自己的代码中使用这样的名称，所以这些名称很容易脱颖而出!</p><p>这些简写参数名映射到闭包接受的参数。在本例中，这意味着<code>name</code>可用为<code>$0</code>。不能混合显式参数和匿名参数：要么声明入参列表，要么使用 <em>$0</em> 系列。这两者做的是完全一样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result6 <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> name <span class="token keyword">in</span>   name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> result7 <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span>   $<span class="token number">0</span><span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>注意到在使用匿名时必须删除<code>name in</code>部分吗？是的，这意味着更少的输入，但同时你也放弃了一点可读性。我喜欢在我自己的代码中使用简写名称，但是只有在需要时才应该使用它们。</p><p>如果你选择使用简写名称，通常会将整个方法调用放在一行上，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> result8 <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token punctuation">{</span> $<span class="token number">0</span><span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>当你将其与原始闭包的大小进行比较时，你必须承认这是一个很大的改进!</p><h3 id="函数作为闭包-Functions-as-closures"><a href="#函数作为闭包-Functions-as-closures" class="headerlink" title="函数作为闭包(Functions as closures)"></a>函数作为闭包(Functions as closures)</h3><p><em>Swift</em> 确实模糊了函数、方法、操作符和闭包之间的界限，这非常棒，因为它向你隐藏了所有编译器的复杂性，并让开发人员做我们最擅长的事情：制作出色的应用程序。这种模糊的行为一开始很难理解，在日常编码中更难使用，但是我想向你展示两个示例，我希望它们能展示 <em>Swift</em> 是多么聪明。</p><p>我的第一个例子是这样的：给定一个名为 <code>words</code> 的字符串数组，如何查明这些单词是否存在于名为 <code>input</code>的字符串中? 一种可能的解决方案是将<code>input</code>分解为它自己的数组，然后遍历两个数组以寻找匹配项。但是 <em>Swift</em> 给了我们一个更好的解决方案：如果导入 <em>Foundation</em> 框架, <em>String</em> 会得到一个名为<code>contains()</code>的方法，该方法接受另一个字符串并返回一个布尔值。因此，这段代码将返回<code>true</code>：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> input <span class="token operator">=</span> <span class="token string">"My favorite album is Fearless"</span>input<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"album"</span><span class="token punctuation">)</span></code></pre><p><em>String</em> 数组还有两个<code>contains()</code>方法：一个方法直接指定一个元素(在我们的例子中是字符串)，另一个方法使用<code>where</code>参数接受闭包。该闭包需要接受一个字符串并返回一个布尔值，如下所示：</p><pre class=" language-swift"><code class="language-swift">words<span class="token punctuation">.</span><span class="token builtin">contains</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token keyword">in</span>   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p><em>Swift</em> 编译器的出色设计让我们把这两件事放在一起：即使字符串的<code>contains()</code>是一个来自 <em>NSString</em> 的基础方法，我们也可以将它传递到数组的<code>contains(where:)</code>中，而不是传递闭包。所以，整个代码变成这样：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">let</span> words <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1989"</span><span class="token punctuation">,</span> <span class="token string">"Fearless"</span><span class="token punctuation">,</span> <span class="token string">"Red"</span><span class="token punctuation">]</span><span class="token keyword">let</span> input <span class="token operator">=</span> <span class="token string">"My favorite album is Fearless"</span>words<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token keyword">where</span><span class="token punctuation">:</span> input<span class="token punctuation">.</span><span class="token builtin">contains</span><span class="token punctuation">)</span></code></pre><p>最后一行是关键。<code>contains(where:)</code>将对数组中的每个元素调用一次闭包，直到找到一个返回<code>true</code>的元素。传入<code>input.contains</code>意味着 <em>Swift</em> 将调用 <code>input.contains("1989")</code> 并返回 <code>false</code>，然后它将调用<code>input.contains("Fearless")</code>并返回<code>true</code>——然后停止。因为<code>contains()</code>具有与<code>contains(where:)</code>所期望的(接受一个字符串并返回一个布尔值)完全相同的签名，所以这就像一个魔咒。</p><p>我的第二个例子使用了数组的<code>reduce()</code>方法：提供一个初始值，然后给它一个函数来应用于数组中的每一项。每次调用该函数时，都会给你两个参数：调用该函数时的前一个值(这将是初始值)和要使用的当前值。</p><p>为了演示这一点，下面是一个调用<code>reduce()</code>对一个整型数组来计算它们的和的例子：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span>numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>int1<span class="token punctuation">,</span> int2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token keyword">in</span>   <span class="token keyword">return</span> int1 <span class="token operator">+</span> int2<span class="token punctuation">}</span></code></pre><p>当代码运行时，它将初始值和 <em>1</em> 相加得到 <em>1</em>，然后是<em>1</em>和 <em>3</em> (得到总数: <em>4</em> )，然后是<em>4</em> 和 <em>5</em> (<em>9</em>)，然后是 <em>9</em> 和 <em>7</em> (<em>16</em>)，然后是 <em>16</em> 和 <em>9</em>，最终得到 <em>25</em> 。</p><p>这种方法非常好，但 <em>Swift</em> 有一个更简单、更有效的解决方案：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">let</span> result <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span></code></pre><p>当你思考它的时候，<code>+</code>是一个接受两个整数并返回它们的和的函数，所以我们可以移除整个闭包并用一个操作符替换它。</p><h3 id="逃逸闭包-Escaping-closures"><a href="#逃逸闭包-Escaping-closures" class="headerlink" title="逃逸闭包(Escaping closures)"></a>逃逸闭包(Escaping closures)</h3><p>当你把一个闭包传递给一个函数时，<em>Swift</em>  默认认为它是不可逃逸的。这意味着闭包必须立即在函数内部使用，并且不能存储起来供以后使用。如果你试图在函数返回后使用闭包，<em>Swift</em> 编译器将拒绝构建，例如，如果要使用 <em>GCD</em> 的 <code>asyncAfter()</code>方法在一段时间的延迟之后调用它。</p><p>这对于许多类型的函数都非常有用，比如<code>sort()</code>，在这些函数中，你可以确定闭包将在方法中使用，然后就再也不会使用闭包了。<code>sort()</code>方法接受非逃逸闭包作为其惟一的参数，因为<code>sort()</code>不会尝试存储该闭包的副本供以后使用——它会立即使用闭包，然后结束。</p><p>另一方面，逃逸闭包是在方法返回后调用的闭包。它们存在于许多需要异步调用闭包的地方。例如，可能会给你一个闭包，该闭包只应该在用户做出选择时调用。你可以将该闭包存储起来，提示用户作出决定，然后在准备好用户的选择后调用闭包。</p><p>逃逸闭包和非逃逸闭包之间的区别可能听起来很小，但这很重要，因为闭包是引用类型。一旦 <em>Swift</em> 知道函数一旦完成就不会使用闭包——它是非逃逸的——它就不需要担心引用计数，因此它可以节省一些工作。因此，非逃逸闭包速度更快，并且是 <em>Swift</em> 的默认闭包。也就是说，除非另外指定，否则所有闭包参数都被认为是非逃逸的。</p><p>如果希望指定逃逸闭包，需要使用<code>@escaping</code>关键字。最好的方法是在需要的时候演示一个场景。考虑下面的代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> queuedClosures<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">func</span> <span class="token function">queueClosure</span><span class="token punctuation">(</span><span class="token number">_</span> closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   queuedClosures<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>closure<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">queueClosure</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Running closure 1"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">queueClosure</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Running closure 2"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token function">queueClosure</span><span class="token punctuation">(</span><span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Running closure 3"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>这将创建要运行的闭包数组和接受要排队的闭包的函数。该函数除了将它被赋予的闭包追加到队列闭包数组之外，什么都不做。最后，它使用三个简单的闭包调用<code>queueClosure()</code>三次，每个闭包打印一条消息。</p><p>为了完成这段代码，我们只需要创建一个名为<code>executequeuedclosure()</code>的新方法，它遍历队列并执行每个闭包：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">executeQueuedClosures</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">for</span> closure <span class="token keyword">in</span> queuedClosures <span class="token punctuation">{</span>      <span class="token function">closure</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">executeQueuedClosures</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>让我们更仔细地研究<code>queueClosure()</code>方法：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">queueClosure</span><span class="token punctuation">(</span><span class="token number">_</span> closure<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   queuedClosures<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>closure<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>它只接受一个参数，这是一个没有参数或返回值的闭包。然后将该闭包添加到<code>queuedclosure</code>数组中。这意味着我们传入的闭包可以稍后使用，在本例中，当调用<code>executequeuedclosure()</code>函数时使用。</p><p>因为闭包可以稍后调用，<em>Swift</em> 认为它们是逃逸闭包，所以它将拒绝构建这段代码。请记住，出于性能考虑，非逃逸闭包是默认的，所以我们需要显式地添加<code>@escape</code>关键字，以明确我们的意图：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">queueClosure</span><span class="token punctuation">(</span><span class="token number">_</span> closure<span class="token punctuation">:</span> @<span class="token function">escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   queuedClosures<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>closure<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><blockquote><p>所以：如果你写了一个函数，它会立即调用闭包，然后不再使用它，它在默认情况下是非逃逸的，你可以忘记它。但是，如果你打算存储闭包供以后使用，则需要<code>@escape</code>关键字。</p></blockquote><h3 id="自动闭包-autoclosure"><a href="#自动闭包-autoclosure" class="headerlink" title="自动闭包(@autoclosure)"></a>自动闭包(@autoclosure)</h3><p><code>@autoclosure</code>属性类似于<code>@escaping</code>，因为你将它应用于函数的闭包参数，但是它的使用要少得多。嗯，不，严格来说不是这样的：调用使用<code>@autoclosure</code>的函数是很常见的，但是用它编写函数则不常见。</p><p>当你使用此属性时，它会根据传入的表达式自动创建闭包。当你调用使用此属性的函数时，你编写的代码不是闭包，当它会变成闭包，这可能有点令人困惑——甚至官方的 <em>Swift</em> 参考指南也警告说，<strong>过度使用自动闭包会使代码更难理解</strong>。</p><p>为了帮助你理解它是如何工作的，这里有一个简单的例子：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">printTest</span><span class="token punctuation">(</span><span class="token number">_</span> result<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Before"</span><span class="token punctuation">)</span>   <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"After"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">printTest</span><span class="token punctuation">(</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">)</span></code></pre><p>该代码创建了<code>printTest()</code>方法，该方法接受闭包并调用它。如你所见，<code>print(“Hello”)</code>位于一个闭包中，该闭包在 “ <em>Before</em> ” 和 “ <em>After</em> ” 之间调用，因此最终的输出是 “ <em>Before</em> ”、“ <em>Hello</em> ”和 “ <em>After</em> ”。</p><p>如果我们使用<code>@autoclosure</code>，它将允许我们重写代码<code>printTest()</code>调用，这样它就不需要大括号，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">printTest</span><span class="token punctuation">(</span><span class="token number">_</span> result<span class="token punctuation">:</span> @<span class="token function">autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Before"</span><span class="token punctuation">)</span>   <span class="token function">result</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"After"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">printTest</span><span class="token punctuation">(</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>由于<code>@autoclosure</code>，这两段代码产生了相同的结果。在第二个代码示例中，<code>print("Hello")</code>不会立即执行，因为它被包装在一个闭包中，以便稍后执行。</p><p>这种行为看起来很简单：所有这些工作只是删除了一对大括号，使代码更难理解。但是，有一个特定的地方需要使用它们：<code>assert()</code>。这是一个 <em>Swift</em> 函数，用于检查条件是否为真，如果不为真，则会导致应用程序停止。</p><p>这听起来可能非常极端：为什么你希望你的应用程序崩溃？显然，你不会这样做，但是在测试应用程序时，添加<code>assert()</code>调用有助于确保代码的行为符合预期。你真正想要的是，你的断言在 <em>debug</em> 模式下是活动的，而在 <em>release</em> 模式下是禁用的，这正是<code>assert()</code>的工作方式。</p><p>请看下面三个例子：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Maths failure!"</span><span class="token punctuation">)</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Maths failure!"</span><span class="token punctuation">)</span><span class="token function">assert</span><span class="token punctuation">(</span><span class="token function">myReallySlowMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token string">"The slow method returned false!"</span><span class="token punctuation">)</span></code></pre><p>第一个例子返回<code>true</code>，所以什么也不会发生。第二个将返回<code>false</code>，因此应用程序将停止。第三个例子是<code>assert()</code>的强大功能：因为它使用<code>@autoclosure</code>将代码封装在闭包中，所以 <em>Swift</em> 编译器在 <em>release</em> 模式下不会运行闭包。这意味着你可以在调试时获得所有断言的安全性，而不需要在  <em>release</em> 模式中付出任何性能代价。</p><p>你可能有兴趣知道，自动闭包还用于处理<code>&amp;&amp;</code>和<code>||</code>操作符。以下是在官方编译器中找到<code>&amp;&amp;</code>完整的 <em>Swift</em> 源代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Bool</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> @<span class="token function">autoclosure</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span><span class="token punctuation">)</span> <span class="token keyword">rethrows</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> lhs <span class="token operator">?</span> <span class="token keyword">try</span> <span class="token function">rhs</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span></code></pre><p>是的，它包含<code>try/catch</code>、<code>throw</code>和<code>rethrow</code>、运算符重载、三元运算符和<code>@autoclosure</code>，所有这些都在一个小函数中。尽管如此，我还是希望你能够理解代码的全部功能：如果<code>lhs</code>为真，则返回<code>rhs()</code>的结果，否则返回<code>false</code>。这是实际的短路评估：如果<code>lhs</code>代码已经返回<code>false</code>, <em>Swift</em> 不需要运行<code>rhs</code>闭包。</p><p>关于<code>@autoclosure</code>的最后一件事：如果你想要进行逃逸闭包，你应该将这两个属性组合起来。例如，我们可以像这样重写前面的<code>queueClosure()</code>函数：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">queueClosure</span><span class="token punctuation">(</span><span class="token number">_</span> closure<span class="token punctuation">:</span> @autoclosure @<span class="token function">escaping</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   queuedClosures<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>closure<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">queueClosure</span><span class="token punctuation">(</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Running closure 1"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><blockquote><p>提醒：小心使用自动闭包。它们会使代码更难理解，所以不要仅仅因为想避免键入一些花括号就使用它们。</p></blockquote><h2 id="操作符-The-operator"><a href="#操作符-The-operator" class="headerlink" title="~=操作符(The ~= operator)"></a>~=操作符(The ~= operator)</h2><p>我知道有一个喜欢的运算符听起来很奇怪，但是我确实喜欢，它是<code>~=</code>。我喜欢它，因为它简单。我爱它，即使它不是真的需要。我甚至喜欢它的形状——只要看看它的美丽就行了！所以我希望你能原谅我花了几分钟时间给你看这个。</p><p>我已经对两个简单的符号流口水了：这到底是做什么的？我很高兴你这么问! <code>~=</code>是模式匹配操作符，它允许你这样编写代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> range <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">100</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">42</span><span class="token keyword">if</span> range <span class="token operator">~</span><span class="token operator">=</span> i <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Match!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>正如我所说，不需要这个操作符，因为你可以使用区间内置的<code>contains()</code>方法编写代码。但是，它确实比<code>contains()</code>有一点语法上的优势，因为它不需要额外的一组括号：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> test1 <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token keyword">let</span> test2 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">100</span> <span class="token operator">~</span><span class="token operator">=</span> <span class="token number">42</span></code></pre><p>我认为<code>~=</code>是使用操作符重载来整理日常语法的一个很好的例子。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pro Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Pro Swift </tag>
            
            <tag> 操作符重载 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第三章 引用类型和值类型(References and Values)</title>
      <link href="/2019/09/05/pro-swift-yi-wen/chapter3-references-and-values/"/>
      <url>/2019/09/05/pro-swift-yi-wen/chapter3-references-and-values/</url>
      
        <content type="html"><![CDATA[<p>下次发生崩溃时，请按照以下说明正确解决问题：单击线程中的  <code>objc_exception_throw</code>，然后在调试区域键入<code>po $arg1</code>以获取错误的可读版本。如果你使用异常断点，你甚至可以在那里添加<code>po $arg1</code>命令，这样它将自动输出。<br> – <em>Natasha Murashev (@natashatherobot)</em>, 作者和演说家</p><h2 id="有什么区别？-What’s-the-difference"><a href="#有什么区别？-What’s-the-difference" class="headerlink" title="有什么区别？(What’s the difference?)"></a>有什么区别？(What’s the difference?)</h2><p>理解和利用引用类型和值类型之间的差异对于任何认真的Swift开发人员来说都是一项至关重要的技能。这不是“有用的知识”，也不是“知道就好”，而是至关重要的——我不是随便说说。</p><p>在接下来的几章中，我将详细介绍引用和值，以便你可以自己学习，但首先我想解释它们之间的区别。我遇到过太多的开发人员，他们要么不理解，要么不在乎——这两者都是错误的——所以这是一个明智的起点。</p><p>我是《星球大战》的超级粉丝，你可能还记得第一部《星球大战》电影(后来被命名为《新希望》)的结尾是对死星的攻击。叛军飞行员之一韦奇·安地列斯——飞往攻击死星，但遭到破坏，不得不飞回基地。另一名叛军飞行员卢克·天行者也在攻击死星，但他使用原力拯救了这一天，至少在下一部电影之前是这样。</p><p>为了说明引用类型和值类型之间的区别，我想用简单的 <em>Swift</em> 代码重新创建这个电影场景。虽然还不完整，但你可以跟着做：</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// create a target</span><span class="token keyword">var</span> target <span class="token operator">=</span> <span class="token function">Target</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// set its location to be the Death Star</span>target<span class="token punctuation">.</span>location <span class="token operator">=</span> <span class="token string">"Death Star"</span><span class="token comment" spellcheck="true">// tell Luke to attack the Death Star</span>luke<span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token comment" spellcheck="true">// oh no – Wedge is hit! We need to</span><span class="token comment" spellcheck="true">// tell him to fly home</span>target<span class="token punctuation">.</span>location <span class="token operator">=</span> <span class="token string">"Rebel Base"</span>wedge<span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token comment" spellcheck="true">// report back to base</span><span class="token function">print</span><span class="token punctuation">(</span>luke<span class="token punctuation">.</span>target<span class="token punctuation">.</span>location<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>wedge<span class="token punctuation">.</span>target<span class="token punctuation">.</span>location<span class="token punctuation">)</span></code></pre><p>现在的问题是：当这些飞行员返回基地时，他们会说什么？答案是，“视情况而定。” 它所依赖的是——你猜对了——引用类型和值类型之间的区别。</p><p>你看，如果<code>Target</code>是一个类，在 <em>Swift</em> 中是一个引用类型，它应该是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> location <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">}</span></code></pre><p>如果<code>Target</code>是结构体，也就是 <em>Swift</em> 中的值类型，它会是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Target</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> location <span class="token operator">=</span> <span class="token string">""</span><span class="token punctuation">}</span></code></pre><p>代码几乎相同，只有一个词不同。但结果是相差巨大的：如果<code>Target</code>是一个结构体，那么卢克会瞄准死亡之星，而韦奇会瞄准叛军基地，但是如果<code>Target</code>是一个类，那么卢克和韦奇都会瞄准叛军基地——这会给叛军和一些深深困惑的电影迷们带来非常不愉快的结局。</p><p>这种行为的原因是，当你在多个位置分配引用类型时，所有这些位置都指向相同的数据块。</p><p>因此，尽管卢克有一个<code>target</code>属性，韦奇也有一个<code>target</code>属性，但它们都指向<code>Target</code>类的同一个实例——改变一个意味着另一个也会改变。</p><p>另一方面，值类型总是只有一个所有者。当你在多个位置分配值类型时，所有这些位置都指向该值的单个副本。</p><p>当代码<code>luke.target = target</code>运行时，卢克获得了自己的<code>Target</code>实例的唯一副本。所以，当这变成“叛军基地”时，他不在乎——他继续攻击死星。</p><p><em>Swift</em> 是一种积极的值类型导向的语言，这意味着它的大多数数据类型都是值类型，而不是引用类型。布尔值、整数、字符串、元组和枚举都是值类型。甚至数组和字典也是值类型，所以下面的代码将打印 <em>3</em> 而不是 <em>4</em> ：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">var</span> b <span class="token operator">=</span> aa<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>b<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span></code></pre><p>值类型比引用类型简单，这不是坏事。当你给定一个要使用的值时，你可以确保它的值不会意外更改，因为你有自己惟一的副本。你还可以轻松地比较值类型，它们是如何得到值的并不重要——只要两个值看起来相同，它们就是相同的。例如，下面的代码将打印 “<em>Equal</em> ” ，即使 <em>a</em> 和 <em>b</em> 的创建方式非常不同：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">if</span> a <span class="token operator">==</span> b <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Equal"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>简而言之，引用类型在赋值时共享，因此可以有多个所有者，而值类型在赋值时复制，因此只有一个所有者。</p><h2 id="闭包是引用类型-Closures-are-references"><a href="#闭包是引用类型-Closures-are-references" class="headerlink" title="闭包是引用类型(Closures are references)"></a>闭包是引用类型(Closures are references)</h2><p>这可能会有点烧脑，所以如果你很少复制闭包，那么可以完全跳过这一章。</p><p>我已经说过，布尔类型、整型、字符串类型、数组、字典、结构体等等都是 <em>Swift</em> 中的值类型。类是引用类型，闭包也是。对于简单的闭包，这并不重要。例如，下面的代码在<code>printGreeting</code>中存储了一个简单的闭包，调用它，将它分配给<code>copyGreeting</code>，然后再调用：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> printGreeting <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello!"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token function">printGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> copyGreeting <span class="token operator">=</span> printGreeting<span class="token function">copyGreeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>在该代码中，闭包可以是值类型，它不会影响输出。当闭包捕获值时，事情就变得复杂了，因为捕获的值在指向相同闭包的任何变量之间共享。</p><p>给你一个实际的例子，下面的代码是一个<code>createIncrementer()</code>函数，它不接受任何参数并返回一个闭包：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">createIncrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Void</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span>   <span class="token keyword">return</span> <span class="token punctuation">{</span>      counter <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span>      <span class="token function">print</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在<code>createIncrementer()</code>函数中有一个变量<code>counter</code>，它的初始值为<code>0</code>。因为该变量是在返回的闭包中使用的，所以它将被捕获。所以，我们可以用这样的代码来执行这个函数：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> incrementer <span class="token operator">=</span> <span class="token function">createIncrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>第一行调用<code>createIncrementer()</code>函数并将其返回的闭包存储在<code>incrementer</code>变量中。下面的两行调用<code>incrementer()</code>两次，触发了闭包，因此你将看到 <code>1</code>和<code>2</code>被打印出来—计数器如预期的那样向上增加。</p><p>现在重点是：因为闭包是引用类型，如果我们创建另一个<code>incrementer</code>引用，它们将共享相同的闭包，因此也将共享相同的计数器变量。例如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> incrementer <span class="token operator">=</span> <span class="token function">createIncrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> incrementerCopy <span class="token operator">=</span> incrementer<span class="token function">incrementerCopy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">incrementer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>当代码运行时，你将看到<code>1</code>、<code>2</code>、<code>3</code>、<code>4</code>被打印出来，因为<code>incrementer</code>和<code>incrementerCopy</code>都指向完全相同的闭包，因此也指向相同的捕获值。</p><p>重复一遍：如果你不经常使用闭包，那么这不太可能是一个问题，如果你不使用闭包来捕获值，那么你就是安全的。否则，请小心操作：在不引入闭包捕获的情况下，使用引用类型可能会非常困难。</p><h2 id="为什么使用结构体？-Why-use-structs"><a href="#为什么使用结构体？-Why-use-structs" class="headerlink" title="为什么使用结构体？(Why use structs?)"></a>为什么使用结构体？(Why use structs?)</h2><p>如果你要在类或结构体(即引用类型或值类型)之间进行选择，那么选择结构体是有充分理由的。这种比较适用于所有引用类型或值类型，但最常见的是当涉及到类或结构体时如何选择，这就是我将在这里讲的内容。</p><p>我已经提到过值类型是复制而不是共享，这意味着如果你的代码有三个不同的东西指向同一个结构，它们每个都有自己的副本 - 他们没有机会踩到对方的脚趾。 一旦你理解了这种逐个复制的行为，你就会开始意识到它带来了另一套好处。</p><p>如果你使用的应用程序比较复杂，那么值类型的最大好处之一就是它们本质上是线程安全的。也就是说，如果你正在处理一个或多个后台线程，则不可能导致值类型的竞争条件。为了避免混淆，在解释原因之前，我先简要解释一下原因。</p><p>首先，竞态条件：这是一个常见的 <em>bug</em> 类型的名称，它是由并行运行的两段代码引起的，它们完成的顺序会影响程序的状态。例如，假设我开车去你家给你 <em>1000</em> 美元，你的一个朋友也开车去你家索要 <em>200</em> 美元。我先到，然后把钱给你。朋友几分钟后到了，你给了她 <em>200</em> 美元——一切都很好。或者，你的朋友可能会比我开得快，然后先到那里，在这种情况下，他们要求 <em>200</em> 美元，而你却没有从我这里得到任何钱——突然之间，你就有麻烦了。</p><p>在软件中，这可能意味着尝试在收到结果之前对其进行操作，或者尝试处理尚未创建的对象。无论如何，结果都是不好的：你的软件的行为不一致，这取决于首先发生的操作，这使得问题很难发现和解决。</p><p>第二，线程安全：这是一个术语，它意味着代码的编写方式是多线程可以使用数据结构，而不会相互影响。如果线程 <em>A</em> 修改了线程 <em>B</em> 正在使用的东西，那么这就不是线程安全的。</p><p>值类型本质上是线程安全的，因为它们不是在线程之间共享的——每个线程都将获得自己的数据副本，并且可以在不影响其他线程的情况下尽可能多地操作该副本。每个副本都独立于其他副本，因此基于数据的竞态条件将消失。</p><p>消除(或至少显著减少)线程问题是很好的，但是值类型有一个更大的好处：它们大大减少了代码中存在的关系的数量。举个例子，常见的情况是 <em>Core Data</em> 应用程序在 <em>app delegate</em> 中设置数据库，然后在视图控制器之间传递对数据库或单个对象的引用。每次你在视图控制器之间传递一个对象时，你都在双向地连接它们——子视图控制器可以以任何方式修改那个对象，而所有这些变化都会无声地出现在父视图控制器中。</p><p>因此，应用程序中的对象关系可能不太像树，而更像意大利面工厂中的爆炸——联系无处不在，任何人所做的更改都可以在应用程序中显示和传播，这一切变得很难解释。也就是说，很难说“这段代码是如何工作的？”当你的物体被缠住的时候。</p><p>当你使用值类型时，这就不是问题了: 一旦将结构体从一个视图控制器传递到另一个视图控制器，子控制器就有了自己的独立副本 – 这里没有形成任何隐含的关系，子控制器也不可能搞乱自己和父控制器的值。</p><p>选择结构体而不是类的最后一个原因是：它们带有成员初始化。这意味着编译器自动生成一个初始化器，该初始化器为结构的每个属性提供默认值。例如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Person</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>   <span class="token keyword">var</span> favoriteIceCream<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">}</span><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">,</span> favoriteIceCream<span class="token punctuation">:</span> <span class="token string">"Chocolate"</span><span class="token punctuation">)</span></code></pre><p>我知道这微不足道，但它非常实用，使结构更容易使用。</p><h2 id="为什么使用类类型？-Why-use-classes"><a href="#为什么使用类类型？-Why-use-classes" class="headerlink" title="为什么使用类类型？(Why use classes?)"></a>为什么使用类类型？(Why use classes?)</h2><p>使用类而不是结构有一些很好的理由，尽管它们中至少有一个会回来咬你一口。引用类型有点像命名或句柄，如果你是一个老派的开发人员，甚至是指针：当你传递它们时，每个人都指向相同的值。这意味着你可以创建一个资源，如数据库连接，并在应用程序中的许多对象之间共享它，而无需创建新的连接。</p><p>巧妙地说，类的这种共享特性是支持和反对使用值类型而不是引用类型的主要原因。原因之一是灵活性和性能：在短期内，很容易传递一个共享对象，并让每个人根据需要修改它。 这很糟糕，而且很脆弱，但它确实很容易编写代码。事实上，我建议这种方法是许多开发人员的默认方法，特别是那些来自 <em>Objective-C</em> 背景的开发人员。</p><p>这种方法也可能运行得非常快，因为你不需要每次将对象传递到其他地方时都创建对象的副本。相反，你只创建一个对象，并将其传递到需要它的地方——只要你的代码是线程安全的，对象甚至可以跨线程使用，而不用担心太多。</p><p>对象提供给你的一个结构体所没有的特性是继承：获取现有类并在其基础上构建的能力。多年来，继承一直是软件开发中的一个基本概念，并且现在已经深深地扎根于我们的行业中，很容易就可以追溯到一两代开发人员。它允许你使用现有的类，无论大小，并以任何你想要的方式构建它。你可能会添加一些小的调整，或大量的更改。有些语言(幸运的是不是 <em>Swift</em> !) 允许你从多个类中继承——这在智力上非常有趣，但很少使用，而且从来没有必要。</p><p>最后，使用类的一个主要原因是 <em>Cocoa Touch</em> 本身是使用类编写的：<em>UIKit</em> 、<em>SpriteKit</em> 、<em>MapKit*、 *Core Location</em> 等等都是面向对象的，<em>NSCoding</em> 和 <em>NSCopying</em> 等协议也是如此。如果你正在编写需要使用 <em>Cocoa</em> 或 <em>Cocoa Touch</em> 的 <em>Swift</em> 代码，比如将自定义数据类型保存到 <em>NSUserDefaults</em> ，那么你可能在某个时候需要类类型。</p><h2 id="在结构和类之间选择-Choosing-between-structs-and-classes"><a href="#在结构和类之间选择-Choosing-between-structs-and-classes" class="headerlink" title="在结构和类之间选择(Choosing between structs and classes)"></a>在结构和类之间选择(Choosing between structs and classes)</h2><p>在结构或类之间进行选择取决于你想要引用类型还是值类型行为。每种方法的一些优点实际上可能是缺点，这取决于你的上下文，因此你需要阅读下面的建议并自己决定。</p><p>首先，线程安全和不受竞争条件限制的好处是使用值类型的主要原因。很容易想象我们是一个非常聪明的程序员，能够在睡梦中处理多线程，但事实是，我们的大脑并不是这样工作的：计算机实际上可以同时执行两项、四项、八项或更多复杂的任务，这对于普通人来说极其困难，更不用说调试了。</p><p><em>Joel Spolsky</em> 就这个主题写了一篇优秀的文章，叫做 “<em>The Duct Tape Programmer</em> ”，他在文章中讨论了聪明的程序员采用简单解决方案的原则 – <em>the equivalent duct tape and WD-40</em> 。在这篇文章中，他引用了多线程作为复杂代码的一个例子，并说：“<em>The Duct Tape Programmer</em> 很好地理解的一个原则是，任何一种稍微复杂的编码技术都会毁了你的项目。”</p><p>你也不应该低估简化你的应用程序中的关系的价值。正如我已经提到的，每次你将一个对象从一个地方传递到另一个地方，你都在含蓄地创建一个关系，在未来的任何时候都可能适得其反。如果你只做过一两次这样的操作，那么跟踪它可能并不困难，但是你有多少次看到对象被传递了几十次的情况呢？如果你曾经使用过 <em>Core Data</em> ，你就会知道它与简单的关系建模截然相反。</p><p>对象允许你在应用的不同部分共享数据，但你真的需要吗？就绝对性能而言，它通常更有效，但是它会在你的体系结构中创建非常复杂的关系。有些值类型——特别是内置到 <em>Swift</em> 本身的值类型——具有一种称为写时复制(<em>copy on write)</em> 的优化，使得传递它们和传递对象一样高效，因为除非你试图更改值，否则 <em>Swift</em> 不会复制值。遗憾的是，这种优化并没有运用到你自定义的结构，所以你要么自己编写代码，要么(稍微)降低性能。</p><p>类的另一个主要优势是能够通过继承另一个类来创建新类。这是一个功能强大的特性，具有经过验证的跟踪记录，而且还有一个额外的好处，即数百万开发人员了解该技术并广泛使用它。但是，尽管继承功能强大，它也有自己的问题：如果你在设计一个聪明,有用的和清晰的架构，从 <em>A</em> 到 <em>B</em> 到 <em>C</em> 甚至是 <em>D</em>，如果你后来改变了主意，会发生什么 – 例如，试着移除 <em>B</em> 或者把 <em>E</em> 放到 <em>B</em> 所在的位置? 答案是，它变得非常混乱。</p><p>虽然继承在任何人的工具包中仍然是一个有价值的工具——特别是在构建 <em>Cocoa</em> 和 <em>Cocoa Touch</em> 时——但是一种更新、更简单的方法正在迅速流行起来：面向协议开发。在这里，你可以水平地而不是垂直地添加单个功能块，这允许你随时更改你的想法，而不会造成任何问题。<em>Swift</em> 强大的扩展类型和扩展能力使得继承远不如以前有用：我们通过功能组合而不是层次继承来生成强大的数据类型。</p><p>同样，你的选择很大程度上取决于你的使用场景。然而，基于以上，我想提供一些总结点，以帮助指导你。</p><p>首先，我建议你尽可能选择结构而不是类。如果没有继承就无法生存，或者迫切需要共享数据所有权，那么就使用类，但是结构应该始终是你的默认起点。我喜欢在自己的代码中使用结构，但在本书中，我偶尔使用类，因为我试图覆盖所有的基础。</p><p>其次，如果必须使用类，请将其声明为<code>final</code>。这将立即带给你性能提升，而且它也应该是你的默认设置：除非你特别认为，“是的，这个类可以安全地被其他类子类化”，否则允许它发生是一个错误。不要低估健壮子类的复杂性！</p><p>第三，尽可能地将结构体或类的属性声明为常量。不变性——数据无法被更改——多亏了<code>let</code> 这个关键字，它被完美地融入了 <em>Swift</em> ，这是一个值得坚持的好习惯。</p><p>第四，如果你发现自己无论如何都是从一个类开始的，这只是其他编程语言遗留下来的问题吗? <em>Objective-C</em> 开发人员几乎所有的事情都使用类，因此类可能是一个难以改变的习惯。如果你像写 <em>Objective-C</em> 一样写 <em>Swift</em> 的时候，那你将错过一半乐趣和一半的效率。对于这种新语言，我建议你在回到使用类之前对值类型进行彻底的了解。</p><h3 id="结合类和结构-Mixing-classes-and-structs"><a href="#结合类和结构-Mixing-classes-and-structs" class="headerlink" title="结合类和结构(Mixing classes and structs)"></a>结合类和结构(Mixing classes and structs)</h3><p>一旦理解了值类型和引用类型，在类和结构体之间进行选择就容易得多——至少在开始时是这样。但是随着应用程序的增长，你可能会发现你的情况变得不那么黑白分明了：你的应用程序可能 <em>95%</em> 的时间都在处理值类型，但是如果你使用引用类型，那么可能只需要一两次，一切就会变得简单得多。</p><p>所有这些都不会丢失：记住我所说的关于两者相对优势和劣势的所有内容，如果你确信这是正确的解决方案，那么有一种方法可以在多个地方共享值类型。这种技术被称为 <em>boxing</em> ——不是那种有力的、汗流浃背的拳击，而是“把东西放在盒子里”。这种方法将值类型封装在引用类型中，以便更容易地共享它，这种方法在 <em>c#</em> 和 <em>Java</em> 等语言中很常见。</p><blockquote><p>注意：我不会继续重复警告：共享而不是复制值会增加程序的复杂性；请将其视为已读！</p></blockquote><p>我想给你举一个实际的例子，让你自己看看它是如何工作的。首先，这里是我们的 <code>Person</code>结构：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Person</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>   <span class="token keyword">var</span> favoriteIceCream<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">}</span><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">,</span> favoriteIceCream<span class="token punctuation">:</span> <span class="token string">"Chocolate"</span><span class="token punctuation">)</span></code></pre><p>如果我们想在多个对象之间共享<code>taylor</code>这个结构体，我们需要像这样创建一个<code>PersonBox</code>类：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PersonBox</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> person<span class="token punctuation">:</span> <span class="token builtin">Person</span>   <span class="token keyword">init</span><span class="token punctuation">(</span>person<span class="token punctuation">:</span> <span class="token builtin">Person</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">self</span><span class="token punctuation">.</span>person <span class="token operator">=</span> person   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> box <span class="token operator">=</span> <span class="token function">PersonBox</span><span class="token punctuation">(</span>person<span class="token punctuation">:</span> taylor<span class="token punctuation">)</span></code></pre><p>它是封装<code>Person</code>结构体的类容器，作为引用类型，将被共享而不是复制。</p><p>最后，让我们创建一个<code>TestContainer</code>类，它模拟应用程序的某些部分，例如不同的视图控制器：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TestContainer</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> box<span class="token punctuation">:</span> <span class="token builtin">PersonBox</span><span class="token operator">!</span><span class="token punctuation">}</span><span class="token keyword">let</span> container1 <span class="token operator">=</span> <span class="token function">TestContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> container2 <span class="token operator">=</span> <span class="token function">TestContainer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>container1<span class="token punctuation">.</span>box <span class="token operator">=</span> boxcontainer2<span class="token punctuation">.</span>box <span class="token operator">=</span> box</code></pre><p>这段代码创建两个容器，每个容器指向同一个<code>PersonBox</code>对象，这意味着它们指向同一个<code>Person</code>结构体。为了证明这一点，我们可以编写如下代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span>container1<span class="token punctuation">.</span>box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>container2<span class="token punctuation">.</span>box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span>box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Not Taylor"</span><span class="token function">print</span><span class="token punctuation">(</span>container1<span class="token punctuation">.</span>box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>container2<span class="token punctuation">.</span>box<span class="token punctuation">.</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span></code></pre><p>这将打印 “<em>Taylor Swift</em> ”两次，然后打印 “<em>Not Taylor</em> ”两次，以证明更改一个容器中的值会更改另一个容器中的值。</p><p>如果你打算广泛使用 <code>boxing</code> 和 <code>unboxing</code>（警告，我希望你可以自己写这个！），你可能需要考虑创建这样的通用<code>Box</code>类：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Box</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> value<span class="token punctuation">:</span> T   <span class="token keyword">init</span><span class="token punctuation">(</span>value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">self</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TestContainer</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> box<span class="token punctuation">:</span> <span class="token builtin">Box</span><span class="token operator">&lt;</span><span class="token builtin">Person</span><span class="token operator">></span><span class="token operator">!</span><span class="token punctuation">}</span></code></pre><p>这样就可以共享其他类型的结构，而不必创建许多不同的<code>Box</code>类。</p><p>不可否认的是，这种方法稍微削弱了值类型的能力和安全性，但至少它明确了哪些情况提供了值类型的安全性，哪些情况没有——你在声明“这部分是显式共享的”，而不是隐式共享所有内容。</p><p>还有一件事你应该知道，如果你有使用 <em>Objective-C</em> 的背景：如果你面临重要的引用计数性能问题，<code>boxing</code> 和 <code>unboxing</code>可能会很有帮助。<em>Swift</em> 与现代的 <em>Objective-C</em> 一样，使用了一个称为自动引用计数(<em>ARC</em>)的系统，它可以跟踪一个对象被引用的次数。当该计数达到 <em>0</em> 时，对象将自动销毁。</p><p><em>Swift</em> 的结构体不进行引用计数，因为它们始终是唯一引用的。但是，如果结构体包含一个对象作为它的属性之一，则该对象将被引用计数。</p><p>对于小的东西，这不是问题，但是如果你的结构有很多对象作为属性。假设有 <em>10</em> 个引用类型的属性，然后你的结构体每次被复制时 <em>ARC</em> 都需要做 <em>10</em> 次增加引用计数的操作。在这种情况下，将结构体装箱到包装对象中可以极大地简化工作，因为 <em>ARC</em> 只需要操作包装对象的引用计数，而不需要操作所有单独的属性。</p><h3 id="不可变性-Immutability"><a href="#不可变性-Immutability" class="headerlink" title="不可变性(Immutability)"></a>不可变性(Immutability)</h3><p>值和引用类型在处理不可变性的方式上有所不同，但我在这里将其分开，因为这是一个非常细微的差异，很容易混淆。</p><p>让我们回顾一下：我喜欢 <em>Swift</em> 的一点是，它积极地关注不变性。也就是说，很容易说“不要让这个值改变”。这不仅意味着在编写代码时鼓励你使用<code>let</code>而不是<code>var</code>，而且 <em>Swift</em> 编译器将扫描你的代码，并在发现可以将变量转换为常量的位置时发出警告。这和 <em>Objective-C</em> 非常不同，在<em>Objective-C*中，可变性只作为类名的一部分强制执行 *NSString</em> 有一个<em>NSMutableString</em> 对应项，<em>NSArray</em> 有一个 <em>NSMutableArray</em> 对应项，等等。</p><p>不变性和值类型似乎是密切相关的。毕竟，如果一个值只是一个值，它怎么能改变呢? 整型是 <em>Swift</em> 中的值类型，你不能确切地说 “嘿，我在改变数字 <em>5</em>，所以现在 <em>5</em> 实际上等于 <em>6</em> ”。但是当你开始比较类和结构时，不变性就更加复杂了，我想解释一下原因。</p><p>考虑以下代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">PersonStruct</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">}</span><span class="token keyword">var</span> taylor <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>taylor<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span></code></pre><p>当代码运行时，<code>taylor</code> 实例的最终名称值是 “<em>Justin Bieber</em> ”，这对于任何参加演唱会的人来说都将是一个巨大的惊喜!</p><p>如果我们只修改一行代码，结果会非常不同：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>taylor<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span></code></pre><p>只有一行不同，代码甚至无法编译，因为不允许更改<code>name</code>属性。即使<code>name</code> 和 <code>age</code>属性被标记为变量，<code>taylor</code>结构被标记为常量，因此 <em>Swift</em> 不允许它的任何部分更改。</p><p>这就是事情变得有点复杂的地方，但请认真对待：这真的很重要。考虑以下代码:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">PersonClass</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name      <span class="token keyword">self</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">PersonClass</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>taylor<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span></code></pre><p>这个例子使用的是 <code>PersonClass</code>类而不是结构体，但是它将 <code>taylor</code> 实例保留为常量。现在代码进行编译，这与它是一个结构体时非常不同。</p><p>当 <code>taylor</code> 是一个常量结构体时，你不能改变它的值或属性。当它是一个常量对象时，你不能改变它的值，但你可以改变它的属性，只要它们没有被单独标记为常量。这意味着使用结构允许你比使用类更强地执行不变性，这有助于进一步简化代码。</p><p>下面的代码显示了所有可能的选项——我已经注释掉了不能工作的代码:</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// variable struct: changing property and changing value OK</span><span class="token keyword">var</span> taylor1 <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>taylor1<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span>taylor1 <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Justin Bieber"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// constant struct: changing property or value not allowed</span><span class="token keyword">let</span> taylor2 <span class="token operator">=</span> <span class="token function">PersonStruct</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//taylor2.name = "Justin Bieber"</span><span class="token comment" spellcheck="true">//taylor2 = PersonStruct(name: "Justin Bieber", age: 22)</span><span class="token comment" spellcheck="true">// variable object: changing property and reference OK</span><span class="token keyword">var</span> taylor3 <span class="token operator">=</span> <span class="token function">PersonClass</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>taylor3<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span>taylor3 <span class="token operator">=</span> <span class="token function">PersonClass</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Justin Bieber"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">22</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// constant object: changing property OK, changing reference not allowed</span><span class="token keyword">let</span> taylor4 <span class="token operator">=</span> <span class="token function">PersonClass</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">26</span><span class="token punctuation">)</span>taylor4<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Justin Bieber"</span><span class="token comment" spellcheck="true">//taylor4 = PersonClass(name: "Justin Bieber", age: 22)</span></code></pre><p>正如你所看到的，在使用常量的地方会发生差异：常量对象不能更改为指向新对象，但是你可以更改它的任何属性，而常量结构是完全固定的。</p><p>在处理集合(如数组)时，易变性是最常见的问题。这些是 <em>Swift</em> 中的值类型(万岁!)，但它们也可以是可变的——如果你将它们声明为 <em>var</em> ，你可以自由地添加和删除元素。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pro Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Pro Swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第二章 类型（Types）</title>
      <link href="/2019/09/04/pro-swift-yi-wen/chapter2-types/"/>
      <url>/2019/09/04/pro-swift-yi-wen/chapter2-types/</url>
      
        <content type="html"><![CDATA[<p>我最喜欢的 <em>Swift</em> 单行代码是使用<code>flatMap()</code>来对一个数组进行降维和过滤：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> myCustomViews <span class="token operator">=</span> allViews<span class="token punctuation">.</span>flatMap <span class="token punctuation">{</span> $<span class="token number">0</span> <span class="token keyword">as</span><span class="token operator">?</span> <span class="token builtin">MyCustomView</span> <span class="token punctuation">}</span></code></pre><p>这行代码看起来很简单，但它包含了很多很棒的 <em>Swift</em> 特性，如果你将其与 <em>Objective-C</em> 中最接近的开箱即用的特性进行比较，就会发现这些特性最为明显：</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">NSArray</span><span class="token operator">&lt;</span><span class="token builtin">MyCustomView</span> <span class="token operator">*</span><span class="token operator">></span> <span class="token operator">*</span>myCustomViews <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">NSArray</span><span class="token operator">&lt;</span><span class="token builtin">MyCustomView</span> <span class="token operator">*</span><span class="token operator">></span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">[</span>allViews filteredArrayUsingPredicate<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">NSPredicate</span> predicateWithBlock<span class="token punctuation">:</span><span class="token operator">^</span><span class="token function">BOOL</span><span class="token punctuation">(</span>id _Nonnull evaluatedObject<span class="token punctuation">,</span> <span class="token builtin">NSDictionary</span><span class="token operator">&lt;</span><span class="token builtin">NSString</span> <span class="token operator">*</span><span class="token punctuation">,</span>id<span class="token operator">></span> <span class="token operator">*</span> _Nullable bindings<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">[</span>evaluatedObject isKindOfClass<span class="token punctuation">:</span><span class="token punctuation">[</span><span class="token builtin">MyCustomView</span> <span class="token keyword">class</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><p>– <em>Matt Gallagher, CocoaWithLove.com</em> 的作者</p><h2 id="高效初始化器-Useful-initializers"><a href="#高效初始化器-Useful-initializers" class="headerlink" title="高效初始化器(Useful initializers)"></a>高效初始化器(Useful initializers)</h2><p>理解 <em>Swift</em> 中初始化器是如何工作的并不容易，但这也是你们很久以前学过的东西，所以我就不在这里重复了。相反，我想关注一些有趣的初始化器，它们可能有助你更有效地使用常见的 <em>Swift</em> 类型。</p><h3 id="重复值-Repeating-values"><a href="#重复值-Repeating-values" class="headerlink" title="重复值(Repeating values)"></a>重复值(Repeating values)</h3><p>我最喜欢的字符串和数组初始化器是 <code>repeat:count:</code>，它允许你快速创建大量值。例如，你可以通过在一些文本下面写等号来创建 <em>Markdown</em> 文本格式的标题，如下所示:</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">This</span> <span class="token keyword">is</span> a heading<span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">===</span><span class="token operator">==</span></code></pre><p><em>Markdown</em> 是一种很有用的格式，因为它可以被计算机解析，同时对人类也具有视觉吸引力，而且下划线为<code>repeat:count:</code> 提供了一个很好的例子。要使用这个初始化器，为其第一个参数指定一个字符串，并为其第二个参数指定重复的次数，如下所示:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> heading <span class="token operator">=</span> <span class="token string">"This is a heading"</span><span class="token keyword">let</span> underline <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">"="</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> heading<span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span></code></pre><p>你也可以对数组这样做：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> equalsArray <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">"="</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> heading<span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token builtin">count</span><span class="token punctuation">)</span></code></pre><p>这个数组初始化器足够灵活，你可以使用它非常容易地创建多维数组。例如，这创建了一个准备填充 <em>10x10</em> 数组:</p><pre class=" language-swift"><code class="language-swift"> <span class="token keyword">var</span> board <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span></code></pre><h3 id="转换为数字和从数字转换-Converting-to-and-from-numbers"><a href="#转换为数字和从数字转换-Converting-to-and-from-numbers" class="headerlink" title="转换为数字和从数字转换(Converting to and from numbers)"></a>转换为数字和从数字转换(Converting to and from numbers)</h3><p>当我看到这样的代码时，我头疼不已:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str1 <span class="token operator">=</span> <span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>someInteger<span class="token delimiter variable">)</span></span>"</span></code></pre><p>这是浪费和不必要的，但是字符串插值是一个很好的特性，使用它是值得原谅。事实上，我很确定我已经使用过它好几次了，毫无疑问！</p><p>但 <em>Swift</em> 有一个简单、更好的方法，可以使用初始化器根据整型创建字符串类型:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str2 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>someInteger<span class="token punctuation">)</span></code></pre><p>当使用这种方式进行转换时，事情会变得稍微困难一些，因为你可能会尝试传入一个无效的数字，例如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> int1 <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"elephant"</span><span class="token punctuation">)</span></code></pre><p>那么，这个初始化器将返回 <code>Int?</code> ：如果你给它一个有效的数字，你会得到一个整数，否则你会得到<code>nil</code>。</p><p>如果你不想要一个可选值，你应该对结果解包:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> int2 <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"1989"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>int2<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>或者，使用空合操作符（<code>??</code>）提供一个合理的默认值，如下所示:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> int3 <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"1989"</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token number">0</span><span class="token function">print</span><span class="token punctuation">(</span>int3<span class="token punctuation">)</span></code></pre><p><em>Swift</em> 在这两个初始化器上有一些处理不同变量基数的变体。例如，如果你想使用十六进制(以 <em>16</em> 为基数)，你可以让 <em>Swift</em> 给你一个十六进制数字的字符串表示形式:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str3 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">)</span></code></pre><p>这将把 <em>str3</em> 设置为 <strong>1c</strong>。如果你更喜欢 <strong>1C</strong>，即大写——请尝试以下方法:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> str4 <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token number">28</span><span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">,</span> uppercase<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">)</span></code></pre><p>要将其转换回整数—请记住它是可选值!——用这个:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> int4 <span class="token operator">=</span> <span class="token function">Int</span><span class="token punctuation">(</span><span class="token string">"1C"</span><span class="token punctuation">,</span> radix<span class="token punctuation">:</span> <span class="token number">16</span><span class="token punctuation">)</span></code></pre><h3 id="唯一的数组（Unique-arrays）"><a href="#唯一的数组（Unique-arrays）" class="headerlink" title="唯一的数组（Unique arrays）"></a>唯一的数组（Unique arrays）</h3><p>如果你有一个包含重复值的数组，并且希望找到一种快速删除重复值的方法，则你需要的找的是<code>Set</code>。这是一个内建的数据类型，具有与普通数组互相转换的初始化器，这意味着你只需使用初始化器即可快速高效地消除数组中的重复数据：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> scores <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token keyword">let</span> scoresSet <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span>scores<span class="token punctuation">)</span><span class="token keyword">let</span> uniqueScores <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>scoresSet<span class="token punctuation">)</span></code></pre><p>这就是它所需要的一切——难怪我这么喜欢集合！</p><h3 id="字典的容量（Dictionary-capacities）"><a href="#字典的容量（Dictionary-capacities）" class="headerlink" title="字典的容量（Dictionary capacities）"></a>字典的容量（Dictionary capacities）</h3><p>以一个简单的初始化器结尾：如果要单独向字典添加项，但是知道想添加多少项，请使用<code>minimumCapacity:initializer</code>创建字典，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> dictionary <span class="token operator">=</span> <span class="token builtin">Dictionary</span><span class="token operator">&lt;</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token operator">></span><span class="token punctuation">(</span>minimumCapacity<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span></code></pre><p>这有助于通过预先分配足够的空间来快速优化执行。注意：在后台，<em>Swift</em> 的字典增加了 <em>2</em> 的幂次方的容量，所以当你请求一个像 <em>100</em> 这样的非 <em>2</em> 的幂次方的容量时，你实际上会得到一个最小容量为 <em>128</em> 的字典。记住，这是最小容量——如果你想添加更多的对象，这不是问题。</p><h2 id="枚举（Enums）"><a href="#枚举（Enums）" class="headerlink" title="枚举（Enums）"></a>枚举（Enums）</h2><p>在模式匹配一章中，我已经讨论了枚举关联值，但这里我想重点讨论枚举本身，因为它们的功能非常强大。</p><p>让我们从一个非常简单的枚举开始，跟踪一些基本的颜色:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> unknown   <span class="token keyword">case</span> blue   <span class="token keyword">case</span> green   <span class="token keyword">case</span> pink   <span class="token keyword">case</span> purple   <span class="token keyword">case</span> red<span class="token punctuation">}</span></code></pre><p>如果你愿意，可以将所有<code>case</code>项写在一行上，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> unknown<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">,</span> pink<span class="token punctuation">,</span> purple<span class="token punctuation">,</span> red<span class="token punctuation">}</span></code></pre><p>为了便于测试，让我们用一个表示玩具的简单结构体来包装它：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Toy</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">let</span> color<span class="token punctuation">:</span> <span class="token builtin">Color</span><span class="token punctuation">}</span></code></pre><p><em>Swift</em> 的类型推断可以推断出<code>Toy</code>的<code>color</code>属性是一个<code>Color</code>枚举，这意味着在创建玩具结构体时不需要编写<code>Color.blue</code>。例如，我们可以创建两个这样的玩具：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> barbie <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Barbie"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>pink<span class="token punctuation">)</span><span class="token keyword">let</span> raceCar <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Lightning McQueen"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>red<span class="token punctuation">)</span></code></pre><h3 id="初始值（Raw-values）"><a href="#初始值（Raw-values）" class="headerlink" title="初始值（Raw values）"></a>初始值（Raw values）</h3><p>让我们从初始值开始：每个枚举项的基础数据类型。默认情况下，枚举没有初始值，因此如果需要初始值，则需要声明它。例如，我们可以给颜色一个这样的整型初始值：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span><span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> unknown<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">,</span> pink<span class="token punctuation">,</span> purple<span class="token punctuation">,</span> red<span class="token punctuation">}</span></code></pre><p>只需添加<code>:Int</code> <em>Swift</em> 将为每种颜色都指定了一个匹配的整数，从<em>0</em> 开始向上计数。也就是说，<code>unknown</code>等于 <em>0</em> ，<code>blue</code>等于 <em>1</em> ，以此类推。有时，默认值对你来说并没有用，所以如果需要，你可以为每个初始值指定单独的整数。或者，你可以指定一个不同的起点，使 <em>Xcode</em> 从那里开始计数。</p><p>例如，我们可以像这样为太阳系的四个行星创建一个枚举:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Planet</span><span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> mercury <span class="token operator">=</span> <span class="token number">1</span>   <span class="token keyword">case</span> venus   <span class="token keyword">case</span> earth   <span class="token keyword">case</span> mars   <span class="token keyword">case</span> unknown<span class="token punctuation">}</span></code></pre><p>通过明确指定水星的值为 <em>1</em>，<em>Xcode</em> 将从那里向上计数：金星是 <em>2</em>，地球是 <em>3</em>，火星是 <em>4</em>。</p><p>现在行星的编号是合理的，我们可以像这样得到任何的行星的初始值:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> marsNumber <span class="token operator">=</span> <span class="token builtin">Planet</span><span class="token punctuation">.</span>mars<span class="token punctuation">.</span>rawValue</code></pre><p>另一种方法并不那么容易：是的，既然我们已经有了初始值，你可以从一个数字创建一个<code>Planet</code> 枚举，但是这样做会创建一个可选的枚举。这是因为你可以尝试创建一个初始值为 <em>99</em> 的行星，而这个行星并不存在——至少目前还不存在。</p><p>幸运的是，我在行星枚举中添加了一个<code>unknown</code>，当请求无效的行星编号时，我们可以从其初始值创建行星枚举，并使用空值合并运算符提供合理的默认值：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> mars <span class="token operator">=</span> <span class="token function">Planet</span><span class="token punctuation">(</span>rawValue<span class="token punctuation">:</span> <span class="token number">556</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token builtin">Planet</span><span class="token punctuation">.</span>unknown</code></pre><p>对于行星来说，数字是可以的，但是当涉及到颜色时，你可能会发现使用字符串更容易。除非你有非常特殊的需要，否则只需指定<code>String</code>作为枚举的原始数据类型就足以为它们提供有意义的名称—— <em>Swift</em> 会自动将你的枚举名称映射到一个字符串。例如，这将打印 <strong><em>Pink</em></strong>:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span><span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> unknown<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">,</span> pink<span class="token punctuation">,</span> purple<span class="token punctuation">,</span> red<span class="token punctuation">}</span><span class="token keyword">let</span> pink <span class="token operator">=</span> <span class="token builtin">Color</span><span class="token punctuation">.</span>pink<span class="token punctuation">.</span>rawValue<span class="token function">print</span><span class="token punctuation">(</span>pink<span class="token punctuation">)</span></code></pre><p>不管初始值的数据类型是什么，或者是否有初始值，当枚举被用作字符串插值的一部分时，<em>Swift</em> 都会自动对枚举进行字符串化。但是，以这种方式使用并不会使它们变成字符串，所以如果你想调用任何字符串方法，你需要自己根据它们创建一个字符串。例如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> barbie <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Barbie"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>pink<span class="token punctuation">)</span><span class="token keyword">let</span> raceCar <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Lightning McQueen"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>red<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// regular string interpolation</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>name<span class="token delimiter variable">)</span></span> toy is <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>color<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// get the string form of the Color then call a method on it</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"The <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>name<span class="token delimiter variable">)</span></span> toy is \(barbie.color.rawValue.uppercased())"</span><span class="token punctuation">)</span></code></pre><h3 id="计算属性和方法-Computed-properties-and-methods"><a href="#计算属性和方法-Computed-properties-and-methods" class="headerlink" title="计算属性和方法(Computed properties and methods)"></a>计算属性和方法(Computed properties and methods)</h3><p>枚举没有结构体和类那么强大，但是它们允许你在其中封装一些有用的功能。例如，除非枚举存储的属性是静态的，否则不能给它们赋值，因为这样做没有意义，但是你可以添加在运行一些代码之后返回值的计算属性。</p><p>为了让你了解一些有用的内容，让我们向<code>Color</code>枚举添加一个计算属性，该属性将打印颜色的简要描述。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">Color</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> unknown<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> green<span class="token punctuation">,</span> pink<span class="token punctuation">,</span> purple<span class="token punctuation">,</span> red   <span class="token keyword">var</span> description<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>      <span class="token keyword">switch</span> <span class="token keyword">self</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> <span class="token punctuation">.</span>unknown<span class="token punctuation">:</span>         <span class="token keyword">return</span> <span class="token string">"the color of magic"</span>      <span class="token keyword">case</span> <span class="token punctuation">.</span>blue<span class="token punctuation">:</span>         <span class="token keyword">return</span> <span class="token string">"the color of the sky"</span>      <span class="token keyword">case</span> <span class="token punctuation">.</span>green<span class="token punctuation">:</span>         <span class="token keyword">return</span> <span class="token string">"the color of grass"</span>      <span class="token keyword">case</span> <span class="token punctuation">.</span>pink<span class="token punctuation">:</span>         <span class="token keyword">return</span> <span class="token string">"the color of carnations"</span>      <span class="token keyword">case</span> <span class="token punctuation">.</span>purple<span class="token punctuation">:</span>         <span class="token keyword">return</span> <span class="token string">"the color of rain"</span>      <span class="token keyword">case</span> <span class="token punctuation">.</span>red<span class="token punctuation">:</span>         <span class="token keyword">return</span> <span class="token string">"the color of desire"</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">let</span> barbie <span class="token operator">=</span> <span class="token function">Toy</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Barbie"</span><span class="token punctuation">,</span> color<span class="token punctuation">:</span> <span class="token punctuation">.</span>pink<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"This <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>name<span class="token delimiter variable">)</span></span> toy is <span class="token interpolation"><span class="token delimiter variable">\(</span>barbie<span class="token punctuation">.</span>color<span class="token punctuation">.</span>description<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span></code></pre><p>当然，计算属性只是封装方法的语法糖，所以你可以直接将方法添加到枚举中也就不足为奇了。现在让我们通过向<code>Color</code> 枚举添加两个新方法来实现这一点，<code>forBoys()</code>和<code>forGirls()</code>，根据颜色来判断一个玩具是为女孩还是男孩准备的——只需在我们刚刚添加的<code>description</code> 属性下面添加以下内容：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">forBoys</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">forGirls</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">}</span></code></pre><p>如果你想知道，根据颜色来决定哪个玩具是男孩的还是女孩的有点上世纪 <em>70</em> 年代的味道：这些方法都返回<code>true</code>是有原因的!</p><p>因此：我们的枚举现在有一个初始值、一个计算属性和一些方法。我希望你能明白为什么我把枚举描述为<strong>看起来很强大</strong>——它们可以做很多事情!</p><h2 id="数组-Arrays"><a href="#数组-Arrays" class="headerlink" title="数组(Arrays)"></a>数组(Arrays)</h2><p>数组是 <em>Swift</em> 的真正主力之一。当然，它们在大多数应用程序中都很重要，但是它们对泛型的使用使它们在添加一些有用功能的同时保证类型安全。我不打算详细介绍它们的基本用法；相反，我想向你介绍一些你可能不知道的有用方法。</p><p>第一：排序。只要数组存储的元素类型遵循<code>Comparable</code>协议，就会得到<code>sorted()</code>和<code>sort()</code>方法——前者返回一个已排序的数组，而后者修改调用它的数组。如果你不打算遵循<code>Comparable</code>协议，可以使用<code>sorted()</code>和<code>sort()</code>的替代版本，让你指定数据项应该如何排序。</p><p>为了演示下面的例子，我们将使用这两个数组:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> names <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Timothy"</span><span class="token punctuation">,</span> <span class="token string">"Tyler"</span><span class="token punctuation">,</span> <span class="token string">"Thomas"</span><span class="token punctuation">,</span> <span class="token string">"Tobias"</span><span class="token punctuation">,</span> <span class="token string">"Tabitha"</span><span class="token punctuation">]</span><span class="token keyword">let</span> numbers <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">]</span></code></pre><p>要按字母顺序排列<code>names</code>数组，使用<code>sorted()</code>或<code>sort()</code>方法取决于你的需要。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token builtin">sorted</span> <span class="token operator">=</span> names<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>一旦代码运行，<code>sorted</code>将包含<code>["Tabitha", "Taylor", "Thomas", "Timothy", "Tobias", "Tyler"]</code>。</p><p>如果你想编写自己的排序函数 - 如果你不采用<code>Comparable</code>则是必需的，否则是可选的 - 编写一个接受两个字符串的闭包，如果第一个字符串应该在排在第二个字符串之前，则返回<code>true</code>。</p><p>例如，我们可以编写一个字符串排序算法，它的行为与常规的字母排序相同，但它总是将名称 <strong><em>Taylor</em></strong> 放在前面。我敢肯定，这正是<code>Taylor Swift</code>(美国女歌手)想要的：</p><pre class=" language-swift"><code class="language-swift">names<span class="token punctuation">.</span><span class="token builtin">sort</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Comparing <span class="token interpolation"><span class="token delimiter variable">\(</span>$<span class="token number">0</span><span class="token delimiter variable">)</span></span> and <span class="token interpolation"><span class="token delimiter variable">\(</span>$<span class="token number">1</span><span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>$<span class="token number">0</span> <span class="token operator">==</span> <span class="token string">"Taylor"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">true</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> $<span class="token number">1</span> <span class="token operator">==</span> <span class="token string">"Taylor"</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token boolean">false</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> $<span class="token number">0</span> <span class="token operator">&lt;</span> $<span class="token number">1</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>该代码使用<code>sort()</code>而不是<code>sorted()</code>，这将使数组按适当位置排序，而不是返回一个新的排序数组。我还在其中添加了一个<code>print()</code>调用，这样你就可以确切地看到<code>sort()</code>是如何工作的。这是输出结果:</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">Comparing</span> <span class="token builtin">Timothy</span> and <span class="token builtin">Taylor</span><span class="token builtin">Comparing</span> <span class="token builtin">Tyler</span> and <span class="token builtin">Timothy</span><span class="token builtin">Comparing</span> <span class="token builtin">Thomas</span> and <span class="token builtin">Tyler</span><span class="token builtin">Comparing</span> <span class="token builtin">Thomas</span> and <span class="token builtin">Timothy</span><span class="token builtin">Comparing</span> <span class="token builtin">Thomas</span> and <span class="token builtin">Taylor</span><span class="token builtin">Comparing</span> <span class="token builtin">Tobias</span> and <span class="token builtin">Tyler</span><span class="token builtin">Comparing</span> <span class="token builtin">Tobias</span> and <span class="token builtin">Timothy</span><span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Tyler</span><span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Tobias</span><span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Timothy</span><span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Thomas</span><span class="token builtin">Comparing</span> <span class="token builtin">Tabitha</span> and <span class="token builtin">Taylor</span></code></pre><p>如你所见，随着算法的发展，名称可以显示为 <em>$0</em> 或 <em>$1</em>，这就是为什么我在自定义排序函数中比较这两种可能性的原因。</p><p>排序很容易，但采用<code>Comparable</code>还可以实现两个更有用的方法：<code>min()</code>和<code>max()</code>。就像<code>sort()</code>一样，如果不采用<code>Comparable</code>的方法，这些方法也可以接受一个闭包，但是代码是相同的，因为操作是相同的：A项应该出现在B项之前吗？</p><p>使用前面的<code>number</code>数组，我们可以在两行代码中找到数组中的最高值和最低值:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lowest <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> highest <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>对于字符串，<code>min()</code>返回排序后的第一个字符串，<code>max()</code>返回最后一个字符串。如果你尝试重用我为自定义排序提供的相同闭包，包括<code>print()</code>语句，你将看到<code>min()</code>和<code>max()</code>实际上比使用<code>sort()</code>更高效，因为它们不需要移动每一项。</p><h3 id="遵循Comparable协议-Conforming-to-Comparable"><a href="#遵循Comparable协议-Conforming-to-Comparable" class="headerlink" title="遵循Comparable协议(Conforming to Comparable)"></a>遵循Comparable协议(Conforming to Comparable)</h3><p>对于字符串和整型等基本数据类型，使用<code>sort()</code>、<code>min()</code>和<code>max()</code>非常简单。但是你怎么把别的东西完全分类呢，比如奶酪的种类或者狗的品种？我已经向你展示了如何编写自定义闭包，但是如果你必须进行多次排序，那么这种方法就会变得非常麻烦—你最终会复制代码，这将带来维护的噩梦。</p><p>更聪明的解决方案是实现<code>Comparable</code>协议，这反过来要求你使用操作符重载。稍后我们将对此进行更详细的讨论，但现在我只想向你展示足以进行比较的工作。首先，这里有一个基本的<code>Dog</code>结构，它包含一些信息:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Dog</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> breed<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">}</span></code></pre><p>为了便于测试，我们将创建三只 <strong>dog</strong> 并将它们放到数组里:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> poppy <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Poodle"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">let</span> rusty <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Labrador"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">let</span> rover <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Corgi"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token keyword">var</span> dogs <span class="token operator">=</span> <span class="token punctuation">[</span>poppy<span class="token punctuation">,</span> rusty<span class="token punctuation">,</span> rover<span class="token punctuation">]</span></code></pre><p>因为 <code>Dog</code>结构体没有遵循 <code>Comparable</code>协议，所以我们没有在<code>dogs</code>数组上获得简单的<code>sort()</code> 和 <code>ordered()</code>方法，我们只获得了需要自定义闭包才能运行的方法。</p><p>要使<code>Dog</code>遵循 <code>Comparable</code>协议，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Dog</span><span class="token punctuation">:</span> <span class="token builtin">Comparable</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> breed<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">}</span></code></pre><p>你会得到错误，没关系。</p><p>下一步是让第一次尝试它的人感到困惑的地方：你需要实现两个新函数，但是它们有一些不同寻常的名称，在处理操作符重载时需要一点时间来适应，这正是我们需要做的。</p><p>在<code>Dog</code>结构中添加这两个函数:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>age <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>age<span class="token punctuation">}</span><span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">==</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>age <span class="token operator">==</span> rhs<span class="token punctuation">.</span>age<span class="token punctuation">}</span></code></pre><p>需要说明的是，你的代码应该如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Dog</span><span class="token punctuation">:</span> <span class="token builtin">Comparable</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> breed<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">var</span> age<span class="token punctuation">:</span> <span class="token builtin">Int</span>   <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">&lt;</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>age <span class="token operator">&lt;</span> rhs<span class="token punctuation">.</span>age   <span class="token punctuation">}</span>   <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">==</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token builtin">Dog</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Bool</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> lhs<span class="token punctuation">.</span>age <span class="token operator">==</span> rhs<span class="token punctuation">.</span>age   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果你以前没有使用过运算符重载，那么这些函数名是不常见的，但是我希望你能够确切地了解它们的作用: 当你编写<code>dog1 &lt; dog2</code>时使用 <code>&lt;</code> 函数，当你写<code>dog1 == dog2</code>时使用<code>==</code>函数。</p><p>这两个步骤足以完全实现<code>Comparable</code>协议，因此你现在可以轻松地对<code>dogs</code>数组进行排序：</p><pre class=" language-swift"><code class="language-swift">dogs<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="添加和删除元素-Adding-and-removing-items"><a href="#添加和删除元素-Adding-and-removing-items" class="headerlink" title="添加和删除元素(Adding and removing items)"></a>添加和删除元素(Adding and removing items)</h3><p>几乎可以肯定，你已经使用过数组的<code>append()</code>、<code>insert()</code>和<code>remove(at:)</code>方法，但我想确保你知道添加和删除项的其他方法。</p><p>如果想将两个数组相加，可以使用<code>+</code>或<code>+=</code>来就地相加。例如:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> poppy <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Poodle"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token keyword">let</span> rusty <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Labrador"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token keyword">let</span> rover <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"Corgi"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token keyword">var</span> dogs <span class="token operator">=</span> <span class="token punctuation">[</span>poppy<span class="token punctuation">,</span> rusty<span class="token punctuation">,</span> rover<span class="token punctuation">]</span><span class="token keyword">let</span> beethoven <span class="token operator">=</span> <span class="token function">Dog</span><span class="token punctuation">(</span>breed<span class="token punctuation">:</span> <span class="token string">"St Bernard"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">8</span><span class="token punctuation">)</span>dogs <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">[</span>beethoven<span class="token punctuation">]</span></code></pre><p>当涉及到删除项目时，有两种有趣的方法可以删除最后一项:<code>removeLast()</code> 和 <code>popLast()</code>。它们都删除数组中的最后一项并将其返回给你，但是<code>popLast()</code>返回的是可选值，而<code>removeLast()</code>不是。考虑一下：<code>dogs.removeLast()</code>必须返回<code>Dog</code>结构的一个实例。 如果数组是空的会发生什么？答案是“坏事情”——你的应用会崩溃。</p><p>如果你试图删除一项时，你的数组可能是空的，那么使用<code>popLast()</code>，这样你就可以安全地检查返回值:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">let</span> dog <span class="token operator">=</span> dogs<span class="token punctuation">.</span><span class="token function">popLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// do stuff with `dog`</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：<code>removeLast()</code>有一个称为<code>removeFirst()</code>的对应项，用于删除和返回数组中的初始项。遗憾的是，<code>popLast()</code>没有类似的方法。</p></blockquote><h3 id="空和容量-Emptiness-and-capacity"><a href="#空和容量-Emptiness-and-capacity" class="headerlink" title="空和容量(Emptiness and capacity)"></a>空和容量(Emptiness and capacity)</h3><p>下面是我想展示的另外两个小技巧:  <code>isEmpty</code> 和 <code>reserveCapacity()</code></p><p>第一个是<code>isEmpty</code>，如果数组没有添加任何项，则返回<code>true</code>。 这比使用<code>someArray.count == 0</code>更短，更有效，但由于某种原因使用较少。</p><p> <code>reserveCapacity()</code>方法允许您告诉 <em>iOS</em> 打算在数组中存储多少项。这并不是一个严格的限制。如果你预留了 <em>10</em> 个容量，你可以继续存储 <em>20</em> 个，如果你想的话——但它允许 <em>iOS</em> 优化对象存储，确保你有足够的空间来容纳你的建议容量。</p><blockquote><p>警告：使用 <code>reserveCapacity()</code>不是一个免费的操作。在后台，<em>Swift</em> 将创建一个包含相同值的新数组，并为你需要的容量留出空间。它不只是扩展现有数组。这样做的原因是该方法保证得到的数组将具有连续存储(即所有项目彼此相邻存储而不是分散在 <em>RAM</em> 中）因此，<em>Swift</em> 会做大量的移动操作。即使你已经调用了<code>reserveCapacity()</code>，这也适用—尝试将这段代码放到一个 <em>Playground</em> 中，自己看看:</p></blockquote><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">let</span> start <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1000000</span><span class="token punctuation">)</span>array<span class="token punctuation">.</span><span class="token function">reserveCapacity</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span>array<span class="token punctuation">.</span><span class="token function">reserveCapacity</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token keyword">let</span> end <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Took <span class="token interpolation"><span class="token delimiter variable">\(</span>end<span class="token delimiter variable">)</span></span> seconds"</span><span class="token punctuation">)</span></code></pre><p>当这段代码运行时，你将看到调用<code>reserveCapacity()</code>时两次都会出现严重的暂停。因为<code>reserveCapacity()</code>是一个<code>O(n)</code>复杂度的调用(其中<code>n</code>是数组的<code>count</code>值)，所以应该在向数组添加项之前调用它。</p><h3 id="连续数组-Contiguous-arrays"><a href="#连续数组-Contiguous-arrays" class="headerlink" title="连续数组(Contiguous arrays)"></a>连续数组(Contiguous arrays)</h3><p><em>Swift</em> 提供了两种主要的数组，但几乎总是只使用一种。首先，让我们分解一下语法：你应该知道这两行代码在功能上是相同的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Int</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> array2 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>第一行是第二行的语法糖。到目前为止，一切都很简单。但是我想向你们介绍一下连续数组容器的重要性，它看起来是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array3 <span class="token operator">=</span> <span class="token builtin">ContiguousArray</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1000000</span><span class="token punctuation">)</span></code></pre><p>就是这样。连续数组具有你习惯使用的所有属性和方法—<code>count</code>、<code>sort()</code>、<code>min()</code>、<code>map()</code>等等—但因为所有项都保证是连续存储的，即你可以得到更好的表现。</p><p>苹果的官方文档说，当你需要 <em>C</em> 数组的性能时，应该使用连续数组，而当你想要<strong>针对 <em>Cocoa</em> 高效转换优化</strong>时，应该使用常规数组。文档还说，当与非类类型一起使用时，<code>Array</code>和<code>ContiguousArray</code>的性能是相同的，这意味着在使用类时，你肯定会得到性能上的改进。</p><p>原因很简单：<em>Swift</em> 数组可以桥接到<code>NSArray</code>，这是 <em>Objective-C</em> 开发人员使用的数组类型。 由于历史原因，<code>NSArray</code>无法存储值类型，例如整数，除非它们被包装在对象中。 因此，<em>Swift</em> 编译器可以很聪明：如果你创建一个包含值类型的常规 <em>Swift</em> 数组，它就知道你不能尝试将它桥接到<code>NSArray</code>，因此它可以执行额外的优化来提高性能。</p><p>也就是说，我发现连续数组无论如何都比数组快，即使是使用<code>Int</code>这样的基本类型。举个简单的例子，下面的代码把1到100万的数字加起来:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> array2 <span class="token operator">=</span> <span class="token builtin">Array</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token keyword">let</span> array3 <span class="token operator">=</span> <span class="token builtin">ContiguousArray</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token keyword">var</span> start <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>array2<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span><span class="token keyword">var</span> end <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Took <span class="token interpolation"><span class="token delimiter variable">\(</span>end<span class="token delimiter variable">)</span></span> seconds"</span><span class="token punctuation">)</span>start <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span>array3<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">+</span><span class="token punctuation">)</span>end <span class="token operator">=</span> <span class="token function">CFAbsoluteTimeGetCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> start<span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Took <span class="token interpolation"><span class="token delimiter variable">\(</span>end<span class="token delimiter variable">)</span></span> seconds"</span><span class="token punctuation">)</span></code></pre><p>当我运行这段代码时，数组花费 <em>0.25</em> 秒，连续数组花费 <em>0.13</em> 秒。考虑到我们只是循环了超过 <em>100</em> 万个元素，这并不是非常优秀，但如果你想在你的应用程序或游戏中获得额外的性能提升，你肯定应该尝试使用连续数组。</p><h2 id="集合-Sets"><a href="#集合-Sets" class="headerlink" title="集合(Sets)"></a>集合(Sets)</h2><p>了解集合和数组之间的区别 – 并知道哪一个在何时是正确的选择 - 是任何 <em>Swift</em> 开发人员工具箱中的一项重要技能。集合可以被认为是无序数组，不能包含重复元素。如果你多次添加同一个元素，它将只在集合中出现一次。缺少重复项和不跟踪顺序的组合允许集合比数组快得多，因为数据项是根据哈希而不是递增的整数索引存储的。</p><p>要将其置于上下文中，检查数组是否包含项，复杂度为<code>O(n)</code>，这意味着“它取决于你在数组中有多少元素”。这是因为<code>Array.contains()</code>需要从 <em>0</em> 开始检查每个元素，所以如果有 <em>50</em> 个元素，则需要执行 <em>50</em> 次检查。检查一个集合是否包含项，复杂度为<code>O(1)</code>，这意味着“无论你有多少元素，它始终以相同的速度运行”。这是因为集合的工作原理类似于字典：通过创建对象的 <em>hash</em> 生成键，而该键直接指向对象存储的位置。</p><h3 id="基础-The-basics"><a href="#基础-The-basics" class="headerlink" title="基础(The basics)"></a>基础(The basics)</h3><p>最好的实验方法是使用 <em>Playground</em> ，试着输入这个：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> set1 <span class="token operator">=</span> <span class="token builtin">Set</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>当它运行时，你将在输出窗口中看到 <strong><em>{ 5,2,3,1,4  }</em></strong>。就像我说的，集合是无序的，所以你可能会在 <em>Xcode</em> 窗口中看到一些不同的东西。</p><p>这将从数组中创建一个新的集合，但是你也可以从范围中创建它们，就像数组一样：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> set2 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">100</span><span class="token punctuation">)</span></code></pre><p>你还可以单独向它们添加项，尽管方法名为<code>insert()</code>而不是<code>append()</code>，以反映其无序性:</p><pre class=" language-swift"><code class="language-swift">set1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span>set1<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span></code></pre><p>若要检查集合中是否存在项，请使用像闪电一样快的<code>contains()</code>方法：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> set1<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Number 3 is in there!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>并使用<code>remove()</code>从集合中删除项：</p><pre class=" language-swift"><code class="language-swift">set1<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span></code></pre><h3 id="数组和集合-Arrays-and-sets"><a href="#数组和集合-Arrays-and-sets" class="headerlink" title="数组和集合(Arrays and sets)"></a>数组和集合(Arrays and sets)</h3><p>数组和集合一起使用时工作得很好，所以它们几乎可以互换也就不足为奇了。首先，数组和集合都有接受另一种类型的构造函数，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> set1 <span class="token operator">=</span> <span class="token builtin">Set</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">var</span> array1 <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span>set1<span class="token punctuation">)</span><span class="token keyword">var</span> set2 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span>array1<span class="token punctuation">)</span></code></pre><p>实际上，将数组转换为集合并返回是删除所有重复项的最快方法，而且只需两行代码。</p><p>其次，集合的一些方法返回数组而不是集合，因为这样做更有用。例如，集合上的<code>ordered()</code>、<code>map()</code>和<code>filter()</code>方法返回一个数组。</p><p>所以，虽然你可以像这样直接循环集合:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> number <span class="token keyword">in</span> set1 <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>…你也可以先将集合按合理的顺序排序，如下所示:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> number <span class="token keyword">in</span> set1<span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>像数组一样，集合使用<code>removeFirst()</code>方法从集合的前面删除项。 但是它的用途是不同的：因为集合是无序的，你真的不知道第一个项目是什么，所以<code>removeFirst()</code>实际上意味着“给我任何对象，以便我可以处理它。” 巧妙地，集合有一个popFirst()方法，而数组没有——我真希望知道为什么!</p><h3 id="集合操作-Set-operations"><a href="#集合操作-Set-operations" class="headerlink" title="集合操作(Set operations)"></a>集合操作(Set operations)</h3><p>集合附带了许多方法，允许你以有趣的方式操作它们。例如，你可以创建两个集合的并集，即两个集合的合并，如下所示:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> spaceships1 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Nostromo"</span><span class="token punctuation">,</span> <span class="token string">"Enterprise"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> spaceships2 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Voyager"</span><span class="token punctuation">,</span> <span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Executor"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> union <span class="token operator">=</span> spaceships1<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>spaceships2<span class="token punctuation">)</span></code></pre><p>当代码运行时，<code>union</code>将包含 <em>5</em> 个条目，因为重复的 “<em>Serenity</em>” 只出现一次。</p><p>另外两个有用的集合操作是<code>intersection()</code>和<code>symmetricDifference()</code>。前者返回一个只包含两个集合中存在的元素的新集合，而后者则相反:它只返回两个集合中不存在的元素。代码是这样的:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> intersection <span class="token operator">=</span> spaceships1<span class="token punctuation">.</span><span class="token function">intersection</span><span class="token punctuation">(</span>spaceships2<span class="token punctuation">)</span><span class="token keyword">let</span> difference <span class="token operator">=</span> spaceships1<span class="token punctuation">.</span><span class="token function">symmetricDifference</span><span class="token punctuation">(</span>spaceships2<span class="token punctuation">)</span></code></pre><p>当它运行时，<code>intersection</code>将包含<code>Serenity</code>，<code>difference</code>将包含<code>Nostromo</code>、<code>Enterprise</code>、<code>Voyager</code>和<code>Executor</code>。</p><blockquote><p>注意：<code>union()</code>、<code>intersection()</code>和 <code>symmetricDifference()</code>都有直接修改集合的替代方法，可以通过向方法前添加<code>form</code>来调用它们，<code>formUnion()</code>、<code>formIntersection()</code> 和 <code>formSymmetricDifference()</code>。</p></blockquote><p>集合有几个查询方法，根据提供的内容返回<code>true</code>或<code>false</code>。</p><p>这些方法是:</p><ul><li><strong>A.isSubset(of: B)</strong>: 如果集合 <em>A</em> 的所有项都在集合 <em>B</em> 中，则返回 <em>true</em> 。</li><li><strong>A.isSuperset(of: B)</strong>: 如果集合 <em>B</em> 的所有项都在集合 <em>A</em> 中，则返回 <em>true</em> 。</li><li><strong>A.isDisjoint(with: B)</strong>: 如果集合 <em>B</em> 的所有项都不在集合 <em>A</em> 中，则返回 <em>true</em> 。</li><li><strong>A.isStrictSubset(of: B)</strong>: 如果集合 <em>A</em> 的所有项都在集合 <em>B</em> 中，则返回 <em>true</em> ， 但是 <em>A</em> 和 <em>B</em> 不相等。</li><li><strong>A.isStrictSuperset(of: B)</strong>: 如果集合 <em>B</em> 的所有项都在集合 <em>A</em> 中，则返回 <em>true</em> ，但是 <em>A</em> 和 <em>B</em> 不相等。</li></ul><p>集合区分子集和严格子集，不同之处在于后者必须排除相同的集合。 也就是说，如果集合 <em>A</em> 中的每个项目也在集合 <em>B</em> 中，则集合 <em>A</em> 是集合 <em>B</em> 的子集。另一方面，如果集合 <em>A</em> 中的每个元素也在集合 <em>B</em> 中，则集合 <em>A</em> 是集合 <em>B</em> 的严格子集，但是集合 <em>B</em>至少包含集合 <em>A</em> 中缺少的一个项。</p><p>下面的代码分别演示了它们，我在注释中标记了每个方法的返回值：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> spaceships1 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Nostromo"</span><span class="token punctuation">,</span> <span class="token string">"Enterprise"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> spaceships2 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Voyager"</span><span class="token punctuation">,</span> <span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"StarDestroyer"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> spaceships3 <span class="token operator">=</span> <span class="token function">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">"Galactica"</span><span class="token punctuation">,</span> <span class="token string">"Sulaco"</span><span class="token punctuation">,</span> <span class="token string">"Minbari"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">let</span> spaceships1and2 <span class="token operator">=</span> spaceships1<span class="token punctuation">.</span><span class="token function">union</span><span class="token punctuation">(</span>spaceships2<span class="token punctuation">)</span>spaceships1<span class="token punctuation">.</span><span class="token function">isSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1and2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>spaceships1<span class="token punctuation">.</span><span class="token function">isSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>spaceships1<span class="token punctuation">.</span><span class="token function">isSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>spaceships1<span class="token punctuation">.</span><span class="token function">isStrictSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1and2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>spaceships1<span class="token punctuation">.</span><span class="token function">isStrictSubset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>spaceships1and2<span class="token punctuation">.</span><span class="token function">isSuperset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>spaceships1and2<span class="token punctuation">.</span><span class="token function">isSuperset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships3<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span>spaceships1and2<span class="token punctuation">.</span><span class="token function">isStrictSuperset</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> spaceships1<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>spaceships1<span class="token punctuation">.</span><span class="token function">isDisjoint</span><span class="token punctuation">(</span>with<span class="token punctuation">:</span> spaceships2<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span></code></pre><h3 id="NSCountedSet"><a href="#NSCountedSet" class="headerlink" title="NSCountedSet"></a>NSCountedSet</h3><p><em>Foundation</em> 库有一个专门的集合叫做<code>NSCountedSet</code>，它是一个具有扭曲(<strong>twist</strong>)的集合: 项仍然只能出现一次，但是如果你尝试多次添加它们，它将跟踪计数，就像它们确实存在一样。这意味着你可以获得非重复集合的所有速度，但是如果允许重复，你还可以计算项目出现的次数。</p><p>你可以根据需要从 <em>Swift</em> 数组或集合创建<code>NSCountedSet</code>。在下面的例子中，我创建了一个大型数组（带有重复项），将它全部添加到计数集，然后打印出两个值的计数:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> spaceships <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Nostromo"</span><span class="token punctuation">,</span> <span class="token string">"Enterprise"</span><span class="token punctuation">]</span>spaceships <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Voyager"</span><span class="token punctuation">,</span> <span class="token string">"Serenity"</span><span class="token punctuation">,</span> <span class="token string">"Star Destroyer"</span><span class="token punctuation">]</span>spaceships <span class="token operator">+</span><span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Galactica"</span><span class="token punctuation">,</span> <span class="token string">"Sulaco"</span><span class="token punctuation">,</span> <span class="token string">"Minbari"</span><span class="token punctuation">]</span><span class="token keyword">let</span> countedSet <span class="token operator">=</span> <span class="token function">NSCountedSet</span><span class="token punctuation">(</span>array<span class="token punctuation">:</span> spaceships<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>countedSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token string">"Serenity"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 2</span><span class="token function">print</span><span class="token punctuation">(</span>countedSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token string">"Sulaco"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span></code></pre><p>正如你所看到的，您可以使用<code>count(for:)</code>来检索一个元素在计数集合中出现的次数(理论上)。你可以使用<code>countedSet.allObjects</code>属性提取所有对象的数组，但要注意：<code>NSCountedSet</code>不支持泛型，因此你需要将其类型转换回<code>[String]</code>。</p><h2 id="元组-Tuples"><a href="#元组-Tuples" class="headerlink" title="元组(Tuples)"></a>元组(Tuples)</h2><p>元组类似于简化的匿名结构体：它们是携带不同信息字段的值类型，但不需要正式定义。由于缺少正式的定义，所以很容易创建和丢弃它们，所以当你需要一个函数返回多个值时，通常会使用它们。</p><p>在关于模式匹配和析构的章节中，我介绍了元组如何以其他方式使用——它们确实是无处不在的小东西。有多普遍？那么，考虑以下代码:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>思考一下： <code>result</code>常量具有什么数据类型？你可能已经猜到了本章的名称，它是一个元组: <code>()</code>。在后台，<em>Swift</em> 将 <em>Void</em> 数据类型(没有显式返回类型的函数的默认值)映射到一个空元组。</p><p>现在考虑一下这个：<em>Swift</em> 中的每一种类型——整数、字符串等等——实际上都是自身的一个单元素元组。请看下面的代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> int1<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token keyword">let</span> int2<span class="token punctuation">:</span> <span class="token builtin">Int</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>这段代码完全正确：将一个整数赋值给一个单元素元组和将一个单元素元组赋值给一个整数都做了完全相同的事情。正如 <em>Apple</em> 文档中所说，“如果括号中只有一个元素，那么(元组的)类型就是该元素的类型。”它们实际上是一样的，所以你甚至可以这样写：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singleTuple <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">)</span>singleTuple <span class="token operator">=</span> <span class="token number">69</span></code></pre><p>当 <em>Swift</em> 编译第一行时，它基本上忽略标签，将其变成一个包含整数的单元素元组——而整数又与整数相同。实际上，这意味着你不能给单元素元组添加标签——如果你试图强制一个数据类型，你会得到一个错误：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> thisIsAllowed <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token keyword">var</span> thisIsNot<span class="token punctuation">:</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>value<span class="token punctuation">:</span> <span class="token number">42</span><span class="token punctuation">)</span></code></pre><p>如果你没有从一个函数返回任何东西，你得到一个元组，如果你从一个函数返回几个值，你得到一个元组，如果你返回一个值，你实际上也得到一个元组。我认为可以肯定地说，不管您是否知道，您已经是一个频繁使用元组的用户了!</p><p>现在，我将在下面介绍元组的一些有趣的方面，但是首先你应该知道元组有几个缺点。具体来说，你不能向元组添加方法或让它们实现协议——如果这是你想要做的，那么你要寻找的是结构体。</p><h3 id="元组有类型-Tuples-have-types"><a href="#元组有类型-Tuples-have-types" class="headerlink" title="元组有类型(Tuples have types)"></a>元组有类型(Tuples have types)</h3><p>元组很容易被认为是数据的开放垃圾场，但事实并非如此:它们是强类型的，就像 <em>Swift</em> 中的其他所有东西一样。这意味着你不能改变一个元组的类型一旦它被创建-像这样的代码将无法编译：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span></code></pre><p>如果你不给元组的元素命名，你可以使用从 <em>0</em> 开始的数字来访问它们，就像这样：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>singer<span class="token punctuation">.</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre><p>如果元组中有元组(这并不少见)，则需要使用 <em>0.0</em> ，诸如此类：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">,</span> address<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token string">"555 Taylor Swift Avenue"</span><span class="token punctuation">,</span> <span class="token string">"No, this isn't real"</span><span class="token punctuation">,</span> <span class="token string">"Nashville"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>singer<span class="token punctuation">.</span><span class="token number">2.2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Nashville</span></code></pre><p>这是一种内置的行为，但并不意味着推荐使用它。你可以——通常也应该——给你的元素命名，这样你才能更明智地访问它们：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>singer<span class="token punctuation">.</span><span class="token builtin">last</span><span class="token punctuation">)</span></code></pre><p>这些名称是类型的一部分，所以这样的代码不会编译通过:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span>singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Justin"</span><span class="token punctuation">,</span> fish<span class="token punctuation">:</span> <span class="token string">"Trout"</span><span class="token punctuation">)</span></code></pre><h3 id="元组和闭包-Tuples-and-closures"><a href="#元组和闭包-Tuples-and-closures" class="headerlink" title="元组和闭包(Tuples and closures)"></a>元组和闭包(Tuples and closures)</h3><p>不能向元组添加方法，但可以添加闭包。我同意这种区别很好，但它很重要：向元组添加闭包就像添加任何其他值一样，实际上是将代码作为数据类型附加到元组。因为它不是一个方法，声明有一点不同，但这里有一个例子让你开始：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">,</span> sing<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>lyrics<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token keyword">in</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>lyrics<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>singer<span class="token punctuation">.</span><span class="token function">sing</span><span class="token punctuation">(</span><span class="token string">"Haters gonna hate"</span><span class="token punctuation">)</span></code></pre><p>注意:这些闭包不能访问同级元素，这意味着这样的代码不能工作：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"My name is <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token builtin">first</span><span class="token delimiter variable">)</span></span>: <span class="token interpolation"><span class="token delimiter variable">\(</span>lyrics<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span></code></pre><h3 id="返回多个值-Returning-multiple-values"><a href="#返回多个值-Returning-multiple-values" class="headerlink" title="返回多个值(Returning multiple values)"></a>返回多个值(Returning multiple values)</h3><p>元组通常用于从一个函数返回多个值。事实上，如果这是元组带给我们的唯一东西，那么与其他语言(包括 <em>Objective-C</em> ) 相比，它们仍然是 <em>Swift</em> 的一个重要特性。</p><p>下面是一个 <em>Swift</em> 函数在一个元组中返回多个值的例子：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> cloudCover<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"Sunny"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> weather <span class="token operator">=</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>weather<span class="token punctuation">.</span>type<span class="token punctuation">)</span></code></pre><p>当然，你不必指定元素的名称，但是这无疑是一种很好的实践，这样其他开发人员就知道应该期望什么。</p><p>如果你更喜欢析构元组返回函数的结果，那么也很容易做到：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span>type<span class="token punctuation">,</span> cloud<span class="token punctuation">,</span> high<span class="token punctuation">,</span> low<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>相比之下，如果 <em>Swift</em> 没有元组，那么我们将不得不依赖于返回一个数组和按需要进行类型转换，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">func</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">"Sunny"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token keyword">let</span> weather <span class="token operator">=</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">let</span> weatherType <span class="token operator">=</span> weather<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">String</span><span class="token keyword">let</span> weatherCloud <span class="token operator">=</span> weather<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Int</span><span class="token keyword">let</span> weatherHigh <span class="token operator">=</span> weather<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Int</span><span class="token keyword">let</span> weatherLow <span class="token operator">=</span> weather<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token keyword">as</span><span class="token operator">!</span> <span class="token builtin">Int</span></code></pre><p>或者更糟的是，使用<code>inout</code>变量，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fetchWeather</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token builtin">String</span><span class="token punctuation">,</span> cloudCover<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token builtin">Int</span><span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token keyword">inout</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    type <span class="token operator">=</span> <span class="token string">"Sunny"</span>    cloudCover <span class="token operator">=</span> <span class="token number">50</span>    high <span class="token operator">=</span> <span class="token number">32</span>    low <span class="token operator">=</span> <span class="token number">26</span> <span class="token punctuation">}</span><span class="token keyword">var</span> weatherType <span class="token operator">=</span> <span class="token string">""</span><span class="token keyword">var</span> weatherCloud <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">var</span> weatherHigh <span class="token operator">=</span> <span class="token number">0</span><span class="token keyword">var</span> weatherLow <span class="token operator">=</span> <span class="token number">0</span><span class="token function">fetchWeather</span><span class="token punctuation">(</span>type<span class="token punctuation">:</span> <span class="token operator">&amp;</span>weatherType<span class="token punctuation">,</span> cloudCover<span class="token punctuation">:</span> <span class="token operator">&amp;</span>weatherCloud<span class="token punctuation">,</span> high<span class="token punctuation">:</span> <span class="token operator">&amp;</span>weatherHigh<span class="token punctuation">,</span> low<span class="token punctuation">:</span> <span class="token operator">&amp;</span>weatherLow<span class="token punctuation">)</span></code></pre><p>说真的：如果<code>inout</code>是答案，你可能问错了问题。</p><h3 id="可选元组-Optional-tuples"><a href="#可选元组-Optional-tuples" class="headerlink" title="可选元组(Optional tuples)"></a>可选元组(Optional tuples)</h3><p>元组可以包含可选元素，也可以有可选元组。这听起来可能相似，但差别很大：可选元素是元组中的单个项，如<code>String?</code> 和 <code>Int?</code> ，而可选元组是整个结构可能存在也可能不存在。</p><p>具有可选元素的元组必须存在，但其可选元素可以为<code>nil</code>。可选元组必须填充其所有元素，或者是<code>nil</code>。具有可选元素的可选元组可能存在，也可能不存在，并且其每个可选元素可能存在，也可能不存在。</p><p>当处理可选元组时，<em>Swift</em> 不能使用类型推断，因为元组中的每个元素都有自己的类型。所以，你需要明确声明你想要什么，就像这样：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> optionalElements<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">)</span><span class="token keyword">let</span> optionalTuple<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span><span class="token keyword">let</span> optionalBoth<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">)</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span></code></pre><p>一般来说，可选元素很常见，可选元组就不那么常见了。</p><h3 id="比较元组-Comparing-tuples"><a href="#比较元组-Comparing-tuples" class="headerlink" title="比较元组(Comparing tuples)"></a>比较元组(Comparing tuples)</h3><p><em>Swift</em> 允许你比较最多拥有 <em>6</em> 个参数数量的元组，只要它们具有相同的类型。这意味着您可以使用<code>==</code>比较包含最多 <em>6</em> 个项的元组，如果一个元组中的所有 <em>6</em> 个项都匹配第二个元组中的对应项，则返回<code>true</code>。</p><p>例如，下面的代码会打印“No match”：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span><span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Justin"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Bieber"</span><span class="token punctuation">)</span><span class="token keyword">if</span> singer <span class="token operator">==</span> person <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Match!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No match"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>但是要注意：元组比较忽略了元素标签，只关注类型，这可能会产生意想不到的结果。例如，下面的代码将打印“Match!”，即使元组标签不同：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> singer <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span><span class="token keyword">let</span> bird <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor"</span><span class="token punctuation">,</span> breed<span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span><span class="token keyword">if</span> singer <span class="token operator">==</span> bird <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Match!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No match"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="别名-Typealias"><a href="#别名-Typealias" class="headerlink" title="别名(Typealias)"></a>别名(Typealias)</h3><p>你已经看到了元组是多么强大、灵活和有用，但是有时候你可能想要将一些东西形式化。给你一个斯威夫特主题的例子，考虑这两个元组，代表泰勒·斯威夫特的父母:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> father <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Scott"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Swift"</span><span class="token punctuation">)</span><span class="token keyword">let</span> mother <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token string">"Andrea"</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token string">"Finlay"</span><span class="token punctuation">)</span></code></pre><p>(不，我没有泰勒·斯威夫特的资料，但我可以用维基百科!)</p><p>当他们结婚时，安德里亚·芬利变成了安德里亚·斯威夫特，他们成为了夫妻。我们可以写一个简单的函数来表示这个事件：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">marryTaylorsParents</span><span class="token punctuation">(</span>man<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span> woman<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>husband<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">,</span> wife<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span>man<span class="token punctuation">,</span> <span class="token punctuation">(</span>woman<span class="token punctuation">.</span><span class="token builtin">first</span><span class="token punctuation">,</span> man<span class="token punctuation">.</span><span class="token builtin">last</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>注：我用了 “<em>man<em>” 和 “</em>wife*” ，还让妻子改成了她丈夫的姓，因为 *Taylor Swift</em> 的父母就是这么做的。很明显，这只是一种婚姻形式，我希望你能理解这是一个简化的例子，而不是一个政治声明。</p><p><code>father</code>元组和<code>mother</code>元组单独看起来足够好，但是<code>marryTaylorsParents()</code>函数看起来相当糟糕。一次又一次地重复<code>(first: String, last: String)</code>会使它很难阅读，也很难更改。</p><p><em>Swift</em> 的解决方案很简单: <code>typealias</code>关键字。这并不是特定于元组的，但在这里它无疑是最有用的：它允许你为类型附加一个替代名称。例如，我们可以创建这样一个 <code>typealias</code>：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">typealias</span> <span class="token builtin">Name</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">first</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">last</span><span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span></code></pre><p>使用这个函数，<code>marryTaylorsParents()</code>函数明显变短：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">marryTaylorsParents</span><span class="token punctuation">(</span>man<span class="token punctuation">:</span> <span class="token builtin">Name</span><span class="token punctuation">,</span> woman<span class="token punctuation">:</span> <span class="token builtin">Name</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span>husband<span class="token punctuation">:</span> <span class="token builtin">Name</span><span class="token punctuation">,</span> wife<span class="token punctuation">:</span> <span class="token builtin">Name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span>man<span class="token punctuation">,</span> <span class="token punctuation">(</span>woman<span class="token punctuation">.</span><span class="token builtin">first</span><span class="token punctuation">,</span> man<span class="token punctuation">.</span><span class="token builtin">last</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="范型-Generics"><a href="#范型-Generics" class="headerlink" title="范型(Generics)"></a>范型(Generics)</h2><p>尽管泛型在 <em>Swift</em> 中是一个高级主题，但你一直在使用它们：<code>[String]</code>是你使用数组结构存储字符串的一个例子，这是泛型的一个例子。事实上，使用泛型很简单，但是创建泛型需要一点时间来适应。在本章中，我将演示如何(以及为什么!)创建自己的泛型，从函数开始，然后是结构体，最后是包装 <em>Foundation</em>类型。</p><p>让我们从一个简单的问题开始，这个问题演示了泛型是什么以及它们为什么重要：我们将创建一个非常简单的泛型函数。</p><p>设想一个函数，它被设计用来打印关于字符串的一些调试信息。它可能是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">inspectString</span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Received String with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">inspectString</span><span class="token punctuation">(</span><span class="token string">"Haters gonna hate"</span><span class="token punctuation">)</span></code></pre><p>现在让我们创建相同的函数来打印关于整数的信息：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">inspectInt</span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Received Int with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">inspectInt</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span></code></pre><p>现在让我们创建打印关于 <em>Double</em> 类型的信息的相同函数。实际上……我们不需要。这显然是非常枯燥的代码，我们需要将其扩展到浮点数、布尔值、数组、字典等等。有一种更智能的解决方案称为泛型编程，它允许我们编写处理稍后指定类型的函数。<em>Swift</em> 中的通用代码使用尖括号<code>&lt;</code>和<code>&gt;</code>，所以它非常明显!</p><p>要创建<code>inspectString()</code>函数的泛型形式，可以这样写：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> inspect<span class="token operator">&lt;</span><span class="token builtin">SomeType</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> <span class="token builtin">SomeType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span></code></pre><p>注意<code>SomeType</code>的用法：在函数名后面的尖括号中，用于描述<code>value</code>参数。尖括号里的第一个是最重要的，因为它定义了你的占位符数据类型：<code>inspect&lt;SomeType&gt;()</code>意味着“一个名为<code>inspect()</code>的函数,可以使用任何类型的数据类型,但是无论使用的数据类型是什么,我想把它称为<code>SomeType</code>。因此，参数<code>value: SomeType</code>现在应该更有意义了：<code>SomeType</code>将被用于调用函数的任何数据类型替换。</p><p>稍后你将看到，占位符数据类型也用于返回值。但是首先，这里是<code>inspect()</code>函数的最终版本，它输出正确的信息，无论向它抛出什么数据：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> inspect<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">inspect</span><span class="token punctuation">(</span><span class="token string">"Haters gonna hate"</span><span class="token punctuation">)</span><span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">56</span><span class="token punctuation">)</span></code></pre><p>我使用了<code>type(of:)</code>函数，以便 <em>Swift</em>正确地输出 “<em>String</em>”、“<em>Int</em>” 等。注意，我还使用了<code>T</code>而不是某种类型，这是一种常见的编码约定:第一个占位符数据类型名为<code>T</code>，第二个<code>U</code>和第三个<code>V</code>，以此类推。在实践中，我发现这个约定没有帮助，也不清楚，所以尽管我将在这里使用它，只是因为你必须习惯它。</p><p>现在，你可能想知道泛型给这个函数带来了什么好处——难道它就不能为它的参数类型使用泛型吗?在这种情况下可以，因为占位符只使用一次，所以这在功能上是相同的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>但是，如果我们希望函数接受相同类型的两个参数，那么<code>Any</code>和占位符之间的区别就会变得更加明显。例如:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> inspect<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value1<span class="token punctuation">:</span> T<span class="token punctuation">,</span> <span class="token number">_</span> value2<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"1. Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value1<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value1<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"2. Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value2<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value2<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>现在接受<code>T</code>类型的两个参数，这是占位符数据类型。同样，我们不知道这将是什么，这就是为什么我们给它一个抽象的名称，如 “<em>T</em> ”，而不是一个特定的数据类型，如<code>Int</code>或<code>String</code>。然而，这两个参数的类型都是<code>T</code>，这意味着无论最终是什么类型，它们都必须是相同的类型。所以，这个代码是合法的：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">)</span></code></pre><p>但这是行不通的，因为它混合了数据类型：</p><pre class=" language-swift"><code class="language-swift"><span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"Dolphin"</span><span class="token punctuation">)</span></code></pre><p>如果我们对数据类型使用了<code>Any</code>参数，那么 <em>Swift</em> 就不能确保两个参数都是相同的类型——一个可以是<code>Int</code>，另一个可以是<code>String</code>。所以，这段代码将是正确的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">_</span> value1<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">,</span> <span class="token number">_</span> value2<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"1. Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value1<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value1<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"2. Received <span class="token interpolation"><span class="token delimiter variable">\(</span><span class="token function">type</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> value2<span class="token punctuation">)</span><span class="token delimiter variable">)</span></span> with the value <span class="token interpolation"><span class="token delimiter variable">\(</span>value2<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">inspect</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">,</span> <span class="token string">"Dolphin"</span><span class="token punctuation">)</span></code></pre><h3 id="范型限制-Limiting-generics"><a href="#范型限制-Limiting-generics" class="headerlink" title="范型限制(Limiting generics)"></a>范型限制(Limiting generics)</h3><p>你常常希望限制泛型，以便它们只能对类似类型的数据进行操作，而 <em>Swift</em> 使这一点变得既简单又容易。下一个函数将对任意两个整数进行平方，不管它们是<code>Int</code>、<code>UInt</code>、<code>Int64</code>，等等：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> square<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Integer</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T <span class="token punctuation">{</span>   <span class="token keyword">return</span> value <span class="token operator">*</span> value<span class="token punctuation">}</span></code></pre><p>注意，我为返回值添加了一个占位符数据类型。在本例中，它意味着函数将返回与它接受的数据类型相同的值。</p><p>扩展<code>square()</code>以支持其他类型的数字(如双精度和浮点数)比较困难，因为没有覆盖所有内置数字类型的协议。我们来创建一个：</p><pre class=" language-swift"><code class="language-swift">protocol <span class="token builtin">Numeric</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token keyword">func</span> <span class="token operator">*</span><span class="token punctuation">(</span>lhs<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">,</span> rhs<span class="token punctuation">:</span> <span class="token keyword">Self</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token keyword">Self</span><span class="token punctuation">}</span></code></pre><p>它不包含任何代码，它只定义了一个名为<code>Numeric</code>的协议，并声明任何符合该协议的东西都必须能够自我相乘。我们想把这个协议应用到 <em>Float</em> 、<em>Double</em> 和 <em>Int</em> ，所以在协议下面加上这三行：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">extension</span> <span class="token builtin">Float</span><span class="token punctuation">:</span> <span class="token builtin">Numeric</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">extension</span> <span class="token builtin">Double</span><span class="token punctuation">:</span> <span class="token builtin">Numeric</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token keyword">extension</span> <span class="token builtin">Int</span><span class="token punctuation">:</span> <span class="token builtin">Numeric</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><p>有了这个新协议，你可以满足任何你想要的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> square<span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Numeric</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token number">_</span> value<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T <span class="token punctuation">{</span>   <span class="token keyword">return</span> value <span class="token operator">*</span> value<span class="token punctuation">}</span><span class="token function">square</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token function">square</span><span class="token punctuation">(</span><span class="token number">42.556</span><span class="token punctuation">)</span></code></pre><h3 id="创建泛型数据类型-Creating-a-generic-data-type"><a href="#创建泛型数据类型-Creating-a-generic-data-type" class="headerlink" title="创建泛型数据类型(Creating a generic data type)"></a>创建泛型数据类型(Creating a generic data type)</h3><p>既然你已经掌握了泛型函数，让我们进一步了解完全泛型数据类型:我们将创建一个泛型结构。在创建泛型数据类型时，需要将占位符数据类型声明为结构名称的一部分，然后可以根据需要在每个属性和方法中使用该占位符。</p><p>我们将要构建的结构名为 <em>deque<em>，这是一种常见的抽象数据类型，意思是“双端队列”。常规队列是将东西添加到队列末尾，然后从队列前端删除它们的队列。</em>deque</em> 是一个队列，你可以将内容添加到开头或结尾，也可以从开头或结尾删除内容。我选择在这里使用<em>deque*，因为重用 *Swift</em> 的内置数组非常简单——这里的关键是概念，而不是实现!</p><p>为了创建 <em>deque</em> 结构，我们将给它一个存储数组属性，它本身是通用的，因为它需要保存 <em>deque</em> 存储的任何数据类型。我们还将添加四个方法: <code>pushBack()</code> 和 <code>pushFront()</code> 将接受类型为<code>T</code>的参数并将其添加到正确的位置，而<code>popBack()</code>和<code>popFront()</code>将返回一个<code>T?</code>(占位符可选数据类型)，如果存在值，它将从后面或前面返回值。</p><p>只有一个很小的复杂性，那就是数组没有返回<code>T?</code>的<code>popFirst()</code>方法，因此我们需要添加一些额外的代码，以便在数组为空时运行。这是代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> deque<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> array <span class="token operator">=</span> <span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">pushBack</span><span class="token punctuation">(</span><span class="token number">_</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>      array<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>    <span class="token punctuation">}</span>   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">pushFront</span><span class="token punctuation">(</span><span class="token number">_</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>      array<span class="token punctuation">.</span><span class="token function">insert</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> at<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">popBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T<span class="token operator">?</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">popLast</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">popFront</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> T<span class="token operator">?</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> array<span class="token punctuation">.</span><span class="token builtin">isEmpty</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token constant">nil</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> array<span class="token punctuation">.</span><span class="token function">removeFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>有了这个结构，我们可以立即开始使用它：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> testDeque <span class="token operator">=</span> deque<span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>testDeque<span class="token punctuation">.</span><span class="token function">pushBack</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>testDeque<span class="token punctuation">.</span><span class="token function">pushFront</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>testDeque<span class="token punctuation">.</span><span class="token function">pushFront</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>testDeque<span class="token punctuation">.</span><span class="token function">popBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="使用Cocoa类型-Working-with-Cocoa-types"><a href="#使用Cocoa类型-Working-with-Cocoa-types" class="headerlink" title="使用Cocoa类型(Working with Cocoa types)"></a>使用Cocoa类型(Working with Cocoa types)</h3><p><em>Cocoa</em> 数据类型—— <code>NSArray</code>、<code>NSDictionary</code> 等等——从 <em>Swift</em> 最早的版本开始就可以使用了，但是它们很难使用，因为 <em>Objective-C</em> 对泛型的支持是最近的，也是有限的。</p><p><code>NSCountedSet</code> 是我最喜欢的基础类型之一，它根本不支持泛型。这意味着你失去了 <em>Swift</em> 编译器赋予你的自动类型安全，而这又让你离 <em>JavaScript</em> 程序员更近了一步——你不想这样吧？ 当然不。</p><p>幸运的是，我将向你演示如何通过围绕 <code>NSCountedSet</code> 创建泛型包装来创建自己的泛型数据类型。</p><p>这就像一个常规集合，每个条目只存储一次，但是它还有一个额外的好处，那“你添加了 <em>20</em> 次数字 <em>5</em> ”，尽管实际上它只在那里出现过一次。</p><p>这个的基本代码并不难，尽管你需要导入 <em>Foundation</em> 来访问<code>NSCountedSet</code> :</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">struct</span> <span class="token builtin">CustomCountedSet</span><span class="token operator">&lt;</span>T<span class="token punctuation">:</span> <span class="token builtin">Any</span><span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> internalSet <span class="token operator">=</span> <span class="token function">NSCountedSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">_</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>      internalSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token number">_</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token punctuation">{</span>      internalSet<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">func</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span> obj<span class="token punctuation">:</span> T<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> internalSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> obj<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>有了新的数据类型，你可以这样使用它:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> countedSet <span class="token operator">=</span> <span class="token builtin">CustomCountedSet</span><span class="token operator">&lt;</span><span class="token builtin">String</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>countedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>countedSet<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span>countedSet<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token keyword">var</span> countedSet2 <span class="token operator">=</span> <span class="token builtin">CustomCountedSet</span><span class="token operator">&lt;</span><span class="token builtin">Int</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span>countedSet2<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>countedSet2<span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token keyword">for</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span></code></pre><p>我们的结构体所做的就是包装<code>NSCountedSet</code>使其类型安全，但这总是一个受欢迎的改进。考虑到苹果在 <em>Swift 3</em> 中的发展方向，如果他们在未来将<code>NSCountedSet</code>重新实现为一个通用的基于结构体的<code>CountedSet</code>，我不会感到惊讶——让我们拭目以待!</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pro Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Pro Swift </tag>
            
            <tag> 范型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一章 语法（Syntax）</title>
      <link href="/2019/09/03/pro-swift-yi-wen/chapter1-syntax/"/>
      <url>/2019/09/03/pro-swift-yi-wen/chapter1-syntax/</url>
      
        <content type="html"><![CDATA[<p>当知道不需要重写声明时，对属性和方法使用<code>final</code>。 这允许编译器用直接调用替换动态派发调用。甚至可以通过将属性附加到类本身，将整个类标记为<code>final</code>。<br>– <em>Wendy Lu (@wendyluwho),Pinterest</em> 的 <em>iOS</em> 工程师</p><h2 id="模式匹配"><a href="#模式匹配" class="headerlink" title="模式匹配"></a>模式匹配</h2><p><code>Switch/case</code>不是一个新概念：<strong>插入一个值，然后执行几个操作过程中的一个</strong>。<em>Swift</em> 对安全的关注增加了对混编的要求，所有可能的情况都要满足––如果没有启用特定的警告，你将无法在 <em>C</em> 中获得某些信息，但这是相当微不足道的。</p><p><em>Swift</em> 的<code>switch</code>语法之所以有趣，归功于它灵活、富有表现力的模式匹配。更有趣的是，自从 <em>Swift</em> 发布以来，大部分模式匹配都被扩展到了其他地方，所以在<code>if</code>条件和<code>for</code>循环中也可以使用同样灵活、有表现力的语法。</p><p>不可否认，如果你在深水区跳入水中，你更可能下沉而不是游泳，所以我想从基本的例子开始进行研究。为了刷新你的记忆，这里有一个基本的<code>switch</code>语句：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">"twostraws"</span><span class="token keyword">switch</span> name <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token string">"bilbo"</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token string">"twostraws"</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Authentication failed"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>当你处理一个简单的字符串时，这非常简单，但是当处理两个或多个值时，事情就变得更加复杂了。例如，如果我们想验证一个名称和密码，我们将把它们作为一个元组来计算：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">"twostraws"</span><span class="token keyword">let</span> password <span class="token operator">=</span> <span class="token string">"fr0st1es"</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如果你愿意，可以将这两个值组合成一个元组，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> authentication <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"twostraws"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span><span class="token keyword">switch</span> authentication <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在这种情况下，元组的两个部分都必须与<code>switch</code>匹配才能执行它。</p><h3 id="部分匹配"><a href="#部分匹配" class="headerlink" title="部分匹配"></a>部分匹配</h3><p>在处理元组时，有时需要部分匹配：<strong>你关心某些值是什么，但不关心其他值</strong>。在这种情况下，使用下划线表示<strong>任何值都可以</strong>，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> authentication <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"twostraws"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">,</span> ipAddress<span class="token punctuation">:</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span><span class="token keyword">switch</span> authentication <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>记住：<em>Swift</em> 将采用它发现的第一个匹配的案例，因此你需要确保首先查找最具体的内容。例如，下面的代码将打印 <em>You could be anybody!</em> 因为第一种情况会立即匹配，即使之后的案例会<strong>更好</strong>匹配，因为它们匹配的内容更多：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> authentication <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You could be anybody!"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson!"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>最后，如果你只想匹配元组的一部分，但仍然想知道另一部分是什么，那么应该使用<code>let</code>语法。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> authentication <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"bilbo"</span><span class="token punctuation">,</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Bilbo Baggins!"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token keyword">let</span> password<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, Paul Hudson: your password was <span class="token interpolation"><span class="token delimiter variable">\(</span>password<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="匹配计算元组"><a href="#匹配计算元组" class="headerlink" title="匹配计算元组"></a>匹配计算元组</h3><p>到目前为止，我们的介绍已经覆盖了大多数开发人员使用模式匹配语法的基本范围。从这里开始，我想举一些其他不太为人所知的有用的模式匹配技术的例子。</p><p>元组最常使用静态值创建，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Paul"</span><span class="token punctuation">,</span> <span class="token string">"Hudson"</span><span class="token punctuation">)</span></code></pre><p>但元组和其他任何数据结构一样，都可以使用动态代码创建。当你希望将元组中的值范围缩小到较小的子集，以便只需要少数<code>case</code>语句时，这一点特别有用。</p><p>为了给你一个实际的例子，考虑 <strong><em>fizz buzz</em></strong> 测试：编写一个接受任何数字的函数，如果数字被 <em>3</em> 整除，则返回 <code>fizz</code>；如果数字被 <em>5</em> 整除，则返回 <code>buzz</code>；如果数字被 <em>3</em> 和 <em>5</em> 整除，则返回<code>fizzbuzz</code>；在其他情况下，返回原始输入数字。</p><p>我们可以计算一个元组来解决这个问题，然后将该元组传递到一个<code>switch</code>中以创建正确的输出。代码如下：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fizzbuzz</span><span class="token punctuation">(</span>number<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>   <span class="token keyword">switch</span> <span class="token punctuation">(</span>number <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">,</span> number <span class="token operator">%</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token string">"Fizz"</span>   <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token string">"Buzz"</span>   <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token string">"FizzBuzz"</span>   <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">fizzbuzz</span><span class="token punctuation">(</span>number<span class="token punctuation">:</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>这种方法将大的输入空间(任何数字)分解为真和假的简单组合，然后在<code>case</code>语句中使用元组模式匹配来选择正确的输出。</p><h3 id="循环-Loops"><a href="#循环-Loops" class="headerlink" title="循环(Loops)"></a>循环(Loops)</h3><p>正如你所看到的，使用元组的一部分进行模式匹配非常简单：你可以告诉 <em>Swift</em> 应该匹配什么，使用<code>let</code>将值绑定到局部常量，或者使用<code>_</code>表示你不关心值是什么。</p><p>在处理循环时，我们可以使用相同的方法，这允许我们只在项与我们指定的条件匹配时遍历项。让我们再次从一个基本示例开始：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> twostraws <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"twostraws"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span><span class="token keyword">let</span> bilbo <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"bilbo"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"bagg1n5"</span><span class="token punctuation">)</span><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"taylor"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span><span class="token keyword">let</span> users <span class="token operator">=</span> <span class="token punctuation">[</span>twostraws<span class="token punctuation">,</span> bilbo<span class="token punctuation">,</span> taylor<span class="token punctuation">]</span><span class="token keyword">for</span> user <span class="token keyword">in</span> users <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这将创建一个元组数组，然后循环遍历每个元组并打印其<code>name</code>的值。</p><p>就像我们前面看到的<code>switch</code>块一样，我们可以用<code>case</code>和元组来匹配<br>元组中的特定值。在之前的循环下面添加以下代码:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token string">"twostraws"</span><span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span> <span class="token keyword">in</span> users <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User twostraws has the password fr0st1es"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>我们也有相同的语法来将局部常量绑定到每个元组的值，例如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token punctuation">(</span><span class="token keyword">let</span> name<span class="token punctuation">,</span> <span class="token keyword">let</span> password<span class="token punctuation">)</span> <span class="token keyword">in</span> users <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the password <span class="token interpolation"><span class="token delimiter variable">\(</span>password<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>不过，通常情况下，最好将<code>let</code>重新放置为：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token keyword">in</span> users <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the password <span class="token interpolation"><span class="token delimiter variable">\(</span>password<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>神奇的是，当你把这两种方法结合起来的时候，在语法上和我们已经看到的<code>switch</code>例子是一样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">)</span> <span class="token keyword">in</span> users <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"User <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the password \"fr0st1es\""</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>它过滤<code>users</code>数组，这样只有密码为<code>fr0st1es</code>的项才会在循环中使用，然后在循环中创建一个<code>name</code>常量供你使用。</p><p>如果你正盯着<code>for case let</code>，看到三个完全不同的关键字混在一起，不要担心：除非有人向你解释它，否则它做什么并不明显，而且要花一点时间才能理解。但我们才刚刚开始…</p><h3 id="匹配可选值-Matching-optionals"><a href="#匹配可选值-Matching-optionals" class="headerlink" title="匹配可选值(Matching optionals)"></a>匹配可选值(Matching optionals)</h3><p><em>Swift</em> 有两种匹配可选值的方法，你很可能会同时遇到这两种方法。首先是<br>使用<code>.some</code>和<code>.none</code>来匹配<strong>有值</strong>和<strong>没有值</strong>，在下面的代码中，它用于检查值并将它们绑定到本地常量:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"twostraws"</span><span class="token keyword">let</span> password<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"fr0st1es"</span><span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token keyword">none</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Please enter a password."</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>由于<code>name</code>和<code>password</code>用于输入常量和本地绑定的常量，这段代码变得更加容易混淆。但是，它们是不同的东西，这就是为什么 <code>print("Hello,\(name)")</code> 不会打印 <em>Hello, Optional(“twostraws”)</em> —— 这里所使用的<code>name</code>是本地绑定展开的可选名称。</p><p>如果想更容易阅读，下面是相同的代码，不同的名称用于匹配的常量：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>matchedName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>matchedPassword<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>matchedName<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>matchedName<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token keyword">none</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Please enter a password."</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><em>Swift</em> 匹配可选值的第二种方法是使用更简单的语法，尽管如果你害怕可选值，这只会让情况变得更糟:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> password<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token operator">?</span><span class="token punctuation">,</span> password<span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Hello, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>username<span class="token operator">?</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Please enter a password."</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Who are you?"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这一次问号的工作方式与可选链类似：<strong>仅当找到值时才继续</strong>。</p><p>这两种方法在<code>if case let</code>代码中都同样有效。下面的代码同时使用它们在循环中过滤掉的<code>nil</code>值:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">let</span> data<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">Any</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Bill"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token number">69</span><span class="token punctuation">,</span> <span class="token string">"Ted"</span><span class="token punctuation">]</span><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span>datum<span class="token punctuation">)</span> <span class="token keyword">in</span> data <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>datum<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> datum<span class="token operator">?</span> <span class="token keyword">in</span> data <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>datum<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="匹配范围-Matching-ranges"><a href="#匹配范围-Matching-ranges" class="headerlink" title="匹配范围(Matching ranges)"></a>匹配范围(Matching ranges)</h3><p>你可能已经在使用与范围匹配的模式，通常使用如下代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> age <span class="token operator">=</span> <span class="token number">36</span><span class="token keyword">switch</span> age <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and time, but not the money"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and money, but not the time"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the time and money, but not the energy"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>对于常规条件语句，也可以使用非常相似的语法–我们可以这样重写代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token keyword">case</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span> <span class="token operator">=</span> age <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and time, but not the money"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token keyword">case</span> <span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span> <span class="token operator">=</span> age <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and money, but not the time"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the time and money, but not the energy"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>在使用类似语法的情况下，这将产生与<code>switch</code>块相同的结果，但我不太喜欢这种方法。我不喜欢它的原因很简单：我不认为<strong>如果0到18的范围等于年龄</strong>是合理的，如果你还不知道它这意味着什么。一个更好的方法是使用模式匹配操作符<code>~=</code>，它看起来像这样:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span> <span class="token operator">~</span><span class="token operator">=</span> age <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and time, but not the money"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span> <span class="token operator">~</span><span class="token operator">=</span> age <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and money, but not the time"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the time and money, but not the energy"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>现在条件是<strong>如果0到18的范围与年龄相匹配</strong>，我认为这更有意义。</p><p>当你记住<code>0..&lt;18</code>创建了一个具有自己方法集的<code>Range</code>结构的实例时，一个更清晰的解决方案就浮出水面了。现在，它的<code>contains()</code>方法特别有用：它的输入时间比<code>~=</code>长，但更容易理解：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and time, but not the money"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>age<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the energy and money, but not the time"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You have the time and money, but not the energy"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>你可以将此范围匹配组合到现有的元组匹配代码中，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"twostraws"</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">"fr0st1es"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">36</span><span class="token punctuation">)</span><span class="token keyword">switch</span> user <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">0</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the energy and time, but no money"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">18</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">&lt;</span> <span class="token number">70</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the money and energy, but no time"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">,</span> <span class="token number">_</span><span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> has the time and money, but no energy"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>最后一种情况将用户名绑定到名为<code>name</code>的本地常量，而不考虑元组中的其他两个值。这是一个匹配所有的<code>case</code>，但因为 <em>Swift</em> 寻找第一个匹配的<code>case</code>，这不会与<code>switch</code>块中的其他两个冲突。</p><h3 id="匹配枚举和关联值-Matching-enums-and-associated-values"><a href="#匹配枚举和关联值-Matching-enums-and-associated-values" class="headerlink" title="匹配枚举和关联值(Matching enums and associated values)"></a>匹配枚举和关联值(Matching enums and associated values)</h3><p>根据我的经验，相当多的人并不真正理解枚举和关联值，因此他们很难利用它们进行模式匹配。本书后面有一整章都是关于枚举的，所以如果你对枚举和相关的值还不熟悉的话，你可能需要在这里暂停并首先阅读该章节。</p><p>基本枚举匹配是这样的:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> cloudy   <span class="token keyword">case</span> sunny   <span class="token keyword">case</span> windy <span class="token punctuation">}</span><span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span>cloudy<span class="token keyword">switch</span> today <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">.</span>cloudy<span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>你还将在基本条件语句中使用枚举，如下所示:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> today <span class="token operator">==</span> <span class="token punctuation">.</span>cloudy <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>一旦你添加了关联值，事情就会变得更加复杂，因为你可以使用它们，过滤它们，或者根据你的目标忽略它们。</p><p>首先，最简单的选项：创建关联值，但忽略它：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>   <span class="token keyword">case</span> sunny   <span class="token keyword">case</span> windy<span class="token punctuation">}</span><span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">switch</span> today <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">.</span>cloudy<span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>使用这种方法，实际上<code>switch</code>代码是不变的。</p><p>第二：创建关联值并使用它。这使用了我们已经多次看到的相同的本地常量绑定：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>   <span class="token keyword">case</span> sunny   <span class="token keyword">case</span> windy<span class="token punctuation">}</span><span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">switch</span> today <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>最后：创建一个关联类型，将一个本地常量绑定到该类型，同时使用该绑定来筛选特定的值。它使用<code>where</code>关键字创建一个需求子句，以阐明你要查找的内容。在我们的例子中，下面的代码根据<code>cloudy</code>使用的关联值打印了两条不同的消息：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>   <span class="token keyword">case</span> sunny   <span class="token keyword">case</span> windy<span class="token punctuation">}</span><span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">switch</span> today <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> coverage <span class="token operator">&lt;</span> <span class="token number">100</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> coverage <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You must live in the UK"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>现在，正如我所承诺的，我将从基本示例开始构建，但是如果你已经准备好了，我想向你展示如何将这两种技术组合在一起：<strong>关联值和范围匹配</strong>。下面的代码现在打印了四条不同的消息：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">WeatherType</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span>   <span class="token keyword">case</span> sunny   <span class="token keyword">case</span> windy<span class="token punctuation">}</span><span class="token keyword">let</span> today <span class="token operator">=</span> <span class="token builtin">WeatherType</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token keyword">switch</span> today <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> coverage <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You must live in Death Valley"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>coverage<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's a bit cloudy, with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token number">51</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>coverage<span class="token punctuation">)</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's very cloudy, with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token keyword">let</span> coverage<span class="token punctuation">)</span> <span class="token keyword">where</span> coverage <span class="token operator">==</span> <span class="token number">100</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"You must live in the UK"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span>windy<span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's windy"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's sunny"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如果要匹配循环中的关联值，添加<code>where</code>子句是错误的方法。事实上，这类代码甚至无法编译:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> forecast<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">WeatherType</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">,</span> <span class="token punctuation">.</span>windy<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">]</span><span class="token keyword">for</span> day <span class="token keyword">in</span> forecast <span class="token keyword">where</span> day <span class="token operator">==</span> <span class="token punctuation">.</span>cloudy <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>day<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如果没有关联值，该代码就可以了，但是因为关联值意味着<code>where</code>子句不能胜任工作–它无法说<strong>并将关联的值绑定到本地常量</strong>。相反，你将回到<code>case-let</code>语法，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> forecast<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">WeatherType</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">,</span> <span class="token punctuation">.</span>windy<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">]</span><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">)</span> <span class="token keyword">in</span> forecast <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy with <span class="token interpolation"><span class="token delimiter variable">\(</span>coverage<span class="token delimiter variable">)</span></span>% coverage"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如果你想知道关联值，并想把它用作过滤条件，语法几乎是一样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> forecast<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">WeatherType</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">,</span> <span class="token punctuation">.</span>windy<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span>coverage<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">.</span>sunny<span class="token punctuation">]</span><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token punctuation">.</span><span class="token function">cloudy</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span> <span class="token keyword">in</span> forecast <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"It's cloudy with 40% coverage"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="匹配类型-Matching-types"><a href="#匹配类型-Matching-types" class="headerlink" title="匹配类型(Matching types)"></a>匹配类型(Matching types)</h3><p>你应该已经知道用于匹配的<code>is</code>关键字，但是你可能不知道它可以在循环和<code>switch</code>块中用于模式匹配。我觉得这个语法很好用，所以我想简单说明一下：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> view<span class="token punctuation">:</span> <span class="token builtin">AnyObject</span> <span class="token operator">=</span> <span class="token function">UIButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">switch</span> view <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UIButton</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a button"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UILabel</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a label"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UISwitch</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a switch"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UIView</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a view"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found something else"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>我以 <em>UIKit</em> 为例，因为你应该已经知道<code>UIButton</code>继承自<code>UIView</code>，我需要给你一个大大的警告…</p><p><strong>记住</strong>：<em>Swift</em> 将接受它找到的第一个匹配的情况，如果对象是特定类型或其父类之一，则<code>is</code>返回<code>true</code>。因此，上面的代码将打印 <strong>Found a button</strong>，而下面的代码将打印 <strong>Found a view</strong>：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> view<span class="token punctuation">:</span> <span class="token builtin">AnyObject</span> <span class="token operator">=</span> <span class="token function">UIButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">switch</span> view <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UIView</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a view"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UIButton</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a button"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UILabel</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a label"</span><span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token keyword">is</span> <span class="token builtin">UISwitch</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a switch"</span><span class="token punctuation">)</span><span class="token keyword">default</span><span class="token punctuation">:</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found something else"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>为了给你提供一个更有用的示例，你可以使用此方法循环数组中的所有子视图并筛选<code>UILabel</code>：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> label <span class="token keyword">in</span> view<span class="token punctuation">.</span>subviews <span class="token keyword">where</span> label <span class="token keyword">is</span> <span class="token builtin">UILabel</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a label with frame <span class="token interpolation"><span class="token delimiter variable">\(</span>label<span class="token punctuation">.</span>frame<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>尽管<code>where</code>确保在循环中只处理<code>UILabel</code>对象，但实际上它不执行任何类型转换。这意味着，如果你想访问<code>label</code>的特定属性，比如它的<code>text</code>属性，你需要自己对它进行类型转换。在这种情况下，使用<code>for case let</code>更容易，因为它在过滤的同时进行类型转换:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> label <span class="token keyword">as</span> <span class="token builtin">UILabel</span> <span class="token keyword">in</span> view<span class="token punctuation">.</span>subviews <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found a label with text <span class="token interpolation"><span class="token delimiter variable">\(</span>label<span class="token punctuation">.</span>text<span class="token delimiter variable">)</span></span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="使用WHERE关键词-Using-the-where-keyword"><a href="#使用WHERE关键词-Using-the-where-keyword" class="headerlink" title="使用WHERE关键词(Using the where keyword)"></a>使用WHERE关键词(Using the where keyword)</h3><p>为了总结模式匹配，我想演示一些有趣的使用<code>where</code>子句的方法，以便你了解它的功能。</p><p>首先，一个简单的方法：循环一组数字，只打印奇数。使用<code>where</code>和取模运算这很简单，但它表明<code>where</code>子句可以包含计算：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> number <span class="token keyword">in</span> numbers <span class="token keyword">where</span> number <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>也可以调用方法，如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> celebrities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Michael Jackson"</span><span class="token punctuation">,</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> <span class="token string">"Michael Caine"</span><span class="token punctuation">,</span> <span class="token string">"Adele Adkins"</span><span class="token punctuation">,</span> <span class="token string">"Michael Jordan"</span><span class="token punctuation">]</span><span class="token keyword">for</span> name <span class="token keyword">in</span> celebrities <span class="token keyword">where</span> <span class="token operator">!</span>name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这将打印 <strong><em>Taylor Swift</em></strong> 和 <strong><em>Adele Adkins</em></strong>。如果要使<code>where</code>子句更复杂，只需添加<code>&amp;&amp;</code>等运算符即可。</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> celebrities <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Michael Jackson"</span><span class="token punctuation">,</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> <span class="token string">"Michael Caine"</span><span class="token punctuation">,</span> <span class="token string">"Adele Adkins"</span><span class="token punctuation">,</span> <span class="token string">"Michael Jordan"</span><span class="token punctuation">]</span><span class="token keyword">for</span> name <span class="token keyword">in</span> celebrities <span class="token keyword">where</span> name<span class="token punctuation">.</span><span class="token function">hasPrefix</span><span class="token punctuation">(</span><span class="token string">"Michael"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>name<span class="token punctuation">.</span>characters<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">==</span> <span class="token number">13</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这将打印 <strong><em>Michael Caine</em></strong>。</p><p>虽然可以使用<code>where</code>子句剔除可选值，但我不推荐。请考虑下面的示例：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> celebrities<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"Michael Jackson"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Michael Caine"</span><span class="token punctuation">,</span> <span class="token constant">nil</span><span class="token punctuation">,</span> <span class="token string">"Michael Jordan"</span><span class="token punctuation">]</span><span class="token keyword">for</span> name <span class="token keyword">in</span> celebrities <span class="token keyword">where</span> name <span class="token operator">!=</span> <span class="token constant">nil</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这当然有用，但它对循环中的字符串的可选性没有任何影响，所以它输出如下:</p><pre class=" language-swift"><code class="language-swift"><span class="token function">Optional</span><span class="token punctuation">(</span><span class="token string">"Michael Jackson"</span><span class="token punctuation">)</span><span class="token function">Optional</span><span class="token punctuation">(</span><span class="token string">"Michael Caine"</span><span class="token punctuation">)</span><span class="token function">Optional</span><span class="token punctuation">(</span><span class="token string">"Michael Jordan"</span><span class="token punctuation">)</span></code></pre><p>相反，使用<code>for case let</code>来处理可选值，并使用<code>where</code>来过滤值。下面是编写循环的首选方法:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token keyword">case</span> <span class="token keyword">let</span> name<span class="token operator">?</span> <span class="token keyword">in</span> celebrities <span class="token keyword">where</span> name<span class="token punctuation">.</span><span class="token function">hasSuffix</span><span class="token punctuation">(</span><span class="token string">"Jackson"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>运行时，<code>name</code>只包含具有值且后缀为<code>Jackson</code>的字符串，因此其输出为:</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">Michael</span> <span class="token builtin">Jackson</span></code></pre><h2 id="空值合并-Nil-coalescing"><a href="#空值合并-Nil-coalescing" class="headerlink" title="空值合并(Nil coalescing)"></a>空值合并(Nil coalescing)</h2><p><em>Swift</em> 可选值是保证程序安全的基本方法之一：<strong>只有在变量确实具有值时才能使用它</strong>。问题是可选值使代码更难读和写，因为你需要安全地展开它们。</p><p>一种替代方法是使用<code>!</code>显式地展开可选值。这也被称为<strong>崩溃操作符</strong>，因为如果你在值为<code>nil</code>的可选值上使用<code>!</code>，你的程序将立即奔溃。</p><p>一个更聪明的选择是空合运算符<code>??</code>，它允许你访问可选值，并在可选值为<code>nil</code>时提供默认值。</p><p>考虑这个可选值:</p><pre><code>let name: String? = "Taylor"</code></pre><p>这是一个名为<code>name</code>的常量，包含一个字符串或<code>nil</code>。如果你试图用<code>print(name)</code>打印它，你会看到<code>Optional("Taylor")</code>，而不是<code>"Taylor"</code>，这不是你真正想要的。</p><p>使用空值合并允许我们使用可选的值，或者提供一个默认值（如果为<code>nil</code>）。所以，你可以这样写：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"Taylor"</span><span class="token keyword">let</span> unwrappedName <span class="token operator">=</span> name <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Anonymous"</span><span class="token function">print</span><span class="token punctuation">(</span>unwrappedName<span class="token punctuation">)</span></code></pre><p>这将打印<code>"Taylor"</code>: <code>name</code>是<code>String?</code>，但是<code>unwrappedName</code>保证是一个常量字符串(不是可选的)，因为使用了空合运算符。要查看默认值的实际操作，请尝试以下操作:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token constant">nil</span><span class="token keyword">let</span> unwrappedName <span class="token operator">=</span> name <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Anonymous"</span><span class="token function">print</span><span class="token punctuation">(</span>unwrappedName<span class="token punctuation">)</span></code></pre><p>现在将打印<code>"Anonymous"</code>，因为使用的是默认值。</p><p>当然，当使用空值合并时，你不需要一个单独的常量——你可以在内联中编写它，如下所示:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token operator">=</span> <span class="token string">"Taylor"</span><span class="token function">print</span><span class="token punctuation">(</span>name <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Anonymous"</span><span class="token punctuation">)</span></code></pre><p>正如您可以想象的那样，空值合并对于确保在使用前合理的值已经就位是非常非常有用的，但是它对于从代码中删除一些可选性特别有用。例如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">returnsOptionalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span><span class="token operator">?</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token constant">nil</span><span class="token punctuation">}</span><span class="token keyword">let</span> returnedName <span class="token operator">=</span> <span class="token function">returnsOptionalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Anonymous"</span><span class="token function">print</span><span class="token punctuation">(</span>returnedName<span class="token punctuation">)</span></code></pre><p>使用这种方法，<code>returnedName</code>是<code>String</code>而不是<code>String?</code>, 因为它是有值的。</p><p>到目前为止，一切都很简单。然而，当你将空值合并与<code>try?</code> 关键字结合起来时，它会变得更加有趣。</p><p>考虑一个简单的应用程序，它允许用户键入并保存文本。当应用程序运行时，它希望加载用户以前键入的任何内容，因此它可能使用如下代码：</p><pre><code>do {   let savedText = try String(contentsOfFile: "saved.txt")   print(savedText)} catch {   print("Failed to load saved text.")}</code></pre><p>如果文件存在，它将加载到<code>savedText</code>常量中。否则 <code>contentsOfFile</code>初始化器将抛出异常，并打印<strong>未能加载保存的文本</strong>。在实际中，你想要扩展它，以便<code>savedText</code>总是有一个值，所以你最终得到这样的结果:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> savedText<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token keyword">do</span> <span class="token punctuation">{</span>   savedText <span class="token operator">=</span> <span class="token keyword">try</span> <span class="token function">String</span><span class="token punctuation">(</span>contentsOfFile<span class="token punctuation">:</span> <span class="token string">"saved.txt"</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">{</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Failed to load saved text."</span><span class="token punctuation">)</span>   savedText <span class="token operator">=</span> <span class="token string">"Hello, world!"</span><span class="token punctuation">}</span><span class="token function">print</span><span class="token punctuation">(</span>savedText<span class="token punctuation">)</span></code></pre><p>这是很多代码，但实际上并没有完成很多工作。幸运的是，有一种更好的方法：空值合并。记住，<code>try</code>有三种变体：<code>try</code>尝试一些代码，并可能引发异常，<code>try！</code>尝试一些代码并在应用程序失败时崩溃，然后<code>try?</code>尝试一些代码，如果调用失败，则返回<code>nil</code>。</p><p>最后一个例子是空值合并的使用场景，因为这与前面的示例完全匹配：我们希望使用可选值，如果可选值为<code>nil</code>，则提供合理的默认值。事实上，使用空值合并，我们可以将所有这些代码重写为两行代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> savedText <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">try</span><span class="token operator">?</span> <span class="token function">String</span><span class="token punctuation">(</span>contentsOfFile<span class="token punctuation">:</span> <span class="token string">"saved.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">"Hello, world!"</span><span class="token function">print</span><span class="token punctuation">(</span>savedText<span class="token punctuation">)</span></code></pre><p>这意味着<strong>尝试加载文件，但如果加载失败，则使用此默认文本</strong>——更整洁的解决方案，可读性更高。</p><p>结合<code>try?</code>和空值合并非常适合于失败的<code>try</code>不是错误的情况，我认为你会发现这种模式在你自己的代码中非常有用。</p><h2 id="Guard"><a href="#Guard" class="headerlink" title="Guard"></a>Guard</h2><p>从 <em>Swift 2.0</em> 开始，<code>guard</code>这个关键字就一直伴随着我们，但是因为它一次性同时做了四件事，所以你没有充分使用它是值得原谅的。</p><p>第一种用法是最明显的：<code>guard</code>用于早期返回，这意味着如果某些前提条件不满足，则退出函数。例如，我们可以编写一个带有偏见的函数来给一个指定的人颁奖:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">giveAward</span><span class="token punctuation">(</span>to name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">guard</span> name <span class="token operator">==</span> <span class="token string">"Taylor Swift"</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No way!"</span><span class="token punctuation">)</span>      <span class="token keyword">return</span>   <span class="token punctuation">}</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Congratulations, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">giveAward</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span></code></pre><p>使用<code>giveAward(to:)</code>方法中的<code>guard</code>声明可以确保只有<code>Taylor Swift</code>赢得奖项。正如我所说，这是有偏见的，但是前提条件是明确的，并且只有在满足我设置的需求时，这段代码才会运行。</p><p>这个最初的示例看起来几乎与使用<code>if</code>相同，但是<code>guard</code>有一个巨大的优势：它使你的意图变得清晰，不仅对人们，而且对编译器也是如此。这是一个早期返回，也就是说，如果不满足前提条件，你希望退出该方法。使用<code>guard</code>可以清楚地表明：这种情况不是方法功能的一部分，只是为了确保实际的代码可以安全运行。编译器也很清楚，这意味着如果删除<code>return</code>语句，代码将不再生成—— <em>Swift</em> 知道这是一个早期返回，因此它不会让你忘记退出。</p><p>使用<code>guard</code>的第二个好处是第一个好处的副作用：使用<code>guard</code>和早期返回可以降低缩进级别。一些开发人员坚信不能使用早期的返回，相反，每个函数应该只从一个地方返回。会在函数代码的主体中强制进行额外的缩进，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">giveAward</span><span class="token punctuation">(</span>to name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> message<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">if</span> name <span class="token operator">==</span> <span class="token string">"Taylor Swift"</span> <span class="token punctuation">{</span>      message <span class="token operator">=</span> <span class="token string">"Congratulations, <span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span>!"</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      message <span class="token operator">=</span> <span class="token string">"No way!"</span>   <span class="token punctuation">}</span>   <span class="token keyword">return</span> message<span class="token punctuation">}</span><span class="token function">giveAward</span><span class="token punctuation">(</span>to<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span></code></pre><p>有了<code>guard</code>，你的先决条件立刻得到解决，并丢弃额外的缩进——为整齐的代码欢呼!</p><p><code>guard</code>带给我们的第三件事是提高主逻辑的明显性。这是软件设计和测试中的一个常见概念，指的是当没有异常或错误发生时，代码将采用的路径。由于有了<code>guard</code>，常见的错误会立即被删除，代码的其余部分可能都是正确的路径。</p><p>这些都是很简单的事情，但是<code>guard</code>还有一个我想要讨论的特性，它是<code>guard</code>和<code>if</code>之间的一个重要区别：当你使用<code>guard</code>检查和解包一个可选值时，这个可选值会留在作用域中。</p><p>为了演示这一点，我将重写<code>giveAward(To:)</code>方法，使它接受一个可选的字符串:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">giveAward</span><span class="token punctuation">(</span>to name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">guard</span> <span class="token keyword">let</span> winner <span class="token operator">=</span> name <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"No one won the award"</span><span class="token punctuation">)</span>      <span class="token keyword">return</span>    <span class="token punctuation">}</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Congratulations, <span class="token interpolation"><span class="token delimiter variable">\(</span>winner<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如果使用常规的<code>if-let</code>，<code>winner</code>常量只能在属于<code>guard</code>的大括号内使用。然而，<code>guard</code>在作用域中保持其可选的展开，因此<code>winner</code>将在第二个<code>print()</code>语句中保留。这段代码读作<strong>尝试将<code>name</code>解包到<code>winner</code>，这样我就可以使用它了，但是如果你不能，那么就打印一条消息并退出。</strong>”</p><p>我想介绍一下<code>guard</code>的最后一个特性，但它并不新鲜。相反，它只是一种使用你已经知道的东西的不同方式。特性是：<strong>如果前提条件失败，<code>guard</code>允许你退出任何范围，而不仅仅是函数和方法。</strong>这意味着你可以使用<code>guard</code>退出<code>switch</code>块或循环，它具有相同的含义：<strong>只有当这些前提条件为真时，才应执行此范围的内容。</strong></p><p>举个简单的例子，这个循环从 <em>1</em> 到 <em>100*，打印出所有能被 *8</em> 整除的数:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">100</span> <span class="token punctuation">{</span>   <span class="token keyword">guard</span> i <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">continue</span> <span class="token punctuation">}</span>   <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>你能用<code>where</code>重写一下吗？试一试——它比你想象的要容易！</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">// 答案</span><span class="token keyword">for</span> i <span class="token keyword">in</span> <span class="token number">1</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">100</span> <span class="token keyword">where</span>  i <span class="token operator">%</span> <span class="token number">8</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="懒加载-Lazy-loading"><a href="#懒加载-Lazy-loading" class="headerlink" title="懒加载(Lazy loading)"></a>懒加载(Lazy loading)</h2><p>延迟加载是 <em>Swift</em> 编码人员进行的最重要的全系统性能优化之一。它在 <em>iOS</em> 中很普遍，任何试图在视图控制器的视图显示之前操纵它的人都能告诉你。<em>Objective-C</em> 没有惰性属性的概念，因此每次需要这种行为时，都必须编写自己的样板代码。令人欣慰的是，<em>Swift</em> 已经将它完全融入其中，所以你几乎不需要任何代码就可以立即获得性能优势。</p><p>但首先：提醒一下什么是惰性属性。考虑一下这个类:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name   <span class="token punctuation">}</span>      <span class="token keyword">func</span> <span class="token function">reversedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token string">"\(name.uppercased()) backwards is \(String(name.uppercased().characters.reversed()))!"</span>   <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>taylor<span class="token punctuation">.</span><span class="token function">reversedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>这将在运行时打印 <strong><em>TAYLOR SWIFT backwards is TFIWS ROLYAT!</em></strong>。</p><p>每个<code>Singer</code>都有一个名为<code>name</code>的属性，还有一个方法对这个属性进行少量处理。显然，在你自己的代码中，这些函数可能会做更重要的工作，但是我在这里尽量保持简单。</p><p>每次你想打印消息 <strong><em>TAYLOR SWIFT reverse is TFIWS ROLYAT!</em></strong> 时，你都需要调用<code>reversedName()</code>方法——它所做的工作不会被存储，如果该工作不是琐碎的，那么重复调用该方法就是浪费。</p><p>另一种方法是创建一个额外的属性来存储<code>reversedName</code>，这样它只计算一次，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">let</span> reversedName<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name      reversedName <span class="token operator">=</span> <span class="token string">"\(name.uppercased()) backwards is \(String(name.uppercased().characters.reversed()))!"</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>taylor<span class="token punctuation">.</span>reversedName<span class="token punctuation">)</span></code></pre><p>对于经常使用<code>reversedName</code>的情况，这是一种性能改进，但是如果从不使用<code>reversedName</code>，则会导致代码运行得更慢——无论是否使用，都会计算它，而当<code>reversedName()</code>是一个方法时，它只会在调用时计算。</p><p>惰性属性是中间地带：它们是只计算一次并存储的属性，但是如果不使用它们，就永远不会计算。因此，如果你的代码重复使用惰性属性，那么只需要付出一次性能代价，如果这些属性从未使用过，那么代码就永远不会运行。这是双赢的!</p><h3 id="懒闭包-Lazy-closures"><a href="#懒闭包-Lazy-closures" class="headerlink" title="懒闭包(Lazy closures)"></a>懒闭包(Lazy closures)</h3><p>开始使用<code>lazy</code>关键字的最简单方法是使用闭包。 是的，我知道在同一个句子中看到 <strong><em>closures(闭包)</em></strong> 和<strong><em>easiest(最简单的)</em></strong> 的情况很少见，但有一个原因，这本书不叫<strong><em>Newbie Swift(新手Swift)！</em></strong></p><p>这里的语法一开始有点不寻常:</p><pre class=" language-Swift"><code class="language-Swift">lazy var yourVariableName: SomeType = {   return SomeType(whatever: "foobar")}()</code></pre><p>是的，你需要显式地声明类型。是的，你需要那个<code>=</code>号。是的，你需要在右大括号后面加上小括号。这有点不寻常，就像我说的，但它的存在是有原因的：你正在创建闭包，立即应用它(而不是稍后)，并将其结果分配回<code>variablename</code>。</p><p>使用这种方法，我们可以将<code>reversedName()</code>方法转换成如下所示的惰性属性：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name   <span class="token punctuation">}</span>   <span class="token keyword">lazy</span> <span class="token keyword">var</span> reversedName<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token string">"\(self.name.uppercased()) backwards is \(String(self.name.uppercased().characters.reversed()))!"</span>   <span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>taylor<span class="token punctuation">.</span>reversedName<span class="token punctuation">)</span></code></pre><blockquote><p><strong>注意</strong>：由于它现在是一个属性而不是方法，所以我们需要使用<code>print(taylor.reversedName)</code>而不是<code>print(taylor.reversedName())</code>来访问该值。</p></blockquote><p>就是这样：属性现在是惰性的，这意味着只有在第一次读取<code>reversedName</code>属性时才会执行闭包中的代码。</p><p>“<strong>但保罗，</strong>” 我听到你说，“<strong>你在一个由对象拥有的闭包中使用<code>self</code> - 为什么你给我一个循环引用？</strong>” 别担心：这段代码非常安全。 <em>Swift</em> 聪明到足以意识到正在发生的事情，并且不会创建任何循环引用。</p><p>在引擎下，任何这样的闭包 - 立即应用的 - 被认为是 <strong><em>non-escaping(非逃逸)</em></strong>，在我们的情况下意味着它不会在其他任何地方使用。 也就是说，此闭包不能存储为属性并稍后调用。 这不仅会自动确保<code>self</code>被认为是<code>unowned</code>，而且还使 <em>Swift</em> 编译器能够进行一些额外的优化，因为它有更多关于闭包的信息。</p><h3 id="懒方法-Lazy-methods"><a href="#懒方法-Lazy-methods" class="headerlink" title="懒方法(Lazy methods)"></a>懒方法(Lazy methods)</h3><p>在使用<code>lazy</code>时，人们经常抱怨它会使代码变得混乱：<code>lazy</code>属性不是属性和方法的简单分离，而是属性和功能混合在一起的灰色区域。对此有一个简单的解决方案：创建方法来将惰性属性从它们所依赖的代码中分离出来。</p><p>如果你想使用这种方法，我建议你将创建的单独方法标记为<code>private</code>，这样就不会意外地使用它。类似这样的东西应该会奏效：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">init</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">self</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name  <span class="token punctuation">}</span>   <span class="token keyword">lazy</span> <span class="token keyword">var</span> reversedName<span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token operator">=</span> <span class="token keyword">self</span><span class="token punctuation">.</span><span class="token function">getReversedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">private</span> <span class="token keyword">func</span> <span class="token function">getReversedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">String</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token string">"\(name.uppercased()) backwards is \(String(name.uppercased().characters.reversed()))!"</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span>name<span class="token punctuation">:</span> <span class="token string">"Taylor Swift"</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>taylor<span class="token punctuation">.</span>reversedName<span class="token punctuation">)</span></code></pre><h3 id="懒单例-Lazy-singletons"><a href="#懒单例-Lazy-singletons" class="headerlink" title="懒单例(Lazy singletons)"></a>懒单例(Lazy singletons)</h3><p>单例模式是我不太喜欢的几种常见编程模式之一。如果你不熟悉它们，那么单例就是一个值或对象，它被设计(和编码)为只创建一次，并在整个程序中共享。例如，如果你的应用程序使用一个日志程序，你可以在应用程序运行时创建一个日志程序对象，并让所有其他代码使用该共享实例。</p><p>我不太喜欢单例的原因很简单：<strong>它们经常被用作全局变量</strong>。许多人会鼓吹全局变量是不好的，然后很高兴地以几乎相同的方式滥用单例，这是草率的。</p><p>话虽如此，使用单例的理由也很充分，而且苹果有时也会使用单例。如果你的对象只能存在一次——比如一个<code>UIApplication</code>的实例——那么单例就有意义了。在 <em>iOS</em>系统中，像<code>UIDevice</code>这样的东西作为单例是有意义的，因为它们只能存在一次。如果你想在使用单例时添加额外的代码，单例也很有用(至少与全局变量相比)。</p><p>所以：只要你仔细考虑它们的使用，单例还是有一席之地的。如果你认为单例是完美的选择，我有个好消息：<em>Swift</em> 让单例变得异常容易。</p><p>举个实际的例子，我们将创建一个<code>Singer</code>类，它将有一个<code>MusicPlayer</code>类作为属性。这需要是一个单例，因为无论我们的应用程序中有多少歌手，我们都希望他们所有的歌曲通过同一个音乐播放器播放，这样音乐就不会重叠。</p><p>下面是<code>MusicPlayer</code>类:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span> <span class="token punctuation">{</span>   <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Ready to play songs!"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>它只在创建消息时打印消息。</p><p>下面是基本的<code>Singer</code>类，它在创建消息时只打印消息：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>   <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Creating a new singer"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>现在对于单例：如果我们想给<code>Singer</code>类一个<code>MusicPlayer</code> 单例属性，我们只需要在<code>Singer</code>类中添加一行代码:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">static</span> <span class="token keyword">let</span> musicPlayer <span class="token operator">=</span> <span class="token function">MusicPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>就是这样。<code>static</code>部分意味着这个属性由类共享，而不是由类的实例共享，这意味着你使用<code>Singer.musicPlayer</code>而不是<code>taylor.musicPlayer</code>。<code>let</code>部分当然意味着它是一个常量。</p><p>你可能想知道所有这些与惰性属性有什么关系，现在是时候找出答案了——将这段代码放到一个<code>playground</code>中:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">class</span> <span class="token class-name">MusicPlayer</span> <span class="token punctuation">{</span>   <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Ready to play songs!"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">class</span> <span class="token class-name">Singer</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token keyword">let</span> musicPlayer <span class="token operator">=</span> <span class="token function">MusicPlayer</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Creating a new singer"</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> taylor <span class="token operator">=</span> <span class="token function">Singer</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>当它运行时，输出是 <strong>Creating a new singer</strong> — <strong>Ready to play songs!</strong> 消息将不会出现。如果你在<code>playground</code>的结尾再加一行，只有这样，信息才会出现:</p><pre class=" language-swift"><code class="language-swift"><span class="token builtin">Singer</span><span class="token punctuation">.</span>musicPlayer</code></pre><p>是的：所有 <em>Swift</em> <code>static let</code>单例都是自动懒加载的——它们只有在需要时才会被创建。这很容易做到，但也非常有效。谢谢, <em>Swift</em> 开发团队!</p><h3 id="懒序列-Lazy-sequences"><a href="#懒序列-Lazy-sequences" class="headerlink" title="懒序列(Lazy sequences)"></a>懒序列(Lazy sequences)</h3><p>现在你已经了解了惰性属性，我想简要地解释一下惰性序列的用处。这些类似于延迟属性，因为它们将工作延迟到必要的时候，但是它们并不像你稍后将看到的那样高效。</p><p>让我们从一个简单的例子开始：斐波那契数列。提醒一下，这是从 <em>0</em> 和 <em>1</em>开始的数字序列，其中后面的每个数字都是前两个数字之和。序列是<code>0 1 1 2 3 5 8 13 21 34 55</code>，以此类推。</p><p>我们可以编写一个函数，该函数计算特定点的斐波那契数，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of num<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> num <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> num   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> num <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这是一个递归函数：它调用自己。这是一个 <strong>naïve (幼稚的)</strong> 实现，因为它不会在运行时缓存结果，这这意味着<code>fibonacci(of: num - 1</code>)所做的所有添加操作不会被<code>fibonacci(of: num - 2)</code>重用，即使它可以被重用。但是，这个实现非常适合演示延迟序列的好处(和缺点!)</p><p>打开一个 <em>Playground</em>，并添加以下代码:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of num<span class="token punctuation">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Int</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> num <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> num   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> num <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fibonacci</span><span class="token punctuation">(</span>of<span class="token punctuation">:</span> num <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> fibonacciSequence <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>fibonacciSequence<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>它计算斐波那契序列的前 <em>21</em> 个数字，并打印出第 <em>11<em>个数字：</em>55<em>。我让你把它放在</em>Playground*上，因为 *Xcode</em> 会告诉你代码执行的频率，你会看到返回 <em>num</em> 行被调用 <em>28656</em> 次——这是一个巨大的工作量。如果你尝试使用 <em>0…21</em> 作为范围-只是一个数字的提高！你会看到这个数字上升到 <em>46367</em> 次。</p><p>就像我说的，这是一个 <strong>naïve (幼稚的)</strong> 的实现,它的伸缩性不是很好。你能想象用 <em>0…199</em> 吗？如果你只需要几个数字，而不是所有的数字怎么办？</p><p>这就是延迟序列发挥作用的地方：你给它一个要处理的序列，并告诉它你想要运行什么代码，就像你对普通序列所做的一样，但是现在，当你访问项时，代码是按需执行的。因此，我们可以准备生成斐波那契数列的前 <em>200</em> 个数字，然后使用序列的惰性属性只使用第 <em>20</em> 个值:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lazyFibonacciSequence <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">199</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">lazy</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>lazyFibonacciSequence<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><blockquote><p>注意：你需要使用 <em>Array*，以确保 *Swift</em> 在数组上创建延迟映射，而不是在 <em>0…199</em> 范围内创建延迟映射。</p></blockquote><p>新代码的运行需要少量的时间，因为所有其他计算都不会运行—不会浪费时间。</p><p>然而，尽管延迟序列很聪明，但是它们有一个延迟属性所没有的缺点：它们没有记忆。这是一种常见的优化技术，它存储计算代价高昂的代码的结果，因此不需要再次创建它。这本质上是常规惰性变量提供给我们的：它不仅保证了一个属性在不使用的情况下不会被创建，而且保证了它在一次又一次使用时不会被重复创建。</p><p>正如我所说，延迟序列没有记忆，这意味着两次请求相同的数据将需要做两次工作。试试这个:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> lazyFibonacciSequence <span class="token operator">=</span> <span class="token function">Array</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token number">199</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">lazy</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>fibonacci<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>lazyFibonacciSequence<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>lazyFibonacciSequence<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>lazyFibonacciSequence<span class="token punctuation">[</span><span class="token number">19</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre><p>你将看到代码现在运行所需的时间是以前的三倍。因此，在必要时使用惰性序列，但是请记住，在某些情况下，它们实际上可能会减慢你的速度!</p><h2 id="析构-Destructuring"><a href="#析构-Destructuring" class="headerlink" title="析构(Destructuring)"></a>析构(Destructuring)</h2><p>析构(也称为分解)是将数据从元组传输到元组和从元组传输到元组的一种聪明的方法，当你开始理解它时，你将认识到析构和模式匹配是如何紧密地联系在一起的。析构有三种用途：<strong>将元组分成多个值，同时分配给多个对象，以及交换值</strong>。</p><p>考虑一下这个元组:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> data <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">)</span></code></pre><p>如果你想从这三个值中创建三个不同的常量，而不进行析构，你需要这样写:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> one <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token number">0</span><span class="token keyword">let</span> two <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token number">1</span><span class="token keyword">let</span> three <span class="token operator">=</span> data<span class="token punctuation">.</span><span class="token number">2</span></code></pre><p>通过析构，你可以这样写:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span>one<span class="token punctuation">,</span> two<span class="token punctuation">,</span> three<span class="token punctuation">)</span> <span class="token operator">=</span> data</code></pre><p><em>Swift</em> 将<code>data</code>元组分成三个单独的常量，所有这些都在一行代码中。</p><p>当你处理返回元组的函数时，这种技术尤其有用，当你希望返回多个值时，通常使用这种方法。通常需要分割这些返回值，以便你可以根据 <strong>terms(条款)</strong>引用它们，尤其是在元组中没有名称的情况下。例如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token builtin">String</span><span class="token punctuation">,</span> <span class="token builtin">Int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token string">"Taylor Swift"</span><span class="token punctuation">,</span> <span class="token number">26</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">let</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation"><span class="token delimiter variable">\(</span>name<span class="token delimiter variable">)</span></span> is <span class="token interpolation"><span class="token delimiter variable">\(</span>age<span class="token delimiter variable">)</span></span> years old"</span><span class="token punctuation">)</span></code></pre><p>如果你想在析构过程中忽略值，请使用<code>_</code>，如下所示:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token number">_</span><span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">getPerson</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"That person is <span class="token interpolation"><span class="token delimiter variable">\(</span>age<span class="token delimiter variable">)</span></span> years old"</span><span class="token punctuation">)</span></code></pre><p>你可以使用相同的技术同时分配多个内容，使用固定值或使用函数调用。例如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> <span class="token punctuation">(</span>captain<span class="token punctuation">,</span> chef<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"Janeway"</span><span class="token punctuation">,</span> <span class="token string">"Neelix"</span><span class="token punctuation">)</span><span class="token keyword">let</span> <span class="token punctuation">(</span>engineer<span class="token punctuation">,</span> pilot<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token function">getEngineer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getPilot</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>这在处理密切相关的值时尤其有用，比如矩形的坐标，并且可以帮助提高可读性。</p><p>最后，元组析构适合于交换值。现在，我要诚实地说:这种技巧在面试之外很少有用，即使在面试中，它也是一个相当糟糕的选择。然而，我想向你们展示它，因为我认为它展示了 <em>Swift</em> 是多么优雅。</p><p>那么，这里开始：给定两个整数 <em>A</em> 和 <em>B</em> ，如何在不使用第三个变量的情况下交换它们? 想一想，甚至可以在 <em>Playground</em> 上尝试一些代码。下面是用大多数语言解决这个问题的方法:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">10</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">20</span>a<span class="token operator">=</span>a<span class="token operator">+</span>bb<span class="token operator">=</span>a<span class="token operator">-</span>b a<span class="token operator">=</span>a<span class="token operator">-</span>b<span class="token function">print</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token function">print</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span></code></pre><p>在Swift中，多亏了析构，你可以把它写在一行:</p><pre class=" language-swift"><code class="language-swift"><span class="token punctuation">(</span>b<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span></code></pre><p>我认为她优雅、高效，而且相当漂亮。如果你在面试中被问到这个问题，你应该能够把它答好!</p><h2 id="带标签的语句-Labeled-statements"><a href="#带标签的语句-Labeled-statements" class="headerlink" title="带标签的语句(Labeled statements)"></a>带标签的语句(Labeled statements)</h2><p>标签已经使用了很长时间，但当开发人员开始对<code>goto</code>不满时，它们在很大程度上就不受欢迎了。<em>Swift</em> 把它们带回来，但没有<code>goto</code>：相反，它们与循环一起使用，让你更容易退出它们。</p><p>这里有一些代码可以创建一个字符串网格，并标记其中一个带有 <strong>x</strong> 的正方形，其中有一些宝藏 - 这是一个硬编码的位置，但在真实的游戏中，你显然会将其随机化。然后代码有两个循环试图找到宝藏，一个循环嵌套在另一个循环中：循环遍历板中的所有行，然后循环遍历每一行中的每一列。</p><p>这是代码：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> board <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span>board<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"x"</span><span class="token keyword">for</span> <span class="token punctuation">(</span>rowIndex<span class="token punctuation">,</span> cols<span class="token punctuation">)</span> <span class="token keyword">in</span> board<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>colIndex<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token keyword">in</span> cols<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> col <span class="token operator">==</span> <span class="token string">"x"</span> <span class="token punctuation">{</span>         <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found the treasure at row <span class="token interpolation"><span class="token delimiter variable">\(</span>rowIndex<span class="token delimiter variable">)</span></span> col <span class="token interpolation"><span class="token delimiter variable">\(</span>colIndex<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>考虑到宝藏可以出现在面板上出现一次，这段代码是相当浪费的：即使在搜索的早期就发现了宝藏，它也会继续查找。如果你认为是时候部署 <code>break</code>了，那么你是对的，至少在一定程度上是对的。它可能是这样的:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">for</span> <span class="token punctuation">(</span>rowIndex<span class="token punctuation">,</span> cols<span class="token punctuation">)</span> <span class="token keyword">in</span> board<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>colIndex<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token keyword">in</span> cols<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> col <span class="token operator">==</span> <span class="token string">"x"</span> <span class="token punctuation">{</span>        <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found the treasure at row <span class="token interpolation"><span class="token delimiter variable">\(</span>rowIndex<span class="token delimiter variable">)</span></span> col <span class="token interpolation"><span class="token delimiter variable">\(</span>colIndex<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span>         <span class="token keyword">break</span>     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>但是，<code>break</code>只退出一个循环级别，因此它将退出<code>for(colIndex,colo)</code>循环，然后继续运行<code>for(rowIndex，cols)</code>循环。是的，它浪费的时间更少，但它仍在浪费一些。你可以添加一个布尔变量，在找到宝藏时将其设置为<code>true</code>，然后你可以使用它来打破外部循环，但 <em>Swift</em> 有一个更好的解决方案：<strong>带标签的语句</strong>。</p><p>带标签的语句允许你为任何循环命名，这允许你在使用<code>break</code>或<code>continue</code>时引用特定循环。要创建标签，只需在任何循环之前写一个名称然后写一个冒号。然后，你可以使用<code>break yourLabelName</code>或<code>continue yourLabelName</code>直接引用它。</p><p>因此，编写该代码的最不浪费的方式是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">var</span> board <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">(</span>repeating<span class="token punctuation">:</span> <span class="token string">""</span><span class="token punctuation">,</span><span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">count</span><span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">)</span>board<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"x"</span>rowLoop<span class="token punctuation">:</span> <span class="token keyword">for</span> <span class="token punctuation">(</span>rowIndex<span class="token punctuation">,</span> cols<span class="token punctuation">)</span> <span class="token keyword">in</span> board<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">for</span> <span class="token punctuation">(</span>colIndex<span class="token punctuation">,</span> col<span class="token punctuation">)</span> <span class="token keyword">in</span> cols<span class="token punctuation">.</span><span class="token function">enumerated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> col <span class="token operator">==</span> <span class="token string">"x"</span> <span class="token punctuation">{</span>         <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Found the treasure at row <span class="token interpolation"><span class="token delimiter variable">\(</span>rowIndex<span class="token delimiter variable">)</span></span> col <span class="token interpolation"><span class="token delimiter variable">\(</span>colIndex<span class="token delimiter variable">)</span></span>!"</span><span class="token punctuation">)</span>         <span class="token keyword">break</span> rowLoop     <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>它会立即跳出两个循环，并在<code>for(rowIndex, cols)</code>循环结束后继续执行——非常好。</p><p>标记循环是聪明的，但是 <em>Swift</em> 更进一步：它允许你标记 <code>if</code> 语句，然后像标记循环一样从中中断。并且想要立即摆脱困境时，这是非常有用的，如果没有这些条件，你可能会得到一个由越来越多的缩进条件组成的金字塔。</p><p>下面是一个很好的例子，你可以看到它的实际应用：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">if</span> <span class="token function">userRequestedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token function">documentSaved</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token function">userAuthenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">if</span> <span class="token function">connectToNetwork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token function">uploadDocument</span><span class="token punctuation">(</span><span class="token string">"resignation.doc"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>               <span class="token keyword">if</span> <span class="token function">printDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Printed successfully!"</span><span class="token punctuation">)</span>               <span class="token punctuation">}</span>            <span class="token punctuation">}</span>         <span class="token punctuation">}</span>      <span class="token punctuation">}</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这段代码要经过一系列检查才能允许用户打印文档：不要尝试运行它，因为那些函数不是真的!</p><p>如果所有条件都为<code>true</code>，那么你将看到<strong>打印成功!</strong></p><p>标记语句允许你为<code>if</code>语句创建早期返回。它们正常运行，但在你认为有必要的任何时候，你都可以退出任何条件语句。例如，我们可以将上面的金字塔重写为:</p><pre class=" language-swift"><code class="language-swift">printing<span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token function">userRequestedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">documentSaved</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">userAuthenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">connectToNetwork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">uploadDocument</span><span class="token punctuation">(</span><span class="token string">"work.doc"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token operator">!</span><span class="token function">printDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Printed successfully!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>这样占用的行数更少，对读取代码的人的缩进也更少，而且很快就能找到满意的解决方案。</p><p>如果你愿意，你甚至可以使用<code>guard</code>来使你的意图更加清晰，就像这样:</p><pre class=" language-swift"><code class="language-swift">printing<span class="token punctuation">:</span> <span class="token keyword">if</span> <span class="token function">userRequestedPrint</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">guard</span> <span class="token function">documentSaved</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token keyword">guard</span> <span class="token function">userAuthenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token keyword">guard</span> <span class="token function">connectToNetwork</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token keyword">guard</span> <span class="token function">uploadDocument</span><span class="token punctuation">(</span><span class="token string">"work.doc"</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token keyword">guard</span> <span class="token function">printDocument</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token keyword">break</span> printing <span class="token punctuation">}</span>   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"Printed successfully!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>为了可读性，我更喜欢测试正面条件，而不是反面条件。也就是说，我宁愿测试<code>if documentsaved()</code>而不是<code>if !documentsaved()</code>是因为它更容易理解，而<code>guard</code>就是这样做的。</p><h2 id="嵌套函数、类和结构-Nested-functions-classes-and-structs"><a href="#嵌套函数、类和结构-Nested-functions-classes-and-structs" class="headerlink" title="嵌套函数、类和结构(Nested functions, classes and structs)"></a>嵌套函数、类和结构(Nested functions, classes and structs)</h2><p><em>Swift</em> 允许你将一种数据类型嵌套到另一种数据类型中，例如结构体中的结构体，类中的枚举或函数中的函数。这是最常用来帮助你按照逻辑行为在心理上将事物分组在一起的方法，但有时会附加访问语义，以防止不正确地使用嵌套数据类型。</p><p>让我们首先处理简单的情况：使用嵌套类型进行逻辑分组。考虑下面的代码，它定义了一个名为<code>London</code>的枚举:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> <span class="token builtin">London</span> <span class="token punctuation">{</span>   <span class="token keyword">static</span> <span class="token keyword">let</span> coordinates <span class="token operator">=</span> <span class="token punctuation">(</span>lat<span class="token punctuation">:</span> <span class="token number">51.507222</span><span class="token punctuation">,</span> long<span class="token punctuation">:</span> <span class="token operator">-</span><span class="token number">0.1275</span><span class="token punctuation">)</span>   <span class="token keyword">enum</span> <span class="token builtin">SubwayLines</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> bakerloo<span class="token punctuation">,</span> central<span class="token punctuation">,</span> circle<span class="token punctuation">,</span> district<span class="token punctuation">,</span> elizabeth<span class="token punctuation">,</span> hammersmithCity<span class="token punctuation">,</span> jubilee<span class="token punctuation">,</span> metropolitan<span class="token punctuation">,</span> northern<span class="token punctuation">,</span> piccadilly<span class="token punctuation">,</span> victoria<span class="token punctuation">,</span> waterlooCity   <span class="token punctuation">}</span>   <span class="token keyword">enum</span> <span class="token builtin">Places</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> buckinghamPalace<span class="token punctuation">,</span> cityHall<span class="token punctuation">,</span> oldBailey<span class="token punctuation">,</span> piccadilly<span class="token punctuation">,</span> stPaulsCathedral   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>该枚举有一个称为<code>coordinates</code>(坐标)的常量，然后是两个嵌套枚举：<strong><em>SubwayLines(地铁线路)</em></strong> 和 <strong><em>Places(位置)</em></strong>。但是，值得注意的是，它没有自己的<code>case</code> ——它只是被用作其他数据的包装器。</p><p>这样做有两个直接的好处：首先，任何具有代码完成功能的 <strong>IDE</strong> 都可以通过在键入时列出可能的选项(例如<code>London.Places.cityHall</code>)来快速、方便地深入到特定的项。其次，因为你实际上是在创建名称空间常量，所以你可以使用<code>Piccadilly</code>这样的合理名称，而不必担心你指的是地铁线路还是那个地方，或者你指的是 <strong><em>London Piccadilly</em></strong> 还是 <strong><em>Manchester Piccadilly</em></strong>。</p><p>如果你进一步扩展此技术，你将认识到你可以将其用于故事板 <em>ID*、表视图单元 *ID</em> 、图像名称，以及更有效地处理在苹果平台上非常流行的字符形式的资源类型。例如：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">enum</span> R <span class="token punctuation">{</span>   <span class="token keyword">enum</span> <span class="token builtin">Storyboards</span><span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> main<span class="token punctuation">,</span> detail<span class="token punctuation">,</span> upgrade<span class="token punctuation">,</span> share<span class="token punctuation">,</span> help   <span class="token punctuation">}</span>   <span class="token keyword">enum</span> <span class="token builtin">Images</span><span class="token punctuation">:</span> <span class="token builtin">String</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> welcome<span class="token punctuation">,</span> home<span class="token punctuation">,</span> about<span class="token punctuation">,</span> button  <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><p>如果你能理解为什么我用 <strong><em>R</em></strong> 来表示它，那就更好了。要使该技术适用于图像，只需将图像命名为与枚举<code>case</code>相同的名称，并在末尾加上 <em>.png</em> ，例如 <em>about.png</em>。</p><p>嵌套类型也适用于其他数据类型，例如，你可以有一个结构体，其中包含它自己的枚举:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Cat</span> <span class="token punctuation">{</span>   <span class="token keyword">enum</span> <span class="token builtin">Breed</span> <span class="token punctuation">{</span>      <span class="token keyword">case</span> britishShortHair<span class="token punctuation">,</span> burmese<span class="token punctuation">,</span> persian<span class="token punctuation">,</span> ragdoll<span class="token punctuation">,</span> russianBlue<span class="token punctuation">,</span> scottishFold<span class="token punctuation">,</span> siamese   <span class="token punctuation">}</span>   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token builtin">String</span>   <span class="token keyword">var</span> breed<span class="token punctuation">:</span> <span class="token builtin">Breed</span><span class="token punctuation">}</span></code></pre><p>你也可以把结构体放在结构体中，当它们一起使用时，例如:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Deck</span> <span class="token punctuation">{</span>   <span class="token keyword">struct</span> <span class="token builtin">Card</span> <span class="token punctuation">{</span>      <span class="token keyword">enum</span> <span class="token builtin">Suit</span> <span class="token punctuation">{</span>         <span class="token keyword">case</span> hearts<span class="token punctuation">,</span> diamonds<span class="token punctuation">,</span> clubs<span class="token punctuation">,</span> spades      <span class="token punctuation">}</span>      <span class="token keyword">var</span> rank<span class="token punctuation">:</span> <span class="token builtin">Int</span>      <span class="token keyword">var</span> suit<span class="token punctuation">:</span> <span class="token builtin">Suit</span>   <span class="token punctuation">}</span>   <span class="token keyword">var</span> cards <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Card</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>正如你在最后一个示例中所看到的，你可以根据需要多次嵌套，结构体嵌套结构体再嵌套枚举是完全合法的。</p><h3 id="嵌套语义-Nesting-with-semantics"><a href="#嵌套语义-Nesting-with-semantics" class="headerlink" title="嵌套语义(Nesting with semantics)"></a>嵌套语义(Nesting with semantics)</h3><p>逻辑分组的嵌套不会阻止你引用任何嵌套类型，但是如果嵌套太多，就会有点麻烦:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> home <span class="token operator">=</span> R<span class="token punctuation">.</span><span class="token builtin">Images</span><span class="token punctuation">.</span>home<span class="token keyword">let</span> burmese <span class="token operator">=</span> <span class="token builtin">Cat</span><span class="token punctuation">.</span><span class="token builtin">Breed</span><span class="token punctuation">.</span>burmese<span class="token keyword">let</span> hearts <span class="token operator">=</span> <span class="token builtin">Deck</span><span class="token punctuation">.</span><span class="token builtin">Card</span><span class="token punctuation">.</span><span class="token builtin">Suit</span><span class="token punctuation">.</span>hearts</code></pre><p>但是，<em>Swift</em> 允许你为嵌套类型分配访问控制修饰符，以控制它们的使用方式。当嵌套类型被设计为专门在其父级内部工作时，这很有用：如果<code>Card</code>结构体只能由<code>Deck</code>体结构使用，那么你需要访问控制。</p><blockquote><p>警告：如果属性使用私有类型，则属性本身必须是私有的。为了演示，让我们再次看一下<code>Deck</code>示例：</p></blockquote><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Deck</span> <span class="token punctuation">{</span>   <span class="token keyword">struct</span> <span class="token builtin">Card</span> <span class="token punctuation">{</span>      <span class="token keyword">enum</span> <span class="token builtin">Suit</span> <span class="token punctuation">{</span>         <span class="token keyword">case</span> hearts<span class="token punctuation">,</span> diamonds<span class="token punctuation">,</span> clubs<span class="token punctuation">,</span> spades      <span class="token punctuation">}</span>      <span class="token keyword">var</span> rank<span class="token punctuation">:</span> <span class="token builtin">Int</span>      <span class="token keyword">var</span> suit<span class="token punctuation">:</span> <span class="token builtin">Suit</span>   <span class="token punctuation">}</span>   <span class="token keyword">var</span> cards <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Card</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>如果我们希望<code>Suit</code>枚举是私有的，以便只有<code>Card</code>实例可以使用它，我们需要使用<code>private enum Suit</code>。然而，这具有连锁效应，要求<code>Card</code>的<code>suit</code>属性也是私有的，否则它将在<code>Suit</code>枚举不可用的地方进入。所以，更新之后的代码是这样的：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">struct</span> <span class="token builtin">Deck</span> <span class="token punctuation">{</span>   <span class="token keyword">struct</span> <span class="token builtin">Card</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">enum</span> <span class="token builtin">Suit</span> <span class="token punctuation">{</span>         <span class="token keyword">case</span> hearts<span class="token punctuation">,</span> diamonds<span class="token punctuation">,</span> clubs<span class="token punctuation">,</span> spades      <span class="token punctuation">}</span>      <span class="token keyword">var</span> rank<span class="token punctuation">:</span> <span class="token builtin">Int</span>      <span class="token keyword">private</span> <span class="token keyword">var</span> suit<span class="token punctuation">:</span> <span class="token builtin">Suit</span>   <span class="token punctuation">}</span>   <span class="token keyword">var</span> cards <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">Card</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="嵌套函数-Nested-functions"><a href="#嵌套函数-Nested-functions" class="headerlink" title="嵌套函数(Nested functions)"></a>嵌套函数(Nested functions)</h3><p>嵌套函数是嵌套类型访问控制的一个有趣的小例子，因为除非你您另有指定，否则它们将自动限制在其封闭函数中。<em>Swift</em> 将嵌套函数实现为命名闭包，这意味着它们将自动从其封闭函数中捕获值。</p><p>为了演示嵌套函数，我将创建一个函数，它使用三种距离计算技术之一计算两点之间的距离: 欧几里德(使用毕达哥拉斯定理)、欧几里德平方(使用毕达哥拉斯定理，但出于性能原因避免调用<code>sqrt()</code>和曼哈顿距离。如果你不熟悉这些术语，“欧几里得距离”基本上是在两点之间画一条直线，“曼哈顿距离”使用直线几何来计算两个笛卡尔坐标的绝对差。</p><p>首先，我们要使用的类型的代码:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">struct</span> <span class="token builtin">Point</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token builtin">Double</span>   <span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">}</span><span class="token keyword">enum</span> <span class="token builtin">DistanceTechnique</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> euclidean   <span class="token keyword">case</span> euclideanSquared   <span class="token keyword">case</span> manhattan<span class="token punctuation">}</span></code></pre><p>我创建了自己的<code>Point</code>类，以避免依赖于<code>CGPoint</code>和 <strong>Core Graphics</strong>。我们将创建三个函数，每个函数都嵌套在一个父函数中。本章的重点不是解释距离计算，所以让我们快速地把它们排除在外：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> deltaX <span class="token operator">=</span> start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x   <span class="token keyword">let</span> deltaY <span class="token operator">=</span> start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y   <span class="token keyword">return</span> deltaX <span class="token operator">*</span> deltaX <span class="token operator">+</span> deltaY <span class="token operator">*</span> deltaY<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>第一个函数<code>calculateEuclideanDistanceSquared()</code>使用毕达哥拉斯定理（勾股定理）计算两点之间的直线距离。如果你上学已经有一段时间了，这个函数认为两点之间的 <em>X</em> 和 <em>Y</em> 是三角形的两条边，然后计算出三角形的斜边就是两点之间的距离。</p><p>第二个函数<code>calculateEuclideanDistance()</code>建立在<code>calculateEuclideanDistanceSquared()</code>函数的基础上，通过计算结果的平方根来给出真实距离。如果需要非常频繁地计算距离，例如每次用户的手指移动时，调用<code>sqrt()</code>可能会影响性能，这就是<code>calculateEuclideanDistanceSquared()</code>函数存在的原因。</p><p>最后，第三个函数是<code>calculateManhattanDistance()</code>，它计算两个点的 <em>X</em> 和 <em>Y</em> 坐标之间的绝对距离之和，就好像你坐在一辆出租车上围绕城市中一个正方形街区行驶。</p><p>有了这三个嵌套函数，现在只需根据所要求的技术选择正确的选项:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">switch</span> technique <span class="token punctuation">{</span><span class="token keyword">case</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">:</span>   <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span>euclideanSquared<span class="token punctuation">:</span>   <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span><span class="token keyword">case</span> <span class="token punctuation">.</span>manhattan<span class="token punctuation">:</span>   <span class="token keyword">return</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>就是这样！以下是完整的代码:</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">import</span> <span class="token builtin">Foundation</span><span class="token keyword">struct</span> <span class="token builtin">Point</span> <span class="token punctuation">{</span>   <span class="token keyword">let</span> x<span class="token punctuation">:</span> <span class="token builtin">Double</span>   <span class="token keyword">let</span> y<span class="token punctuation">:</span> <span class="token builtin">Double</span><span class="token punctuation">}</span><span class="token keyword">enum</span> <span class="token builtin">DistanceTechnique</span> <span class="token punctuation">{</span>   <span class="token keyword">case</span> euclidean   <span class="token keyword">case</span> euclideanSquared   <span class="token keyword">case</span> manhattan<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">calculateDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> technique<span class="token punctuation">:</span> <span class="token builtin">DistanceTechnique</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> deltaX <span class="token operator">=</span> start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x      <span class="token keyword">let</span> deltaY <span class="token operator">=</span> start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y      <span class="token keyword">return</span> deltaX <span class="token operator">*</span> deltaX <span class="token operator">+</span> deltaY <span class="token operator">*</span> deltaY   <span class="token punctuation">}</span>   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">func</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">switch</span> technique <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span>   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclideanSquared<span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span>   <span class="token keyword">case</span> <span class="token punctuation">.</span>manhattan<span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">let</span> <span class="token builtin">distance</span> <span class="token operator">=</span> <span class="token function">calculateDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span> technique<span class="token punctuation">:</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">)</span></code></pre><p>现在，所有这些代码都是完全有效的，但它也比需要的更冗长。提醒一下，函数只是命名闭包，因此它们从其封闭函数中捕获任何值。</p><p>在这个上下文中，这意味着我们不需要让这三个嵌套函数接受任何参数，因为它们与封闭函数接受的参数相同——如果我们删除它们，它们就会被自动捕获。这有助于使我们的意图更清楚：这些嵌套函数只是在相同数据上操作的不同方式，而不是使用特定的值。</p><p>下面是<code>calculateDistance()</code>函数重写之后的代码，这样它就可以从嵌套函数中删除参数，而是依赖于捕获：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">calculateDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> technique<span class="token punctuation">:</span> <span class="token builtin">DistanceTechnique</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> deltaX <span class="token operator">=</span> start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x      <span class="token keyword">let</span> deltaY <span class="token operator">=</span> start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y      <span class="token keyword">return</span> deltaX <span class="token operator">*</span> deltaX <span class="token operator">+</span> deltaY <span class="token operator">*</span> deltaY   <span class="token punctuation">}</span>   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">func</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">switch</span> technique <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclideanSquared<span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token keyword">case</span> <span class="token punctuation">.</span>manhattan<span class="token punctuation">:</span>      <span class="token keyword">return</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="返回嵌套函数-Returning-nested-functions"><a href="#返回嵌套函数-Returning-nested-functions" class="headerlink" title="返回嵌套函数(Returning nested functions)"></a>返回嵌套函数(Returning nested functions)</h3><p>嵌套函数被自动限制在它们的封闭函数中，除非你另有指定，即如果你返回它们。记住，函数在 <em>Swift</em> 中属于一等公民 <em>(first-class data types)</em>，因此你可以使用一个函数根据特定条件返回另一个函数。在我们的例子中，我们可以将<code>calculatedDistance()</code>函数转换为<code>createdDistanceAlgorithm()</code>，它只接受一个技术参数，并根据请求的技术返回其三个嵌套函数之一。</p><p>我知道这是显而易见的，值得重复的是，当你使用这种方法时，嵌套函数将不再是私有的——它将作为返回值返回给任何人使用。</p><p>下面是重写<code>calculateDistance()</code>的代码，使它返回以下三个函数之一：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">func</span> <span class="token function">createDistanceAlgorithm</span><span class="token punctuation">(</span>technique<span class="token punctuation">:</span> <span class="token builtin">DistanceTechnique</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token builtin">Point</span><span class="token punctuation">,</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>      <span class="token keyword">let</span> deltaX <span class="token operator">=</span> start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x      <span class="token keyword">let</span> deltaY <span class="token operator">=</span> start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y      <span class="token keyword">return</span> deltaX <span class="token operator">*</span> deltaX <span class="token operator">+</span> deltaY <span class="token operator">*</span> deltaY   <span class="token punctuation">}</span>   <span class="token keyword">func</span> <span class="token function">calculateEuclideanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">sqrt</span><span class="token punctuation">(</span><span class="token function">calculateEuclideanDistanceSquared</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> start<span class="token punctuation">,</span> end<span class="token punctuation">:</span> end<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">func</span> <span class="token function">calculateManhattanDistance</span><span class="token punctuation">(</span>start<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">,</span> end<span class="token punctuation">:</span> <span class="token builtin">Point</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token builtin">Double</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>x <span class="token operator">-</span> end<span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">abs</span><span class="token punctuation">(</span>start<span class="token punctuation">.</span>y <span class="token operator">-</span> end<span class="token punctuation">.</span>y<span class="token punctuation">)</span>   <span class="token punctuation">}</span>   <span class="token keyword">switch</span> technique <span class="token punctuation">{</span>   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">:</span>      <span class="token keyword">return</span> calculateEuclideanDistance   <span class="token keyword">case</span> <span class="token punctuation">.</span>euclideanSquared<span class="token punctuation">:</span>      <span class="token keyword">return</span> calculateEuclideanDistanceSquared   <span class="token keyword">case</span> <span class="token punctuation">.</span>manhattan<span class="token punctuation">:</span>      <span class="token keyword">return</span> calculateManhattanDistance   <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>注意，这三个函数现在都需要接受参数，因为稍后将像这样调用它们：</p><pre class=" language-swift"><code class="language-swift"><span class="token keyword">let</span> distanceAlgorithm <span class="token operator">=</span> <span class="token function">createDistanceAlgorithm</span><span class="token punctuation">(</span>technique<span class="token punctuation">:</span> <span class="token punctuation">.</span>euclidean<span class="token punctuation">)</span><span class="token keyword">let</span> <span class="token builtin">distance</span> <span class="token operator">=</span> <span class="token function">distanceAlgorithm</span><span class="token punctuation">(</span><span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Point</span><span class="token punctuation">(</span>x<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">,</span> y<span class="token punctuation">:</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><h2 id="文档标记-Documentation-markup"><a href="#文档标记-Documentation-markup" class="headerlink" title="文档标记(Documentation markup)"></a>文档标记(Documentation markup)</h2><p><em>Swift</em> 有特殊的语法，允许你将 <em>Markdown</em> 格式的文本嵌入到源代码中，源代码由 <em>Xcode</em> 解析并显示在 <em>Quick Help</em> 系统面板中——在编码时按 <em>Alt+Cmd+2</em> 将其显示在 <em>Xcode</em> 窗口的右侧。使用特殊格式的代码注释，你可以记录应该传入哪些参数、返回值将包含哪些内容、可以抛出的任何错误等等。</p><p>此文档与添加到特定代码中的常规内联注释不同。这些特殊的注释放在函数和类之前，用于在 <em>Quick Help</em> 和代码提示弹出窗口中显示信息，并进行了格式化，以便人类和 <em>Xcode</em> 都能阅读它们。</p><p>让我们先把简单的事情解决掉：除非你使用后面介绍的特殊关键字之一，否则你在 <em>Markdown</em> 注释中编写的所有内容都将在 <em>Quick Help</em> 面板中显示为描述文本。如果你刚开始输入文本，你所写的内容将在代码提示弹出窗口中作为简要描述使用。<em>Xcode</em> 通常可以在自动补全的空间中填入 <em>20-30</em> 个单词，但这对于实际使用来说太长了——目标是大约 <em>10</em> 个单词的简洁描述。</p><p><em>Markdown<em>注释以/\</em>*开头，以\</em>/结尾，像这样：</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/**Call this function to grok some globs.*/</span><span class="token keyword">func</span> <span class="token function">myGreatFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do stuff</span><span class="token punctuation">}</span></code></pre><p>在本文中，你可以使用一系列 <em>Markdown</em> 格式，如下所示：</p><pre class=" language-swift"><code class="language-swift"><span class="token comment" spellcheck="true">/**  将文本放在`反引号`中以标记代码; 在你的键盘上这通常与波浪号〜共享一个键。  * 你可以用星号和空格开头来写项目描述。     * 缩进星号来创建子列表  1. 你可以以1.开始编写编号列表  1. 后续条目也可以以1.开始，Xcode会自动重新编号。   如果你想写一个链接，[把你的文本放在中括号里](链接放在小括号里)  # 标题以#号开始  ## 副标题以##开头  ### 子副标题以###开头，是你会遇到的最常见的标题样式  在文本前后写一个*星号*，使它成为斜体  在文本前后写**两个星号**，使它加粗*/</span></code></pre><h3 id="文档关键字-Documentation-keywords"><a href="#文档关键字-Documentation-keywords" class="headerlink" title="文档关键字(Documentation keywords)"></a>文档关键字(Documentation keywords)</h3><p>除了使用文本来描述函数外，<em>Swift</em> 还允许你添加在 <em>Quick Help</em> 窗格中显示的特殊关键字。有很多这样的工具，但是大多数都只显示一个标题和一些文本。我通常推荐六种有用的方法，你可以在几分钟内学会它们。</p><p>首先: <code>Returns</code>关键字允许你指定调用者在函数成功运行时期望返回的值。请记住代码自动补全提示已经显示了返回值的数据类型，所以这个字段用于描述数据的实际含义——我们知道它是一个字符串，但是它将如何格式化?</p><pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Returns</span><span class="token punctuation">:</span> A string containing a date formatted <span class="token keyword">as</span> <span class="token constant">RFC</span><span class="token operator">-</span><span class="token number">822</span></code></pre><p>接下来是<code>Parameter</code>关键字。这允许你指定参数的名称并描述它包含的内容。同样，代码自动补全提示会显示必须使用的数据类型，所以这是你提供一些细节的机会：*”The name of a Taylor Swift album”*。你可以包含尽可能多的参数行。</p><pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Parameter</span> album<span class="token punctuation">:</span> <span class="token builtin">The</span> name of a <span class="token builtin">Taylor</span> <span class="token builtin">Swift</span> album<span class="token operator">-</span> <span class="token builtin">Parameter</span> track<span class="token punctuation">:</span> <span class="token builtin">The</span> track number to load</code></pre><p>第三个是<code>Throws</code>关键字，它允许你指定一个用逗号分隔的错误类型列表，该函数可以抛出:</p><pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Throws</span><span class="token punctuation">:</span> <span class="token builtin">LoadError</span><span class="token punctuation">.</span>networkFailed<span class="token punctuation">,</span> <span class="token builtin">LoadError</span><span class="token punctuation">.</span>writeFailed</code></pre><p>第四个是<code>Precondition</code>，它应该用于在调用函数之前描述程序的正确状态。如果使用纯函数，这个先决条件应该只依赖于传递给函数的参数，例如<code>inputArray.count &gt; 0</code>:</p><pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Precondition</span><span class="token punctuation">:</span> inputArray<span class="token punctuation">.</span><span class="token builtin">count</span> <span class="token operator">></span> <span class="token number">0</span></code></pre><p>第五是<code>Complexity</code>，它在 <em>Swift</em> 标准库中很流行。在 <em>Quick Help</em> 中，这不是特别格式化的，但是对于使用代码的其他人来说，这是有用的信息。这应该用大O符号来写，例如:</p><pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Complexity</span><span class="token punctuation">:</span> <span class="token function">O</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span></code></pre><p>最后是<code>Authors</code>关键字，一开始听起来很有用，但我表示怀疑。可以想象，这用于将函数作者的名称写入 <em>Quick Help</em> 面板，当你需要确定应该向谁抱怨或表扬他们的工作时，这将非常有用。但是由于 <em>Xcode</em> 将<code>Authors</code>放在<code>Returns</code>、<code>Throws</code>和<code>Parameter</code>之前，添加一个认证信息只会把重要的字段往下推。尝试一下，看看你是怎么想的，但是请记住，文档首先是有用的。</p><pre class=" language-swift"><code class="language-swift"><span class="token operator">-</span> <span class="token builtin">Authors</span><span class="token punctuation">:</span> <span class="token builtin">Paul</span> <span class="token builtin">Hudson</span></code></pre><p>如果你在文档关键字之间包含更多的自由格式文本，那么它将在 <em>Quick Help</em> 中被正确地放置。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Pro Swift </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Swift </tag>
            
            <tag> Pro Swift </tag>
            
            <tag> 模式匹配 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
